
;; (setq debug-on-error t)
;; (setq debug-on-signal t)

;; This file sets up XEmacs C++ code formatting for Retroactive Fiasco source files.

;; This is the command that gets executed by default with "M-x compile".
(defvar compile-command "src_build -k root notags")

;; Make the tab key indent four spaces at a time, not eight.
(setq c-basic-offset 4)

;; Interpret hard tab characters read from a file as eight-character indents,
;; for compatibility with the rest of the world.
(setq tab-width 8)
(setq default-tab-width 8)
(setq tab-stop-list '(4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96))

;; Only insert spaces, and not tab characters, when the Tab key is pressed.
(setq-default indent-tabs-mode nil)

;; This enables auto-indenting for XML files.
(setq sgml-indent-data t)
(setq sgml-indent-step 4)

;; Show line numbers in the status bar.
(line-number-mode t)

;; Wrap comments at column 90.
;; We assume 100 character wide lines of source code.
(setq default-fill-column 90)

;; Don't end sentences with double spaces when fill-paragraph is used.
(setq sentence-end-double-space nil)

;; Hunt back up through the directory hierarchy for the TAGS file in the build subdirectory.
(defun find-retro-tags-file (path)
  (let* ((parent (file-name-directory path))
         (candidate-tags-file (concat parent "/build/TAGS")))
    (if (file-exists-p candidate-tags-file)
        candidate-tags-file
      (if (or (not (stringp parent)) (string= parent "/"))
          nil
        (find-retro-tags-file (directory-file-name parent))))))
(setq retro-tags-file (find-retro-tags-file (default-directory)))

;; Specify the TAGS file only if one was found.
(if (not (equal retro-tags-file nil))
    (setq tag-table-alist 
          (append 
           '(("/retro/src/" . retro-tags-file))
           (if (boundp 'tag-table-alist) (symbol-value 'tag-table-alist) nil))))

;; Don't bother asking if the tags completion table should be built.
(setq tags-build-completion-table t)

(add-hook 'c-mode-common-hook
          (lambda ()
            ;; Don't save backup files because we're using Subversion for that.
            (setq make-backup-files nil)

            ;; In cc-mode, when Ctrl+C, H is pressed, toggle between the current .h file
            ;; and its associated .cpp file, and vice versa.
            (define-key c-mode-base-map (kbd "C-c h") 'retro-header-source-toggle)

            ;; In cc-mode, when Ctrl+C, U is pressed, toggle between the current .h or
            ;; .cpp file and its associated unit test file.
            (define-key c-mode-base-map (kbd "C-c u") 'retro-unit-test-source-toggle)

            ;; In cc-mode, when Ctrl+C, T is pressed, create a template .h or .cpp file
            ;; with default class definitions based on the file name.
            (define-key c-mode-base-map (kbd "C-c t") 'retro-source-template)

            ;; In cc-mode, when Ctrl+C, O is pressed, output the expression in the current
            ;; line to std::cout, followed by a newline.
            (define-key c-mode-base-map (kbd "C-c o") 'retro-output-expression-to-cout)

            ;; In cc-mode, when Ctrl+C, J is pressed, provide an empty function definition
            ;; for the function declaration on the current line.
            (define-key c-mode-base-map (kbd "C-c j") 'retro-jump-to-function-definition)

            ;; In cc-mode, when Ctrl+C, D is pressed, run src_diff
            (define-key c-mode-base-map (kbd "C-c d") 'retro-diff)

            ;; In cc-mode, when Ctrl+C, C is pressed, run the compiler.
            (define-key c-mode-base-map (kbd "C-c c") 'compile)

            ;; In cc-mode, when Ctrl+C, N or Ctrl+C, P are pressed, jump to the next and
            ;; previous compiler error, respectively.
            (define-key c-mode-base-map (kbd "C-c n") 'next-error)
            (define-key c-mode-base-map (kbd "C-c p") 'previous-error)

            ))

;; Tell XEmacs to recogize assert failure messages generated by the Mac OS X 10.5 version
;; of GCC, so it's easy to jump to them automatically when they are output by assertion
;; failures within unit tests.
(eval-after-load "compile"
  '(add-to-list 'compilation-error-regexp-alist
                '("^Assertion failed: .*, file \\(.*?\\), line \\([0-9]*\\)." 1 2)))


;; Request that cc-mode be used for .h files.
(setq auto-mode-alist (append '(("\\.h\\'" . c++-mode)) auto-mode-alist))

;; Retroactive Fiasco C++ indentation style.
(defconst retro-cpp-style
  '(
    ;; tab-always-indent makes it impossible to tab without a C-q
    (c-tab-always-indent           . nil)
    (c-comment-only-line-offset    . 0)
    ;; The following keep code on the same line following a colon.
    (c-hanging-colons-alist        . ((member-init-intro before)
                                      (inher-intro)
                                      (case-label after)
                                      (label after)
                                      (access-label after)))
    ;; The following rules get applied after a close-brace.
    (c-cleanup-list                . (brace-else-brace
                                      scope-operator
                                      empty-defun-braces
                                      defun-close-semi))
    ;; BSD + Custom offsets
    ;; see "M-x help v c-offsets-alist" for a full description.
    (c-offsets-alist               . ((statement-block-intro . 4)
                                      (knr-argdecl-intro     . 4)
                                      (knr-argdecl           . 4)
                                      (substatement-open     . 0)
                                      (label                 . 0)
                                      (statement-cont        . 4)
                                      (inextern-lang         . 0)
                                      (arglist-cont-nonempty . 4)
                                      (arglist-intro         . 4)
                                      (arglist-cont          . 0)
                                      (stream-op             . 4)
                                      (func-decl-cont        . 4)
                                      (inher-cont            . 4)
                                      (innamespace           . 0)
                                      ))
;;  This is a 'printf' tool for debugging indentation rules
;;  (c-echo-syntactic-information-p . t)
    )
  "Retroactive Fiasco C++ Indentation Style")

(defun retro-c-mode-common-hook ()
  ;; Add my indentation style, defined below.
  (c-add-style "retro-indentation-style" retro-cpp-style t)

  ;; Turn off K&R syntax checking, which presumably is expensive.
  (setq c-recognize-knr-p nil)
  )

(add-hook 'c-mode-common-hook 'retro-c-mode-common-hook)


(defun retro-source-template ()
  "Creates template C++ source files."
  (interactive)

  ;; If the buffer is not empty, return immediately rather
  ;; than fill it with garbage.
  (if (not (equal (buffer-string) ""))
      (message "Buffer is not empty.")

    (progn
      (let* ((case-fold-search nil)

             (upcase-name
              (upcase (concat (substring (buffer-name) 0 1)
                              (replace-in-string 
                               (substring (substring (buffer-name) 1) 0 -2) "[A-Z]" "_\\&"))))

             (copyright-notice
              (concat "// Copyright "
                      (format-time-string "%Y" (current-time)) " Retroactive Fiasco."))

             (module-is-library              
              (and (not (file-exists-p "Main.cpp"))
                   (not (string-match "Main.cpp" (buffer-file-name))))))

        (if (and (string-match "/test/" (buffer-file-name))
                 (string= (substring (buffer-file-name)
                                     (- (length (buffer-file-name)) 8)
                                     (length (buffer-file-name))) "Test.cpp"))
            (retro-insert-default-unit-test-cpp-file)
   
          (if (string= (substring (buffer-file-name)
                                  (- (length (buffer-file-name)) 2)
                                  (length (buffer-file-name))) ".h")

              (retro-insert-default-h-cpp-file)

            (if (string= (substring (buffer-file-name)
                                    (- (length (buffer-file-name)) 9)
                                    (length (buffer-file-name))) "/Main.cpp")
                (retro-insert-default-main-cpp-file)

              (if (string= (substring (buffer-file-name)
                                      (- (length (buffer-file-name)) 4)
                                      (length (buffer-file-name))) ".cpp")
                  (retro-insert-default-cpp-file)

                (message "Not a C++ source file or header file")))))))))

(defun retro-insert-default-unit-test-cpp-file ()
  (let* ((mixedcase-name (substring (buffer-name) 0 -4))
         (tested-class-name (substring mixedcase-name 0 -4))
         (dir-name-list (split-string-by-char default-directory directory-sep-char))
         (current-dir (nth (- (length dir-name-list) 2) dir-name-list))
         (parent-dir (nth (- (length dir-name-list) 3) dir-name-list)))

    (insert copyright-notice)
    (insert "\n\n")

    (insert "#include <cppunit/extensions/HelperMacros.h>\n")
    (insert "\n")

    (insert "#include <")
    (insert parent-dir)
    (insert "/")
    (insert tested-class-name)
    (insert ".h>\n")
    (insert "\n")

    (insert "using ")
    (insert parent-dir)
    (insert "::")
    (insert tested-class-name)
    (insert ";\n")
    (insert "\n")

    (insert "class ")
    (insert tested-class-name)
    (insert "Test : public CppUnit::TestFixture\n")
    (insert "{\n")
    (insert "    CPPUNIT_TEST_SUITE(")
    (insert tested-class-name)
    (insert "Test);\n")
    (insert "    CPPUNIT_TEST(test%%);\n")
    (insert "    CPPUNIT_TEST_SUITE_END();\n")
    (insert "\n")
    (insert "public:\n")
    (insert "    void setUp() {\n")
    (insert "    }\n")
    (insert "\n")
    (insert "    void tearDown() {\n")
    (insert "    }\n")
    (insert "};\n")
    (insert "\n")
    (insert "CPPUNIT_TEST_SUITE_REGISTRATION(")
    (insert tested-class-name)
    (insert "Test);\n")

    (beginning-of-buffer)
    (search-forward "%%")
    (backward-delete-char 2)

    (recenter)
    (save-buffer)
    (retro-subversion-add-current-file)))

(defun retro-insert-default-h-cpp-file ()
  (let* ((mixedcase-name (substring (buffer-name) 0 -2))
         (dir-name-list (split-string-by-char default-directory directory-sep-char))
         (current-dir (nth (- (length dir-name-list) 2) dir-name-list)))

    (insert copyright-notice)
    (insert "\n\n")
         
    (insert "#ifndef ")

    (insert (upcase current-dir))
    (insert "__")
    (insert upcase-name)
    (insert "__INCLUDED")
    (insert "\n")
    (insert "#define ")
    (insert (upcase current-dir))
    (insert "__")
    (insert upcase-name)
    (insert "__INCLUDED")
    (insert "\n")
    (insert "\n")

    (if module-is-library
        (progn
          (insert "namespace ")
          (insert current-dir)
          (insert " {\n")
          (insert "\n")))
         
    (insert "// ")
    (insert mixedcase-name)
    (insert "\n")

    (insert "//\n")
    (insert "// %%\n")
    (insert "\n")

    (insert "class ")
    (insert mixedcase-name)
    (insert "\n")

    (insert "{\n")
    (insert "public:\n")
    (insert "    ")
    (insert mixedcase-name)
    (insert "();\n")
    (insert "    ~")
    (insert mixedcase-name)
    (insert "();\n")
    (insert "\n")
    (insert "private:\n")
    (insert "};\n")
    (insert "\n")

    (if module-is-library
        (progn
          (insert "} // namespace ")
          (insert current-dir)
          (insert "\n")
          (insert "\n")))

    (insert "#endif // ")
    (insert (upcase current-dir))
    (insert "__")
    (insert upcase-name)
    (insert "__INCLUDED\n")

    (beginning-of-buffer)
    (search-forward "%%")
    (backward-delete-char 2)

    (recenter)
    (save-buffer)
    (retro-subversion-add-current-file)))

(defun retro-insert-default-main-cpp-file ()

  (insert copyright-notice)
  (insert "\n\n")

  (insert "// %%\n")
  (insert "\n")

  (insert "#include <cstdlib>\n")
  (insert "#include <iostream>\n")
  (insert "\n")

  (insert "#include <opt/ProgramOptionsParser.h>\n")
  (insert "#include <con/Streams.h>\n")
  (insert "\n")

  (insert "static opt::ProgramOptionsParser gOptions;\n")
  (insert "\n")

  (insert "// Parse the command line arguments.\n")
  (insert "static void ParseCommandLineArguments(int argc, char **argv);\n")
  (insert "\n")

  (insert "int\n")
  (insert "main(int argc, char **argv)\n")
  (insert "{\n")
  (insert "    try {\n")
  (insert "\n")

  (insert "        ParseCommandLineArguments(argc, argv);\n")
  (insert "\n")

  (insert "    } catch (const std::exception &exception) {\n")
  (insert "        con::error << exception.what() << std::endl;\n")
  (insert "        exit(EXIT_FAILURE);\n")
  (insert "    }\n")
  (insert "\n")

  (insert "    return EXIT_SUCCESS;\n")
  (insert "}\n")
  (insert "\n")

  (insert "static void\n")
  (insert "ParseCommandLineArguments(int argc, char **argv)\n")
  (insert "{\n")
  (insert "    gOptions.setUsageSummary(\"input.rfm output.rfm [options]\");\n")
  (insert "    gOptions.setProgramPurpose(\"Reads an RFM file.\");\n")
  (insert "\n")

  (insert "    gOptions.addRequiredPositionalOptions()\n")
  (insert "        (\"input-file\", \"Input file\")\n")
  (insert "        (\"output-file\", \"Output file\")\n")
  (insert "        ;\n")
  (insert "\n")

  (insert "    gOptions.addOptions()\n")
  (insert "        (\"flag\", \"Flag\")\n")
  (insert "        (\"quality\", opt::value<int>(), \"Quality\")\n")
  (insert "        ;\n")
  (insert "\n")

  (insert "    // These only appear in the usage message when the --help-debug ")
  (insert "flag is specified.\n")
  (insert "    gOptions.addDebugOptions()\n")
  (insert "        (\"validate\", \"Validate the output\")\n")
  (insert "        ;\n")
  (insert "\n")

  (insert "    gOptions.parse(argc, argv);\n")
  (insert "}\n")

  (beginning-of-buffer)
  (search-forward "%%")
  (backward-delete-char 2)

  (recenter)
  (save-buffer)
  (retro-subversion-add-current-file))

(defun retro-insert-default-cpp-file ()
  (let* ((mixedcase-name (substring (buffer-name) 0 -4))
         (dir-name-list (split-string-by-char default-directory directory-sep-char))
         (current-dir (nth (- (length dir-name-list) 2) dir-name-list)))
         
    (insert copyright-notice)
    (insert "\n\n")

    (insert "#include \"")
    (insert mixedcase-name)
    (insert ".h\"\n")

    (insert "\n")

    (if module-is-library
        (progn
          (insert "namespace ")
          (insert current-dir)
          (insert " {\n")
          (insert "\n")))
         
    (insert mixedcase-name)
    (insert "::")
    (insert mixedcase-name)
    (insert "()%%\n")

    (insert "{\n")
    (insert "}\n")
    (insert "\n")

    (insert mixedcase-name)
    (insert "::~")
    (insert mixedcase-name)
    (insert "()\n")

    (insert "{\n")
    (insert "}\n")
    (insert "\n")

    (if module-is-library
        (progn
          (insert "} // namespace ")
          (insert current-dir)
          (insert "\n")))

    (beginning-of-buffer)
    (search-forward "%%")
    (backward-delete-char 2)

    (recenter)
    (save-buffer)
    (retro-subversion-add-current-file)))

;; Adds the file corresponding to the current buffer to the Subversion repository.
(defun retro-subversion-add-current-file ()
  "Adds the current buffer's file to the Subversion repository."
  (interactive)
  (let* ((result (shell-command-to-string (concat "svn add " buffer-file-name " ..")))
         (add-marker-index (string-match "A" result)))
    (if (equal add-marker-index 0)
        (message "Added to Subversion repository.")
      (message result))))

;; If this is a .cpp file, load the corresponding
;; header file, and vice versa.
(defun retro-header-source-toggle ()
  "Toggles between corresponding header and source files."
  (interactive)
  (if (string-match "/Main.cpp" (buffer-file-name))
      (message "Main.cpp should not have a corresponding header file.")
    (if (string-match "Test.cpp" (buffer-file-name))
        (message "Unit tests should not have a corresponding header file.")
      (if (string= (substring (buffer-file-name)
                              (- (length (buffer-file-name)) 2)
                              (length (buffer-file-name))) ".h")

          ;; If the current file is a .h file, try to load
          ;; the corresponding .cpp file if it exists -- otherwise
          ;; try to load the corresponding .c file.
          ;; If that fails, open the nonexistant corresponding .cpp file
          (if (file-exists-p (concat (substring (buffer-file-name) 0
                                                (- (length (buffer-file-name)) 2)) ".cpp"))
              (find-file (concat (substring (buffer-file-name) 0
                                            (- (length (buffer-file-name)) 2)) ".cpp"))
            (if (file-exists-p (concat (substring (buffer-file-name) 0
                                                  (- (length (buffer-file-name)) 2)) ".c"))
                (find-file (concat (substring (buffer-file-name) 0
                                              (- (length (buffer-file-name)) 2)) ".c"))
              (find-file (concat (substring (buffer-file-name) 0
                                            (- (length (buffer-file-name)) 2)) ".cpp"))))

        ;; If the current file is a .c file, try to load the
        ;; corresponding .h file.
        (if (string= (substring (buffer-file-name)
                                (- (length (buffer-file-name)) 2)
                                (length (buffer-file-name))) ".c")
            (find-file (concat (substring (buffer-file-name) 0
                                          (- (length (buffer-file-name)) 2)) ".h"))

          ;; If the current file is a .cpp file, try to load the
          ;; corresponding .h file.
          (if (string= (substring (buffer-file-name)
                                  (- (length (buffer-file-name)) 4)
                                  (length (buffer-file-name))) ".cpp")
              (find-file (concat (substring (buffer-file-name) 0
                                            (- (length (buffer-file-name)) 4)) ".h"))
            (message "Not a C source file or header file")
            )
          )
        )
      )

    ;; If the file is empty, do nothing. An older version of this function 
    ;; would fill the .cpp file with default code and check it into Subversion,
    ;; but this would tend to happen frequently when a .h file intentionally
    ;; had no corresponding .cpp file, and then we'd have to manually
    ;; do an 'svn move' to clean it up, which was annoying.
    ;; Given the new behavior, it's now necessary to use Ctrl+C,T to 
    ;; fill the .cpp file with default code, but that isn't such a big deal.
    )
  )

;; If this is a .cpp or .h file, load the corresponding
;; unit test .cpp file, and vice versa.
(defun retro-unit-test-source-toggle ()
  "Toggles between corresponding header file and unit test file."
  (interactive)
  (let* ((dir-name-list (split-string-by-char buffer-file-name directory-sep-char))
         (local-filename (nth (- (length dir-name-list) 1) dir-name-list))
         (current-dir (nth (- (length dir-name-list) 2) dir-name-list))
         (parent-dir (nth (- (length dir-name-list) 3) dir-name-list))
         (filename-component-list (split-string-by-char local-filename ?\.))
         (base-filename (first filename-component-list)))

    (if (string= current-dir "test")
        (progn
          (let* ((case-fold-search nil)
                 (source-filename (replace-in-string base-filename "Test" "")))
            (find-file (concat "../" source-filename ".h"))))
      (find-file (concat "test/" base-filename "Test.cpp")))))

;; Assume the current line is an expression, and replace it with an expression
;; that outputs that expression to std::out, prefixed with the expression
;; as a string. This aids in printf-debugging.
(defun retro-output-expression-to-cout ()
  "Rewrites the expression on the current line to output it to std::cout."
  (interactive)
  (beginning-of-line-text)
  (let ((start (point)))
    (end-of-line)
    (let* ((end (point))
           (expression (substring (buffer-string) (- start 1) (- end 1)))
           (expression (replace-in-string expression "^ +" "")))
      (delete-region start end)
      (insert "std::cout << \"" expression " = \" << " expression " << std::endl;"))))

;; Jump to the function definition corresponding to the function declaration
;; on the current line, or provide one if it does not already exist.
(defun retro-jump-to-function-definition ()
  "Provide an empty function definition for the function declaration on the current line."
  (interactive)
  (if (string-match "Test.cpp" (buffer-file-name))
      (retro-jump-to-unit-test-function-definition)
    (if (string= (substring (buffer-file-name)
                            (- (length (buffer-file-name)) 2)
                            (length (buffer-file-name))) ".h")
        (progn
          (let ((member-variable (retro-get-member-variable-declaration)))
            (if member-variable
                (retro-jump-to-accessor-function-declaration member-variable)
              (if (not (retro-jump-to-member-function-definition))
                  (message "Not a valid member variable or function declaration.")))))
      (if (string= (substring (buffer-file-name)
                              (- (length (buffer-file-name)) 4)
                              (length (buffer-file-name))) ".cpp")
          (if (not (retro-jump-to-member-function-declaration))
              (message "Not a valid function definition."))))))

;; Jump to the function definition corresponding to the unit test function declaration
;; on the current line, or provide one if it does not already exist.
(defun retro-jump-to-unit-test-function-definition ()

  ;; Find the unit test function declaration name on the current line.
  (string-match "CPPUNIT_TEST\(\\(.*\\)\);" (buffer-string) 
                (line-beginning-position))
  (if (not (and (match-beginning 1) (< (match-beginning 1) (line-end-position))))

      ;; If we're inside a unit test function definition, jump back to its declaration.
      (progn
        (let ((original-position (point)))
          (end-of-line)
          (if (search-backward-regexp "void \\([_a-zA-Z0-9]+\\)\(\) {" nil t)
              (if (search-backward (concat "CPPUNIT_TEST(" (match-string 1) ");") nil t)
                  (progn
                    (beginning-of-line)
                    (recenter))
                (goto-char original-position))
            (goto-char original-position))))

    (progn
      ;; The name of the unit test function declaration on the current line.
      (let ((current-unit-test (match-string 1 (buffer-string))))
        (if (search-forward (concat "void " current-unit-test "(") nil t)
            ;; If the corresponding unit test function definition already exists,
            ;; jump to it.
            (progn
              (recenter)
              (next-line 1)
              (beginning-of-line))

          ;; Otherwise, create a new function definition.
          (progn

            ;; Build a list of all of the unit test function declarations
            ;; in the file.
            (let ((start 0)
                  (test-list (list)))
              (while 
                  (string-match "CPPUNIT_TEST\(\\(test[_a-zA-Z0-9]+\\)\);" 
                                (buffer-string) start)
                (progn
                  (setq test-list
                        (append test-list (list (match-string 1 (buffer-string)))))
                  (setq start (match-end 0))
                  ))

              ;; Jump to the beginning of the file.
              (beginning-of-buffer)
              (search-forward "tearDown()")
              (search-forward-regexp "^    }")
              (next-line 1)
              (beginning-of-line)

              (let ((pos (point))
                    (start-pos (point)))

                ;; Hunt through the file for each unit test function
                ;; definition.
                (let (test (car test-list))
                  (while (not (string= test current-unit-test))
                    (let ((newpos (search-forward (concat "void " test "()") nil t)))
                      (if newpos
                          (setq pos newpos)))
                    (setq test (car test-list))
                    (setq test-list (cdr test-list))
                    )
                  (goto-char pos)
                  (if (not (equal pos start-pos))
                      (progn
                        (search-forward-regexp "^    }" nil t)
                        (next-line 1)
                        (beginning-of-line)))
                  
                  ;; Determine whether or not this will be the first function
                  ;; in the file. This affects whether we'll insert a blank
                  ;; line before the function or after it.
                  (let ((is-first-function (equal (point) start-pos)))

                    ;; Insert the new function definition.
                    (beginning-of-line)
                    (insert "\n")
                    (insert "    void " current-unit-test "() {\n")
                    (insert "        %%\n")
                    (insert "    }\n")
                    (search-backward "%%" nil t)
                    (delete-char 2)
                    (recenter)))))))))))

;; Jump to the function definition corresponding to the member function declaration
;; on the current line, or provide one if it does not already exist.
(defun retro-jump-to-member-function-definition ()

  (let ((original-pos (point))
        (return-type nil)
        (name nil)
        (arguments nil))

    ;; Get the components of the function declaration nearest the current line.
    (if (not (retro-parse-cpp-function-declaration 'return-type 'name 'arguments))
        ;; Return nil so an error message will be printed.
        nil

      (progn
        ;; Determine if the function is an accessor, and record
        ;; the name of the corresponding member variable
        ;; and an argument variable we can use to provide a default
        ;; set- or get- function definition later on.
        (let* ((is-set-function (and (> (length name) 3) (string= (substring name 0 3) "set")))

               (member-variable
                (if is-set-function
                    (concat "m" (substring name 3))
                  (concat "m" (upcase (substring name 0 1)) (substring name 1))))

               (argument-variable 
                (concat (downcase (substring member-variable 1 2))
                        (substring member-variable 2)))

               (is-accessor-function (search-forward (concat member-variable ";") nil t)))

          (goto-char original-pos)

          ;; Find the name of the class that the function was declared inside.
          ;; The ^; term keeps us from matching against forward declarations
          ;; of classes, like "class Foo;".
          (let ((class nil))
            (if (search-backward-regexp "^class +\\([_a-zA-Z0-9]+\\)\\(.\\|\\)" nil t)
                (progn
                  (if (not (string= (match-string 2) ";"))
                      (setq class (match-string 1)))))

            ;; Friend function definitions shouldn't reference classes.
            (if (string-match "friend" return-type)
                (setq class nil))

            ;; Strip out all keywords that should not appear in a function definition.
            (dolist (keyword (list "explicit" "static" "virtual" "friend" "inline"))
              (setq return-type 
                    (retro-trim-whitespace
                     (replace-in-string (concat return-type " ") (concat keyword " ") ""))))

            ;; Strip out any default value or pure virtual assignments in the argument list.
            ;; These should not appear in a function definition.
            (setq arguments (replace-in-string arguments " *= *\".*\" *" ""))
            (setq arguments (replace-in-string arguments " *= *[_a-zA-Z0-9\.]* *" ""))

;      (insert "\n")
;      (insert "\n")
;      (insert "return-type = " return-type "\n")
;      (insert "name = " name "\n")
;      (insert "arguments = " arguments "\n")
;      (insert "\n")

            (goto-char 0)
            (if (not (string= return-type ""))
                (if (or (search-forward-regexp (concat "enum *" return-type " *{") nil t)
                        (search-forward-regexp (concat "typedef.*" return-type ";") nil t)
                        (search-forward-regexp (concat "typedef.*" return-type " *{") nil t))
                    (setq return-type (concat class "::" return-type))
                  (let* ((tokens (split-string-by-char return-type ?\ ))
                         (base-type (nth 1 tokens)))
                    (goto-char 0)
                    (if (and base-type
                             (string= "const" (nth 0 tokens))
                             (or (search-forward-regexp 
                                  (concat "enum *" base-type " *{") nil t)
                                 (search-forward-regexp 
                                  (concat "typedef.*" base-type ";") nil t)
                                 (search-forward-regexp 
                                  (concat "typedef.*" base-type " *{") nil t)))
                        (setq return-type 
                              (replace-in-string return-type base-type 
                                                 (concat class "::" base-type)))))))

            ;; Build a list of all the function declarations in the file.
            (let ((function-list (list)))
              (goto-char 0)
              (while 
                  (search-forward ";" nil t)
                (let ((temp-return-type nil)
                      (temp-name nil)
                      (temp-arguments nil))
                  (if (retro-parse-cpp-function-declaration 
                       'temp-return-type 'temp-name 'temp-arguments)
                      (setq function-list
                            (append function-list (list temp-name))))))
              (goto-char original-pos)

              ;; Switch to the corresponding source file.
              (retro-header-source-toggle)

              ;; Find the function if it's already in the corresponding source file.
              (goto-char 0)
              (if (if class
                      (search-forward-regexp (concat "^" class "::" name "(") nil t)
                    (search-forward-regexp (concat "^" name "(") nil t))
                  (progn
                    (search-forward "{")
                    (next-line 1)
                    (beginning-of-line)
                    (recenter)
                    t
                    )

                ;; Otherwise, insert a default function definition.
                (progn
                  (beginning-of-buffer)
                  (search-forward "namespace" nil t)
                  (next-line 1)
                  (beginning-of-line)

                  ;; Hunt through the file for each function definition.
                  (let ((pos (point))
                        (start-pos (point))
                        (function (car function-list)))
                    (while (not (string= function name))
                      (if (string= function class)
                          (setq function (concat "~" function)))
                      (let ((newpos 
                             (if class
                                 (search-forward-regexp (concat "^" class "::" function "(") nil t)
                               (search-forward-regexp (concat "^" function "(") nil t))))
                        (if newpos
                            (setq pos newpos)))
                      (setq function (car function-list))
                      (setq function-list (cdr function-list))
                      )
                    (goto-char pos)
                    (if (not (equal pos start-pos))
                        (progn 
                          (search-forward-regexp "^}")
                          (next-line 1)
                          (beginning-of-line)))

                    (let ((original-position (point)))
                      (insert "\n")
                      (if (not (string= return-type ""))
                          (insert return-type "\n"))
                      (if class
                          (insert class "::" name arguments "\n")
                        (insert name arguments "\n"))
                      (insert "{\n")
                      ;; Indent the function arguments correctly.
                      (indent-region original-position (point) nil)
                      (if is-accessor-function
                          (if is-set-function
                              (insert "    " member-variable " = " argument-variable ";%%\n")
                            (insert "    return " member-variable ";%%\n"))
                        (insert "    %%\n"))
                      (insert "}\n")
                      (search-backward "%%")
                      (delete-char 2)
                      (recenter)
                      (message "Created new function definition."))
                    )
                  ;; Return t on success, so an error message will not be printed.
                  t)))))))))

;; From a C++ function definition, jump back to the corresponding
;; function declaration in the header file.
(defun retro-jump-to-member-function-declaration ()
  (let ((original-pos (point))
        (case-fold-search nil)
        (function-search-result 
         (or (end-of-line)
             (search-backward-regexp "^[A-Z][A-Za-z0-9_]*::\\([~A-Za-z0-9_]*\\)(" nil t)
             (search-backward-regexp "^\\([~A-Za-z0-9_]*\\)(" nil t)))
        (function (match-string 1)))
    (goto-char original-pos)
    (let ((previous-close-brace (search-backward-regexp "^}" nil t)))
      (goto-char original-pos)
      (if (and function-search-result
               (or (not previous-close-brace)
                   (> function-search-result previous-close-brace)))
          (progn
            (retro-header-source-toggle)
            (beginning-of-buffer)
            (search-forward-regexp (concat "[^A-Za-z0-9_~]" function "("))
            (beginning-of-line)
            (recenter)
            t
            )
        nil))))

;; Assuming the insertion point is sitting in the middle of a 
;; C++ function declaration, this function returns the function's
;; return type, name, and arguments. Quoted names of variables
;; to store the results in should be passed as arguments.
(defun retro-parse-cpp-function-declaration
  (return-type-symbol name-symbol arguments-symbol)

  ;; Save the original insertion point position so we can restore it later.
  (let ((original-pos (point)))

    (end-of-line)
    (let ((original-end-of-line-pos (point)))
      (beginning-of-line)

      ;; Find the end of the declaration.
      (search-forward ";" nil t)
      (let ((function-declaration-end (- (point) 1)))
        (search-backward ")" nil t)

        ;; Go to the opening parenthesis at the beginning of the
        ;; function's argument list.
        (let ((pos (- (point) 1 ))
              (level 1))
          (while (and
                  (not (eq level 0))
                  (not (eq pos (point-min))))
            (if (eq (char-after pos) ?\()
                (setq level (- level 1)))
            (if (eq (char-after pos) ?\))
                (setq level (+ level 1)))
            (setq pos (- pos 1))
            )
          (setq pos (+ pos 1))
          (goto-char pos))

        ;; Extract the name of the function.
        ;; This must work correctly for constructors, destructors, and operators.
        (let ((function-name-end (point)))
          (search-backward-regexp "[ ]*" nil t)
          (search-backward-regexp "[_a-zA-Z0-9~]" nil t)
          (let ((function-name-begin (+ (search-backward-regexp "[^_a-zA-Z0-9~]" nil t) 1)))
            (set name-symbol 
                 (retro-trim-whitespace
                  (buffer-substring function-name-begin function-name-end)))

            ;; Find the beginning of the function declaration.
            (beginning-of-line)
            (search-forward-regexp "[^ \n]" nil t)
            (let ((function-declaration-begin (- (point) 1)))

              (if (> function-declaration-begin original-end-of-line-pos)
                  ;; If the function declaration starts after
                  ;; the end of the line the cursor was originally on,
                  ;; then we've most likely grabbed some other function declaration
                  ;; that wasn't on the current line, and this is an error.
                  (progn
                    (goto-char original-pos)
                    nil)
                (progn
                  ;; Get all of the text before and after the function name.
                  (set return-type-symbol 
                       (retro-trim-whitespace 
                        (buffer-substring function-declaration-begin function-name-begin)))
                  (set arguments-symbol 
                       (retro-trim-whitespace 
                        (buffer-substring function-name-end function-declaration-end)))

                  ;; Put the insertion point back to where it originally was.
                  (goto-char original-pos)

                  ;; Return nil if it's a function declaration that already has an inline
                  ;; definition, or is otherwise invalid.
                  (not (string-match "{\\|;" (eval arguments-symbol))))))))))))


;; Strip off leading and trailing whitespace from a string.
(defun retro-trim-whitespace (string)
  (replace-in-string (replace-in-string string " $" "") "^ " ""))

;; Return the member variable declared on the current line.
(defun retro-get-member-variable-declaration ()
  (let ((original-pos (point)))
    (beginning-of-line)
    (let ((beginning-of-line-pos (point)))
      (end-of-line)
      (let ((end-of-line-pos (point))
            (case-fold-search nil))
        (beginning-of-line)
        (if (search-forward-regexp "^.*[^a-zA-Z0-9_]\\(m[A-Z][a-zA-Z0-9_]*\\).*;" nil t)
            (progn
              (goto-char original-pos)
              (if (and (match-string 1)
                       (> (match-beginning 1) beginning-of-line-pos)
                       (< (match-beginning 1) end-of-line-pos))
                  (match-string 1)
                nil))
          nil)))))

;; Jump to the accessor functions corresponding to the specified member variable,
;; or create ones if they don't already exist.
(defun retro-jump-to-accessor-function-declaration (target-member-variable)

  ;; Build a list of all the member variables.
  (let ((start 0)
        (member-variable-list (list))
        (case-fold-search nil))
    (while 
        (string-match "^.*[^a-zA-Z0-9_m]\\(m[A-Z][a-zA-Z0-9_]*\\).*;"
                      (buffer-string) start)
      (progn
        (setq member-variable-list
              (append member-variable-list (list (match-string 1 (buffer-string)))))
        (setq start (match-end 0))))

    (beginning-of-buffer)

    (if (string-match (concat "^ *\\(.*\\)" target-member-variable ";") (buffer-string))
        (setq member-variable-type (retro-trim-whitespace (match-string 1 (buffer-string))))
      (progn
        (message "Could not determine type for member variable.")))

    ;; Try to find the set-accessor function if it already existsw.
    (let ((target-set-function (concat "set" (substring target-member-variable 1)))
          (target-get-function (concat (downcase (substring target-member-variable 1 2)) 
                                       (substring target-member-variable 2))))
      (beginning-of-buffer)
      (if (search-forward (concat target-set-function "(") nil t)
          (progn
            (beginning-of-line)
            (recenter))

        ;; It doesn't already exist, so create both accessor functions.
        (progn
          ;; Jump to the beginnng of the file.
          (beginning-of-buffer)
          (search-forward "public:")
          (search-forward "~")
          (beginning-of-line)
          (let ((pos (point)))

            ;; Hunt through the file for each
            ;; function definition.
            (let ((member-variable (car member-variable-list)))
              (while (not (string= member-variable target-member-variable))
                (let ((set-function (concat "set" (substring member-variable 1)))
                      (get-function (concat (downcase (substring member-variable 1 2)) 
                                            (substring member-variable 2))))
                  (setq newpos (search-forward (concat set-function "(") nil t))
                  (if newpos
                      (progn
                        (setq pos newpos)
                        (let ((newpos (search-forward (concat get-function "()") nil t)))
                          (if newpos
                              (setq pos newpos)))))
                  (setq member-variable (car member-variable-list))
                  (setq member-variable-list (cdr member-variable-list))))
              (goto-char pos)
              (search-forward ";" nil t)
              (beginning-of-line)
              (next-line 1)

              (insert "\n")
              (insert "    // %%\n")

              (if (string= (substring member-variable-type -1) "*")
                  (progn
                    (insert "    void " target-set-function 
                            "(" member-variable-type target-get-function ");\n")
                    (insert "    " member-variable-type target-get-function "() const;\n"))
                (if (retro-type-is-intrinsic member-variable-type)
                    (progn
                      (insert "    void " target-set-function 
                              "(" member-variable-type " " target-get-function ");\n")
                      (insert "    " member-variable-type " " target-get-function "() const;\n"))
                  (progn
                    (insert "    void " target-set-function 
                            "(const " member-variable-type " &" target-get-function ");\n")
                    (insert "    const " member-variable-type " &" target-get-function 
                            "() const;\n"))))
        
              (search-backward "%%")
              (delete-char 2)
              (recenter))))))))

;; Returns t if the specified type is intrinsic.
(defun retro-type-is-intrinsic (type)
  (or (string= (substring type (- (length type) 3) (length type)) "Ptr")
      (string= type "bool")
      (string= type "char")
      (string= type "int")
      (string= type "long")
      (string= type "unsigned")
      (string= type "unsigned char")
      (string= type "unsigned int")
      (string= type "unsigned long")
      (string= type "signed char")
      (string= type "signed int")
      (string= type "signed long")
      (string= type "long long")
      (string= type "long int")
      (string= type "float")
      (string= type "double")
      (string= type "int8_t")
      (string= type "uint8_t")
      (string= type "int16_t")
      (string= type "uint16_t")
      (string= type "int32_t")
      (string= type "uint32_t")
      (string= type "int64_t")
      (string= type "uint64_t")
      (string= type "intptr_t")
      (string= type "uintptr_t")
      (string= type "int_least8_t")
      (string= type "uint_least8_t")
      (string= type "int_least16_t")
      (string= type "uint_least16_t")
      (string= type "int_least32_t")
      (string= type "uint_least32_t")
      (string= type "int_least64_t")
      (string= type "uint_least64_t")
      (string= type "int_fast8_t")
      (string= type "uint_fast8_t")
      (string= type "int_fast16_t")
      (string= type "uint_fast16_t")
      (string= type "int_fast32_t")
      (string= type "uint_fast32_t")
      (string= type "int_fast64_t")
      (string= type "uint_fast64_t")
      (string= type "intmax_t")
      (string= type "uintmax_t")
      (string= type "u_char")
      (string= type "u_short")
      (string= type "u_int")
      (string= type "u_long")
      (string= type "ushort")
      (string= type "uint")
      (string= type "dev_t")
      (string= type "gid_t")
      (string= type "in_addr_t")
      (string= type "in_port_t")
      (string= type "ino_t")
      (string= type "key_t")
      (string= type "mode_t")
      (string= type "nlink_t")
      (string= type "id_t")
      (string= type "pid_t")
      (string= type "off_t")
      (string= type "uid_t")
      (string= type "clock_t")
      (string= type "size_t")
      (string= type "ssize_t")
      (string= type "time_t")
      (string= type "useconds_t")
      (string= type "suseconds_t")
      (string= type "pthread_addr_t")
      (string= type "pthread_cond_t")
      (string= type "pthread_condaddr_t")
      (string= type "pthread_mutex_t")
      (string= type "pthread_mutexaddr_t")
      (string= type "pthread_once_t")
      (string= type "pthread_rwlock_t")
      (string= type "pthread_rwlockaddr_t")
      (string= type "pthread_t")
      (string= type "pthread_key_t")
      (string= type "fsblkcnt_t")
      (string= type "fsfilcnt_t")))

;; Runs src_diff on the file corresponding to the current buffer.
(defun retro-diff ()
  "Runs src_diff on the file corresponding to the current buffer."
  (interactive)
  (shell-command (concat "src_diff " buffer-file-name)))
