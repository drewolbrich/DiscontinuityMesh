
- Long term:
    - Finish the shadow code.
    - Write CSG code.
    - Write code for constructing environments in-game using CSG operations 
        interactively driven by a scripting language.
    - Spend a year doing little one-off hastily written game experiments to "identify the fun".
    - Create a real schedule, and then semipublically commit to it in a blog or among
        a small group of friends, to provide artificial motivation.

X Rename cgmath/WriteMatrix to MatrixInternal or something implying it's not for
    general use, and rename the WriteMatrix function as well.

X In SConstruct, add code to ignore all subdirectories that aren't called "test".
    X Ignore them instead of rejecting them, because maybe I'll
        want to put in subdirectories of documentation.

X Write my own CppUnit code to print out unit test output in a form that isn't quite as ugly.

X Write unit tests for everything in cgmath.
    X Vector2f
    X Vector3f
    X Vector4f
    X Matrix3f
    X Matrix4f

X Add an xemacs directory and put a Retroactive Fiasco specific XEmacs init file in it.
    Switch to loading that one by default instead of what I'm loading now.

X Change the cgmath_internal namespace to cgmath::internal.

X Write an src_diff script.

X Write unit tests for cgmath.

X Double-check vector premultiplication and postmultiplication,
    especially the Vector3f cases. I just changed this to handle
    homogeneous coordinates.

X Split out the Vector3f and Vector4f vector matrix multiply tests into
    two separate functions. Make the Vector3f test do a real test of the
    division by 'w'. Create a matrix which rotates the vector 90 degrees
    and then causes the elements of the resulting vector to be divided by two.

X Write an XEmacs macro to automatically create a unit test template.

X Write an XEmacs macro to add a unit test.

X Write an XEmacs macro that toggles between the current source file and the unit test 
    corresponding to the current file.

X Write an XEmacs macro to create a function definition for the function declaration
    on the current line.
    X If the return type refers to an enum or typedef defined in the
        header, it should be prefixed with the class name.

X The macro that jumps to the corresponding header or source file should
    populate it with default code if it's empty.

X Write an XEmacs macro to print the expression on the current line.

X Write an XEmacs macro to create accessor function declarations for the
    member variable on the current line.

X Change the macros so they search for existing functions for placement of new
    functions in order, rather than in reverse order.
    X After a function is found, just regexp-search for "^}$" to hop to the
        end of the function definition.

X Have Scons print concise output with prefixes like "Compiling" or "Linking"
    or "Running unit test" depending on what's going on. Skip the ranlib lines.

X Make Ctrl+C,J switch from a member function definition in a .cpp file back
    to the function declaration in the header file.

X Automatically fill out function definition body when the function declaration
    is an accessor.

X Write unit tests for the rest of the geometric predicates.

X Make Ctrl+C,H do nothing for unit test files, so I don't wind up checking
    a header for the unit test into Subversion.

X Make Ctrl+C,T create boilerplate source code for Main.cpp as a special case.

X Make some kind of standard class for parsing command line arguments
    without so much of the boilerplate boost::program_options code I have 
    in my Main.cpp files.

X Convert all programs over to use opt::ProgramOptionsParser.

X Convert triangulate_points and triangulate_polygons over to use ProgramOptionsParser.

X Look into boost/program_options/value_semantic.hpp to see if I can support
    processing Vector3f arguments directly, with multiple arguments specified
    using spaces instead of commas. Make sure this works with negative numbers.

X Put examples in the comments of opt/ProgramOptionsParser.h.

X Make the Main.cpp xemacs template use ProgramOptionsParser.

X Replace most of the setq's in the xemacs file with let.

X Reimplement src/con/ProgramName.cpp's platform-specific code in terms
    of boost::filesystem::path.

- Make Ctrl+C,T not put constructor and destructor definitions in the .cpp file
    if they're no longer present in the .h file.

- Make Ctrl+C,T use the same namespace as the .h file.

X When XEmacs tries to add a C++ file to Subversion, it should also first try to
    add the directory that the file is in, if that's necessary,
    so I don't have to add libraries manually.

- Automatically add to the initialization list when a member variable's
    accessor functions are created.

- In a .cpp file, Ctrl+C,J should create function definitions in that .cpp file
    if the insertion point is sitting on a global function declaration at the top
    of the .cpp file.

- Make Ctrl+C,U go from a .cpp or .h file to the corresponding unit test .cpp file,
    but go from a unit test .cpp file to the corresponding .cpp file.

- Make Ctrl+C,H go from a unit test .cpp file to the corresponding .h file.

- Write an XEmacs macro to add a unit test for a C++ function I'm sitting in
    in a library directory.
    - This must also create the test subdirectory and check it into Subversion
        if it doesn't already exist.

- Allow for a region to be selected containing multiple member variable declarations,
    and automatically create accessor functions for each.

- Allow for a region to be selected containing multiple member functions declarations,
    and automatically create function definitions for each.

- Add support for precompiled headers.

- Break photon mapping into two passes. Create the photon map
    in one pass, and shade the model using the photon map in the next pass.
    That way I can try out the effects of different photon map evaluation
    parameters and techniques without having to recompute the photon map.

- Maybe I could use Delaunay triangulation to do clipping of arbitrary polygons.
    Compute all the intersection points of all of the edges, then
    create a Delaunay triangulation of all of the resulting points.
    Generate the resulting polygon output from that.

- Here's how I could convert a photon map to a triangle mesh.
    - For each polygon in my original mesh, create a Delaunay triangulation
        of it, based on the photon map points.
    - Then iteratively collapse the edges in order of least discontinuity of intensity,
        up to some threshold.

- Here's another way I could convert the photon map to a triangle mesh.
    - Shade vertices by firing rays at the surrounding geometry and interpolating
        the photon map at the intersection points.
    - Just do a regular subdivision of the original mesh triangles. Keep subdividing
        until a size threshold is reached, or if subdividing would result
        in vertices whose intensity would fall under an error threshold
        when compared to adjacent vertices.

- I don't need to implement the photon map at all before supporting indirect illumination.
    For each vertex I'm shading, I could fire rays into the surrounding scene
    and sample the direct illumination that I've already explicitly computed.
    That'll supply me with one-bounce indirect illumination.
    Later, I'll implement the photon map, which will encode indirect illumination
    of two and higher bounces.

- Write a mesh viewing program with lots of features for inspecting the mesh in detail,
    to aid in debugging, before writing any interesting algorithms.

X Write some code to do incremental Delaunay triangulation.
    X Find some way of viewing and inspecting simple 2D point and line output.
        X Write out SVG files and view them with Illustrator.
    X Write a test program that reads a text file of vertices as input
        and writes out an SVG file with the vertices and the Delaunay triangulation.
        X Write a function to read a CSV file of points and store them in a
            std::vector<cgmath::Vector2f>.
    X Create a new library for Delaunay triangulation.
    X Write unit tests for everything, in advance, as I go along.
    X Write a 2D vertex class.
        X Do I need references to edges?
            X No.
        X Do I need references to triangles?
            X No.
    X Write a 2D edge class.
        X References to zero, one, or two vertices.
        X References to zero, one or two triangles.
    X Write a 2D triangle class.
        X References to zero, one, two, or three vertices.
        X References to zero, one, two, or three edges.
    X Write a mesh class.
        X Write functions to create, destroy, and iterate over vertices, edges, and meshes.
            X Write unit tests for all these.
        X Convert the edge and face classes to deal with the new Ptr classes instead of
            using regular pointers.
        X Rename all the Edge::addVertex, removeVertex, etc. functions
            (and those for Faces) to be called addAdjacentVertex, etc., so it's clear
            they are pointers to those objects, not the objects themselves.
        X Put all the not for public consumption delaunay code in a nested namespace
            just like what I did in cgmath/MatrixInternal.h, so it's clear that the
            code isn't part of the API.
            Maybe it should be cgmath_internal after all, so it's less awkward in the code.
            I don't know.
        X Write a function to check the mesh for consistency.
            X Test for degenerate triangles.
            X Test for triangles that are inverted.
            X The vertices of faces should always be specified in counterclockwise order.
            X Edges of faces should always be specified in counterclockwise order.
        X I really should write unit tests for my mesh consistency check somehow.
            X Make one function that performs all the tests and returns the kind of
                inconsistency detected in the mesh.
            X Write a function, AssertMeshConsistency, that, only in debug mode,
                calls TestMeshConsistency and performs an individual assert
                on each resulting status value, so that it'll fail at a line that
                indicates exactly what the problem is, followed by an assert
                of status == IS_CONSISTENT as a catch-all in case new status values
                are added and I forget to update the wrapper function.
                X Make this a function, not a macro.
            X Rename TestMeshConsistency.cpp to MeshConsistency.cpp since it contains
                both the Test and Assert functions.
            X Then write unit tests using the original function.
        X I need to add an additional mesh consistency test to check that
            no pair of edges of the same face reference the same vertices.
            I made this mistake in EdgeOperationsTest.cpp and it was not found
            by the consistency test. See '##' in that file.
        X Add the missing unit test for HAS_DUPLICATE_EDGES.
        X Add the missing unit test for HAS_DUPLICATE_FACES.
        X Check through the code to see if there's anywhere I make assumptions
            about how many vertices/edges/faces an edge or face has,
            and precede it with an assert call.
        X Rework MeshConsistencyStatus so that it returns a structure with a count
            of how many of each violation there are, so that multiple
            violation types can be represented at once, to make it easier
            for me to write my unit tests.
            X Redo testHasEdgeFaceWithoutBackpointer as something much simpler.
            X Write testHasFaceEdgeWithoutBackpointer.
            X Get rid of the ordering comments in TestMeshConsistency and
                restore the original order if necessary.
        X Add an additional consistency test to make sure that each face's vertices
            and edges are defined in the same order. The first edge must reference
            the first and second vertices, etc.
            X Add the test.
            X Add a unit test for this test.
            X I'm not sure that SwapEdge is really working correctly in all cases.
                Look over the diagram I drew again and run through the SwapEdge
                function line by line.
                For example, I am pretty sure I'm making assumptions about how v1 and v2
                are assigned. They should be determined by looking at the 
                vertices adjacent to the faces and comparing those to the vertices
                of the shared edge (e1).
                X First, write these functions and their unit tests, to help
                    with testing that SwapEdge works in all cases.
                    X RotateFaceVertices
                    X RotateFaceEdges
    X Put the unit text executables in the top level bin directory (with a '.debug'
        suffix for the debug builds) so they're easy to get at when I want to
        see a stack trace when an assertion fails.
    X Write a function that, given an edge with two adjacent faces, flips the edge.
        X Write a unit test for SwapEdge.
    X Write a function that, given a triangle and a vertex within that triangle,
        subdivides the triangle into three triangles and returns those triangles.
    X I do need a RotateFace function after all, so I can unit test all the permutations
        of functions like SwapEdge, so that they work regardless of how the
        vertices and edges of the faces are ordered. Right now, I'm not getting full coverage.
    X Reproduce my three before/after drawings in Illustrator and save them
        as PDF files in delaunay/doc, and then reference them in the source code
        so I can make sense of it later.
    X The SplitEdge function should have asserts that ensure that the new vertex
        lies inside the bounds of the initial two faces (just like SplitFace does).
        X Make sure it correctly handles the case of two triangles that would form
            a concave quadrilateral if merged into a single polygon.
    X Write a function that, given an edge and a vertex along the edge,
        subdivides the edge and the one or two adjacent triangles and returns
        either two or four triangles.
    X Oops, I'm not sure that my SplitEdge function handles the case
        where there's only one triangle adjacent to the edge being split.
        X Write a unit test for this case
        X Fix the SplitEdge function to handle that case.
    X Go over everything again and make sure I've handled all the special cases.
    X Write a function to perform incremental Delaunay triangulation.
        X Take an array of Vector2f's as input.
        X Return an array of vertex index triplets.
        X Write a debugging mode function to collect output of the algorithm
             so it can be printed out later into a single page-sized image.
             X Capture the state of the polygons, edges, and faces at each step.
                 I only need to record the positions of these objects.
                 X Maybe I'll also want the ability to highlight certain features.
                 X I'll also want to be able to draw a circle given three points
                     on the circle.
             X At the end, scale everything so each step can be drawn as a box in a grid.
                 X Write out vertices as filled circles.
                 X Write out triangles as polygons. Shrink the triangles
                     so I can see how they're positioned relative to each other and
                     when they overlap.
             X Code this up.
                 X Use the existing mesh as the representation.
                     X Write a Mesh::clone function, so I can capture the state of the 
                         mesh at each step.
                         X Write a unit test.
                         X Write clone functions for Vertex, Edge, and Face.
                             (Edge and Face's clone functions will do almost nothing.)
                         X Make a new mesh.
                         X Loop over each vertex, edge, and face, creating duplicates
                             of each and putting each in a map from the old
                             pointers to the new pointers.
                         X Loop over the old mesh elements and the new mesh elements
                             simultaneously, creating the adjacent elements
                             for the new mesh elements.
                         X Return the new mesh.
                X Move the bounding box classes to cgmath and write unit tests for them.
                    X I think the bounding box classes are missing unit tests
                        for intersection. Check for others.
                X Write a Snapshot class to encapsulate a cloned mesh
                    and lists of highlighted features.
                X Write a History class that can create and keep track of a list of Snapshots.
                X Write a function to compute the bounding box of a MeshSnapshot.
                X Write a History member function to output the history as an SVG file.
                    X First do a few SVG experiments to see how the coordinate space works.
                        Where's the origin? What are the units?
                    X Compute the maximal bounding box of each of the meshes
                        in the MeshHistory.
                    X 'computeBoundingBox' shouldn't be in MeshSnapshot.
                        It should be a standalone function in MeshOperations.
                    X Based on the size of this bounding box, and the dimensions of
                        a standard page, figure out how many rows and columns
                        should be displayed on the page.
                        X Maybe rather than calculate this explicitly, I could
                            just keep iterating over possibilities until everything fit.
                            X Given N boxes, loop over 1 to N as the number of boxes
                                in the X axis.
                            X The Y axis would be N/X, rounded up.
                            X Then, given the aspect ratio of the maximal bounding box,
                                compute the size of that box as it would appear
                                in each cell.
                            X Choose the values of X and Y that result in the
                                largest boxes.
                    X In MeshHistory, 'offset' should take into account shifting the
                        mesh vertex coordinates so that the upper left corner of the mesh
                        is at 0, 0 instead of whatever arbitrary values it's at now.
                        This calculation should look at the mesh bounding box.
                    X Make the triangulate program create a delaunay::Triangulator
                        object and call Triangulator::triangulate with the input data,
                        so I'm in a position to actually manipulate it.
                    X Write delaunay::MeshHistory::writeMesh.
                    X Add a MeshHistory function to specify an optional circle 
                        to output with the other elements in the SVG file.
        X Write bounding box functions sizeX, sizeY, sizeZ, along with unit tests.
        X Replace Mesh pointers with the new MeshPtr's where it makes sense.
        X BoundingBox2f and BoundingBox3f are missing equality and inequality operators.
            Add these and write unit tests. Then go back to writing the unit test
            for MeshSnapshot.
        X I need unit tests for the except library.
        X Put asserts in BoundingBox2f/3f's constructors to ensure
            that the min/max values are properly ordered.
        X I'm not happy with the naming of some of the BoundingBox2f/3f functions.
            X 'intersectsRaySegment' is awkward because the length of 'direction'
                is significant. Maybe it should take two points instead of an origin
                and a vector whose length matters.
                - Maybe 'intersectsLineSegment' would be a better name.
            X It's inconsistent that I have 'extend' overloaded but
                then I have functions like 'intersectsBoundingBox3f' that takes
                a bounding box as an argument just like 'extend' does.
        - Add const correctness support to Mesh.
        X Create an initial triangle which bounds the input data.
        X For best performance, I think the vertices should really be processed 
            in a deterministic random order,
            rather than the order that they're specified in the file.
            Determine that this is really required before implementing it, though.
        X TestMeshConsistency and AssertMeshConsistency take Mesh references as
            arguments, but they should take MeshPtr's instead.
        X In the SVG file, I'm writing out vertices with the origin in the upper left,
            but this doesn't match up with the coordinate system I'm doing all 
            my math in. To fix this, vertically flip everything I write into the SVG file.
            This also means that my bounding triangle is upside down.
        X The face inset code doesn't check for faces of negative size correctly,
            and tries to draw them anyway, because the faces aren't actually inverted.
            It's as if they're rotated 180 degeres.
            X I think in insetMeshFaceVertex, what I want to do is check if
                the distance from v2 to line v1 v3 is insetDistance or less,
                or if v2 is on the wrong side of line v1 v3.
                X So, first I need a function to compute the signed distance
                    from a point to a line.
        X Add pointers from vertices to adjacent edges and faces.
            X I'll assume that the order of the adjacent edges and faces does not matter.
            X Add add/remove functions to the Vertex class.
            X Add unit tests for the new vertex functions.
            X To MeshConsistencyStatus, add:
                X VERTICES_WITH_ZERO_EDGES
                X VERTICES_WITH_ONE_EDGE
                X VERTICES_WITH_DUPLICATE_EDGES
                X VERTICES_WITHOUT_FACES
                X VERTICES_WITH_DUPLICATE_FACES
                X VERTEX_EDGES_WITHOUT_BACKPOINTER
                X VERTEX_FACES_WITHOUT_BACKPOINTER
                X EDGE_VERTICES_WITHOUT_BACKPOINTER
                X FACE_VERTICES_WITHOUT_BACKPOINTER
            X Add all of these tests to TestMeshConsistency in MeshConstency.cpp.
                X Write unit tests for these tests.
            X Add all the new MeshConsistencyStatus values to AssertMeshConsistency.
            X Update the SwapEdge unit tests.
                X Update verifySwapEdge in EdgeOperationsTest.cpp.
            X Update SwapEdge to use the new Vertex functions.
            X Update the SplitEdge unit tests.
            X Update SplitEdge to use the new Vertex functions.
            X Update the RotateFace unit tests.
            X Update RotateFace to use the new Vertex functions.
            X Update the SplitFace unit tests.
            X Update SplitFace to use the new Vertex functions.
            X Update the Mesh::clone unit tests.
            X Update Mesh::clone to use the new Vertex functions.
        - FaceOperationsTest.cpp testSplitFace doesn't seem to be complete.
            It doesn't examine vertices and faces adjacent to the edges,
            or edges and faces adjacent to vertices.
        X Add VertexOperations.cpp and write:
            X DestroyVertexAndAllAdjacentElements
                X Write a unit test first.
        X Write a function that, in debug mode only, asserts that a mesh is Delaunay.
            Call this after I've executed the code below, when I think that the 
            mesh should in fact meet the Delaunay criterion.
            X Make both a Test function and an Assert function that calls the Test function,
                so when I'm writing the output to the SVG file, I can have it
                stop when the mesh isn't Delaunay when I expect that it should be.
            X Write a unit test for this.
        X For each vertex,
            X Determine which triangle it lies inside.
                X Handle the case when the vertex lies inside another triangle.
                X Handle the case when the vertex lies on an existing edge.
                X Handle the case when the vertex is coincident with an existing vertex.
            X Subdivide that triangle into three triangles.
            X For each new triangle, flip the exterior edges (that are not adjacent
                to the newly inserted vertex) as necessary:
                X For each edge, test if the far vertex on the neighboring faces
                    lies inside the circle that intersects the face's vertices.
                    X If it does, flip the edge leading from the far end of the
                        face to that vertex.
                    X Then perform the test on the far edges of the triangles
                        adjacent to the flipped edge. Repeat as necessary.
        X Show all the vertices before any of them are added to the mesh
            or before the bounding triangle is created.
        X Show each vertex before it's inserted into the mesh.
        X Remove the bounding triangle's vertices, edges, and associated faces.
            X Write a function to delete a face and all adjacent mesh elements
                that are orphaned as a result.
                X Unwire the face from all adjacent edges.
                X Unwire the face from all adjacent vertices.
                X Delete all adjacent edges that have no adjacent faces.
                    X Unwire the edge from all vertices adjacent to the edge.
                    X Unwire the edge from all faces adjacent to the edge.
                X Delete all adjacent vertices that have no adjacent edges.
                    X Unwire the vertex from all edges adjacent to the vertex.
                    X Unwire the vertex from all faces adjacent to the vertex.
                X Delete the face.
                X Write unit tests for this function.
            X Write a function to delete a vertex and all adjacent mesh elements
                that are orphaned as a result.
                X Do this by simply calling the function above to delete 
                    all adjacent faces.
                X Write unit tests for this function.
        X The following input data results in a mesh that does not completely span
            the convex bounding hull:
            55, 350
            43, 430
            110, 450
            9, 470
            X Make another test function to check if the perimeter of the mesh
                is convex.
                X First test the topology of the mesh.
                    X Does the mesh have disconnected segments?
                        Start with one vertex and then flood fill, and see if we
                        can visit every vertex in the mesh.
                    X Does the mesh have holes?
                        Assuming the mesh has only one connected region, then if the
                        Euler characteristic of the mesh (V - E + F) is less than 1,
                        then the mesh has holes.
                X Find leftmost vertex.
                X Look at all adjacent edges/vertices, comparing the angle between that edge
                    and a line straight out to the left, to find the next vertex
                    counterclockwise around the perimeter.
                X March around the perimeter until we return to that vertex.
                X For each set of three vertices visited, test for local concavity
                    using the 2D orientation test.
            X For each bounding triangle vertex,
                loop over all the adjacent edges that have two adjacent faces.
                If the two faces, when combined, form a concave polygon, then flip that edge.
                I'm pretty sure this will result in a mesh that has a convex perimeter
                when the three bounding triangle vertices are removed.
                X Actually, I'm not entirely sure this will fix the mesh in all cases.
                    Perhaps it's necessary to apply this pass repeatedly until
                    no more edge swaps are performed.
                    At the very least, add a comment that'll help me fix this
                    later if the convex perimeter test at the end of
                    Triangulator::triangulate fails.
                    src/triangulate/stress_test.py fails because of this.
                    Making multiple passes with correctBoundingTriangleVertexEdges
                    doesn't even work.
                    X I guess I have to use that approach described after all.
                        X Maybe it's as simple as, when I've decided that I want to flip an edge,
                            then if the edge leads to a bounding triangle vertex, don't flip it.
                        X That's not enough on it's own. We may create these edges
                            that we don't want when we insert new vertices. Somehow we want
                            to fix them up when we get the chance.
                        X This didn't work.
                    X I tried what was described in the slides, but it seems as though
                        "Illegal Edge Test, Case 3" will happily flip an edge that
                        results in an inverted triangle. I'm sure that I trust
                        a bunch of slides somebody made.
                    X This is really weird. If incremental Delaunay triangulation
                        is so commonly implemented, how come I can't find any references
                        on the Internet about how to deal with this case?
                    X Another approach would be to not start with a bounding triangle,
                        but specially handle the case of adding a vertex that doesn't
                        lie inside any existing triangles.
                        X Undo revision 396 (again).
                        X To support this, I'd need a function that, given three vertices,
                            added a new face between those vertices as well as
                            any edges that were not already present.
                            (CreateFaceAndAdjacentEdges)
                            X Write unit tests for this function.
                        X Rather than start with a bounding triangle, I'd start with
                            a triangle created by three randomly chosen
                            non-colinear, non-coincident vertices.
                        X Find the existing vertex closest to the new vertex.
                            By definition, this vertex will be on the perimeter.
                        X March around the mesh to the left and to the right, adding
                            new triangles, stopping at the point when 
                            I'd be adding an inverted triangle.
                            X I need a function for stepping around the perimeter of
                                the mesh, from one vertex to the next, either
                                clockwise of counterclockwise.
                                X Then reimplement MeshHasConvexPerimeter
                                    more simply in terms of this function.
                                    (Do this again.)
                        X After I create this new vertex and the adjacent triangles,
                            I can just run the standard Delaunay correction pass
                            on all the triangles adjacent to the newly created vertex.
                        X I might as well use this approach, because I know it'll work,
                            since the Delaunay criterion will be maintained at all times.
        X stress_test.py fails with 1000 input points.
        X The script src/triangulate/RUN doesn't stop if the build step fails,
            and it should.
        X I don't have unit tests for MeshConvexPerimeter.cpp.
            X Test for the case when the perimeter is convex.
            X Test for the case when the perimeter is concave.
        X What if the input points are colinear, or all coincident? I'm guessing there's 
            a few places I don't deal with that correctly.
            This is important because I might use this function later to 
            try to triangulate a degenerate polygon.
            X Seems to work OK.
        X I might have skimmed over unit tests and asserts in the code I added 
            recently. Fix this.
        X Make the algorithm more efficient by walking the mesh to find intesecting
            vertices, edges, and faces, rather than considering the entire mesh.
            X This could all be based on a single routine that finds the
                the nearest vertex to a given point, with an option to ignore
                backfacing perimeter edge points, which we'd only want to use
                when searching for the nearest perimeter edge.
            X I first need to keep track of the vertices in a vector as I add them
                so I can randomly choose one as a starting point for each search.
            X Before making the following changes, write a script that runs
                timing tests of the release build, for random sets of input
                of sizes from 50 to 500 points in 50 point increments.
                Output the duration in seconds, so I can graph the change
                in efficiency in Excel.
            X I was walking edges, which it turns out doesn't always work.
                The literature says that you should walk from one face to the next.
                Do that instead. See "A Small Improvement in the Walking Algorithm 
                for Point Location in a Triangulation" for a description
                of an algorithm.
    X Modify the test Python scripts so that they always build either triangulate.debug
        or triangulate (the release version) first, as necessary,
        because each one builds a different version and that's a potential
        source of confusion.
    X Organize/rename the tests in src/triangulate.
    X Rename TestMeshIsDelaunay to MeshIsDelaunay and then get rid of
        AssertMeshIsDelaunay and replace uses of it with actual assert statements.
    X Give the triangulate an option to specify if I want to output the whole history
        of the mesh in the SVG file, or just the final image.
    X None of the unit tests should call AssertMeshConsistency. Instead they should call
        CPPUNIT_ASSERT(delaunay::TestMeshConsistency(mMeshptr).isConsistent())
        That way it's easier to tell where the unit test failed when a mesh is
        inconsistent.
    X SplitFace should take a MeshPtr, not a Mesh reference.
    X Try to remove some unneeded include statements. For example, I think because MeshPtr
        is now in MeshTypes, I don't have to explicitly include Mesh.h in some headers.
    X I don't like how MeshPtr is defined in MeshTypes.h, but MeshSnapshotPtr is defined
        in MeshSnapshot.h. I had to move MeshPtr because of circular reference issues.
    X In debug builds, GetAdjacentVertexAroundPerimeter should find the opposite vertex for both
        adjacent perimeter edges, not just one, and assert that they're both
        on the same side of their respective edges in relation to the vertex shared
        by the two edges. (See '##' in the code.)
    X The mesh consistency test should also test that for a given edge, the two vertices
        of the adjacent faces that are not part of the edge are on opposite sides
        of the edge. I shouldn't have two faces leading off of the same side
        of a given edge.
        - Write unit tests for this.
    - The stress test crashes with a floating exception.
        - It was doing an integer divide by zero. Mysteriously, I put in some assert statements
            to check for this, and then it stopped crashing and worked fine.
            That's not good.
        - I tried removing the asserts again later and couldn't reproduce the crash.
    X The aligned grid test in src/triangulate failed.
        X This is because Triangulator::getNearestPerimeterVertex is returning a vertex
            that is on the far side of the mesh, but which is physically the closest.
            Instead, it should only return vertices that are visible to the 
            vertex being added. Since the mesh perimeter is always convex, 
            I should be able to weed out illegal perimeter vertices by doing an
            orientation test on the adjacent vertices.
    X The rotated grid test has two issues:
        X My FACES_WITH_CLOCKWISE_EDGES test in MeshConsistency.cpp
            fails when it encounters slivers, because of the multiplication by 0.5.
            Either fix this so there's no possibility of roundoff errors,
            or get rid of the test entirely.
        X Slivers cause my mesh output code to put "nan" in the SVG file.
            Fix this by getting rid of the code that calculates inset polygons.
    X MeshConsistencyTest.cpp has several unimplemented unit tests, marked with '##'.
    X I need unit tests for the triangulator. Feed it varying configurations
        of input points.
        X For robust testing, I think I really want an option that adds the points
            to the mesh in the ordered they're specified, rather than
            randomizing them for efficiency. Do this in all my tests.
        X Test the following input data:
            X One point
            X Two points
            X Two coincident points
            X Three points
            X Three colinear points
            X Three coincident points
            X Four points
            X Four cocircular points
            X Four points with three colinear points
            X A regular grid
            X A regular grid with a small rotation.
    X Make Triangulate return the computed vertices and edges.
        X Return the three vertices for each triangle.
        X Return the three edges for each triangle.
        X Return the two vertices for each edge.
        X Anything else I need can be easily derived from backpointers.
    X Make 'triangulate' output vertices optionally to a CSV file, and never to stdout.
    X For 'triangulate', write a test script that runs a bunch of 
        integration (?) tests (not unit tests that are automatically run)
        and lump my existing tests in with those.
        X Should src/triangulate/test/test.py be run automatically?
            When I write the script to do endless random testing, it certainly
            shouldn't be run forever.
            X I'll decide no for now.
    X Write code to repeatedly test the triangulator with moderate amounts 
        of random input containing random contrived semidegenerate data, and run it all night.
        Set it up so that if it fails, I'll have a record of the input cases to inspect.
        Test by hand what happens in the event of failure by forcing the program to crash.
        For each point, randomly give it a value calculated in one of these ways:
        X On a regular grid.
        X On a regular grid, rotated.
        X Completely random.
    X Write code to test a regular grid rotated at random angles and run that all night.
    X Extend the Delaunay triangulation algorithm to perform constrained 
        Delaunay triangulation.
        X Put in asserts to test for mesh consistency after this modification
            to the mesh is performed.
        X Write unit tests for this.
        X DeleteFaceAndAllOrphanedAdjacentEdges needs unit tests.
        X In Triangulator, rename some member functions:
            X setInputPointVector
            X inputPointVector
            X setInputEdgeVector
            X inputEdgeVector
            X outputEdgeVector
            X outputTriangleVector            
        X I fail an assert if an input edge is degenerate,
            but I allow duplicate input points and ignore them. Handle this
            more consistently. I also fail an assert if edges intersect other edges
            or input vertices. Should it be the case that Triangulator::triangulate
            simply should never crash on bad input data, or not?
            X I decided to consistently trigger asserts on all bad input data in debug mode.
                I don't know how the code will be have in optimized mode.
            X Maybe I could have a validateInputData function that returns status
                information indicating if the input data is valid or not,
                and the command line tools can call that to perform an 
                expensive test up front, but in general I would not use it.
                X Write PointTriangulator::validate.
                X Write a unit test for PointTriangulator::validate.
                X Write PolygonTriangulator::validate.
                X Write a unit test for PolygonTriangulator::validate.
    X src/triangulate/test/test.py's exponential test fails!
    X Do I have any other of those orientation0*orientation1 > 0.0 comparisons
        around that fail with extremely small numbers that get
        rounded to zero?
    X I think exact::TestPointIntersectsLineSegment fails if the point lies on the
        endpoints of the line segment. Write a unit test for that case and
        then fix it.
    X Triangulator has lots of redundant code for finding vertices opposite edges
        and edges opposite vertices (of a face), and testing if a vertex is a member
        of a face, or an edge, or finding a vertex on the opposite side
        of an edge, etc. Write explicit functions for these, and unit tests for them,
        and clean up the existing code.
        X Return true if a vertex has another specified vertex as a neighbor
            along an adjacent edge.
            (Would be used at the top of Triangulator::insertConstrainedEdge.)
            X Unit test.
        X Given a vertex, return the adjacent edge that leads to the neighboring vertex,
            or MeshPtr::edgeEnd() if there isn't one.
            Must take a MeshPtr as an argument.
            (Would be used by CreateFaceAndAdjacentEdges.)
            X Unit test.
        X Given a vertex and an edge, return the neighboring vertex along the edge.
            (Would be used by GetAdjacentVertexAroundPerimeter in VertexOperations.cpp.)
            X Unit test.
        X Given an edge and a face, return the face on the other side of the edge.
            This would assume the edge had two adjacent faces.
            (Would be used by Triangulator::insertConstrainedEdge.)
            X Unit test.
        X Given an edge, return true if the edge has a specified adjacent vertex.
            (Would be used by TestEdgeFaceOrientation in MeshConsistency.cpp.)
            X Unit test.
        X Given an edge, return true if the edge has the specified two adjacent vertices.
            (Would be used by TestVertexEdgeOrderOfFaces in MeshConsistency.cpp.)
            X Unit test.
        X Given a face and an edge, return the vertex that is opposite the edge.
            (Would be used by Triangulator::insertConstrainedEdge
            and GetVertexOppositePerimeterEdge in VertexOperations.cpp.)
            X Unit test.
        X Given a face and a vertex, return the edge that is opposite that vertex.
            (Would be used by Triangulator::insertConstrainedEdge.)
            X Unit test.
    X It should be the case that the indices of the input edges should 
        be identical to the indices of the output edges, and all be listed first,
        with additional edges following them, just as the input point indices are the
        same as the (implicit) output point indices.
        Otherwise I'll have no easy way of knowing if an output edge is also an
        input edge or not when I try to implement arbitrary polygon triangulation.
    X Write a function to tessellate an arbitrary polygon with holes,
        based on the constrained Delaunay triangulation.
        X Rename triangulate to triangulate_points.
        X Create a new program, triangulate_polygons.
        X Rename Triangulator to PointTriangulator.
        X Create a new class, PolygonTriangulator, in terms of PointTriangulator.
        X In triangulate_polygons, write code to read a points file 
            and a polygon file.
        X Implement PolygonTriangulator
            X Pass through all points to Triangulator
            X Build a vector of constraining edges from all polygons.
            X Triangulate the points.
                X Cull out all triangles that lie outside the exterior perimeters
                    or interior perimeters.
                X Create a vector parallel to the triangles to keep track of which 
                    ones are inside or outside.
                X Initially, mark them all as undetermined.
                X Loop over every triangle.
                    X If the triangle's status is not undetermined, skip it.
                    X If none of the edges of the triangle were constraining edges, skip it. 
                        To determine if an edge is a constraining edge, just check if its index 
                        lies within the range of input constraining edge indices.
                    X If any of the edges were constraining edges, determine if the triangle 
                        is inside or outside using the 2D orientation test. Recursively loop over 
                        all adjacent faces via non-perimeter edges, marking them 
                        with the same status.
                X Then create a vector of output faces. These will be all the faces 
                    that are marked inside.
            X To create the vector of output edges, examine each edge output 
                from Triangulate, and only pass through those edges that have 
                at least one neighboring triangle that lies inside the polygon. 
                Do this by creating a parallel vector of flags for the edges marking 
                them inside or outside, and then populating it by looping over the triangles, 
                and for each triangle inside the polygon, marking all of its neighboring 
                edges as inside. Then create the vector of output edges.
                X I also want to output, for each output triangle, the indices of the output 
                    edges adjacent to that triangle. How do I do that?
            X Print out, with table indices, all the vertex coordinates, points adjacent to edges,
                and points and edges adjacent to triangles, and then verify it all by hand.
            X Once again, I'll want some way of visualizing this and debugging the output, and a
                standalone program for testing it.
            X Maybe rename triangulate to triangulate_points, and then I'll have a new program
                triangulate_polygons.
        X Write code to output an SVG file of PolygonTriangulator's output.
            X Use MeshHistory to do this. When an SVG file is requested,
                convert the final results in a Mesh and then pass it to
                MeshHistory for output.
        X In Python, write an SVG to points.csv and polygons.csv converter
            so I can easily create complex test cases in Illustrator.
        X Write unit tests for PolygonTriangulator.
            X Convex polygon.
            X Concave polygon.
            X Multiple polygons.
            X Convex polygon with holes.
        X Put the test data to triangulate_polygons in a test subdirectory.
        X Create a script in 'tools' that runs all the integration tests.
    - Everywhere I have a function that returns a value as an argument,
        make sure they're passed as pointers, not non-const references.
    - I could speed up the triangulation code further by putting all the vertices
        in a KD tree as I go along, and then use it to locate the nearest
        vertex to a given point in O(log n) time, and use that as the starting
        point for my triangle walk, which should then always be extremely short.
    - I have to be more sure about the behavior of Triangulator when fed bogus input, like
        intersecting edges or vertices. This has to be very well defined, and the debug build has
        to explicitly catch all illegal input.

X The build script doesn't do any validity checking on its arguments.

- Why do I have Mesh::clone instead of simply defining 
    the copy constructor and assignment operator?
    (Same for Vertex, Edge, and Face.)

- Make vectors and matrices and everything else provide default values
    in their constructors for safety. In cases where I really care about speed,
    I can just use the contructors that take explicit values as arguments.

X Rework the exceptions so that they are also ostreams, so that messages can be
    streamed into them when they are thrown, rather than requiring the use
    of a std::ostringstream.
    Instead of:
        std::ostringstream ostr; 
        ostr << "Could not open file \"" << filename << "\"."; 
        throw except::FailedOperationException(SOURCE_LINE, ostr.str(), 
            Error::fromSystemError()); 
    I would then write:
        throw except::FailedOperationException(SOURCE_LINE, Error::fromSystemError())
            << "Could not open file \"" << filename << "\".";

X Redo the logo to fix the asymmetry problem and put it under Subversion.

- Reduce the thickness of the logo border so it matches the proportions of 
    real street signs.

X Ctrl+C,J doesn't work in the body of a definition of a global function,
    because the function declaration doesn't have a class designation.

- Ctrl+C,H to a new .cpp file shouldn't provide default constructors and destructors
    if the .h file didn't have a class declaration that matches the filename.

X Write an Emacs macro to load my TODO file.

X Loading the TODO file should automatically jump to the last line
    that starts with two asterisks.

- Approaches for handling the imprecision of floating point numbers:
    - Epsilon
    - Exact arithmetic
    - Interval arithmetic
    - Fixed point
    - Thick/fat mesh elements

X I added the optimization but the speed test doesn't show any increase!
    X Instrument the code to see how much time it spends finding nearest faces,
        as opposed to doing everying else.
        X Less than 1% of the time is spent in findNearestFace,
            so I suspect memory allocation as the big time sink.
    X I was still calling my assertions and consistency tests because NDEBUG
        wasn't defined in the optimized version.
    X Get rid of the timing tests I added to Triangulator when I'm all done,
        so the tests themselves won't be causing overhead.

X Copy over my unit tests for src/timeval.

X When accessor function declarations/definitions are automatically created by my macros,
    size_t is not considered to be an integral type, and "const &" is added
    when it should not be.

X Make sure the output point indices match the input vertices across the edges.

- Port my old mesh library over.
    X Copy the code.
    X Copy the unit tests. (copy out of src/mesh/temp/test)
    - Figure out what to do with the epsilon-based code I ifdef'd.
    - Look into adding a boost::shared_ptr based MeshPtr.
    - Reformat the code for 100 columns.
    X Many functions in StandardAttributes.h are not verb phrases
        and look like class names and should probably start with "Get".
    - Use boost::pool::fast_pool_allocator.
    - Scan through the code for places where I do floating point comparisons,
        where I should use exact geometric predicates instead.

X Port the objfile library.
    X Port the string library because objfile depends on it.
    X Port objfile/test.

X Port the meshfile library.

X Port mesh_print.

X Port the console library.
    X Make sure triangulate_points, triangulate_polygons, and rfm_print,
        call call con::SetProgramName at startup.
    X Modify triangulate_points, triangulate_polygons, and rfm_print,
        to use them instead of std::cerr.
    X Port the console library's unit tests.
    X "rfm_print foo" outputs junk. Is cons::err working?

X Port the thread library.
    X Port the unit tests.

X Get rid of 'Context' in the file names in rfmfile and objfile.

X Port obj2mesh.

X Port mesh2obj.

X Try the evaluation version of Silo and Modo.
    X See how well they would work as OBJ file viewers and debugging tools.
        X In Silo, there's no support for vertex colors.
            X It looks like I'm going to have to write my own mesh viewer to
                see the lighting output from the discontinuity meshing.
    X Can I disable lighting?
    X Can I easily isolate individual mesh elements and cull away the rest of the mesh?
    X Buy the pro version of Silo.

X Eventually I'd like to support multiple distant light sources
    and local light sources.
    X Local light sources could be defined using the emission material attribute.

- Write a program to modify material properties of an RFM file.
    - Create rfm_setattr.
        - For discontinuity meshing, I'll want to set the emission attribute 
            of a particular material, by name.
        - A full version of this program would allow me to set any attribute at all,
            by name and type.
    - Don't bother with this yet. I'll just hand-modify the MTL file and specify
        the nonstandard "Ke" MTL file attribute.

- Write rfm_triangulate as a standalone way of testing triangulation code.
    - Write mesh::Triangulate, based on the Delaunay triangulation code.
    - I don't need this yet either. I'll just use Silo to triangulate the input mesh first.

- Write a program to create a discontinuity mesh.
    X Create rfm_discmesh.
    X Fail if the input mesh isn't all triangles.
    X Given a description of a wedge (one vertex and two edge endpoint vertices) 
        extending in both directions and a triangle (three vertices),
        return the line segment intersection of the segment in wedge space, if any.
        X Only handle the VE case first. Worry about EV after I get
            VE entirely working and unit tested and I trust it.
        X There may be zero, one, or two line segments. Do not return
            degenerate line segments.
        X The endpoints must be returned in 2D wedge space coordinates, not 3D coordinates,
            because that's what I'll use to sort them.
    X Write an EndpointIdentifier class.
    X Write an Endpoint class that'll keep track of the endpoint's (s,t) wedge-space
        coordinates as well as its original 3D space coordinates, and an EndpointIdentifier.
        X Make IntersectVeWedgeWithTriangle return Endpoints instead of pure (s,t) coordinates,
            including 3D coordinates and EndpointIdentifiers.
        X Update the IntersectVeWedgeWithTriangle to pass in the new arguments
            instead of the triangle vertices and test the output endpoints.
        X Update the IntersectVeWedgeWithTriangle unit tests to test the endpoint worldspace
            coordinates as well as the wedge space coordinates.
        X Update the IntersectVeWedgeWithTriangle unit tests to test the
            EndpointIdentifiers (by creating new identifiers to compare them with).
        X Add more unit tests for the cases where one or more triangle vertices directly intersect
            the plane of the wedge. I should wind up with the correct endpoint identifiers.
    X Write a class to handle 2D output of a set of line segments to an SVG file.
        X Build a list of 2D line segments.
        X Find the bounding box of the line segments.
        X Center the bounding box on the page and output all the line segments
            to the SVG file.
        X Figure out why in my test code at the top of rfm_discmesh,
            the lines don't wind up in a nice position on the page.
        X Remove the test code from rfm_discmesh, along with the includes I added for it.
    X Modify the triangles.mtl file so the light source has Ke defined,
        then rebuild the triangles.rfm file from it.
    X Make rfm_discmesh read the RFM file.
    X Create a DiscontinuityMesher class.
    X Loop over all of the vertices of all faces with the emissive attribute defined.
    X For each vertex, loop over all edges that aren't adjacent to faces that are light sources,
        and do the VE wedge intersection test for that vertex and edge
        against all other faces in the scene (that are not adjacent to the occluding edge),
        and dump the XZ coordinates of the results to the SVG file.
    X Implement the EV wedge intersection test.
        X Rework WedgeOperation into a WedgeClipper class, so code can be
            shared between the VE and EV intersection test cases.
        X Modify WedgeIntersector::clipToLightSource so that it puts the world space
            positions of the clipped vertices into mLineSegmentArray and updates
            mLineSegmentCount, rather than modifying mD and mE.
        X Then, make the rest of the code refer to mLineSegmentArray variables
            rather than mD, mEp0, mId0, etc.
        X WedgeIntersector::clipToLightSource should handle the EV_EVENT case
            by clipping the line segment both against the plane passing through point V
            and a plane passing through edge PQ.
            X We don't want to consider geometry behind the light source.
            X Clipping against the plane passing through point V may
                result in two line segments.
        X In testTriangle, loop over the line segments in mLineSegmentArray,
            map the line segments to wedge space, clip them, and then map them back to 
            world space.
        X In the EV_EVENT case, before testTriangle returns, remap the wedge space
            coordinates so t is 0 at edge PQ and 1 at point V.
            (By default t is 0 at V and 1 at edge PQ.)
            X This will be important when the line segment sorting occurs later.
        X Questions:
            X In the EV_EVENT case when DE is clipped into two line segments, 
                what should happen to the EndpointIdentifiers?
                X Should clipToLightSource set the EndpointIdentifier of the
                    clipped endpoints?
                X Generally this would be important only in the case of an occluder
                    that intersected a light source.
            X In the EV_EVENT case, does clipWedgeSpaceLineSegmentToWedge work
                in all cases (on either side of point V)?
            X Are there any EV_EVENT cases where two line segments are generated
                and then one of them is discarded, in which case the size of the
                line segment array would have to change?
                X Yes. Remove the line segment to be discarded, but keep the other one.
    X Write unit tests for WedgeIntersector, based on WedgeOperations's VE event unit tests.
        X Within the unit test, write a helper function that replaces 
            the call to IntersectVeWedgeWithTriangle.
    X Get rid of WedgeOperations.cpp.
    X Write a VE event unit test that tests the case where one vertex of the line segment
        intersects the plane passing through point V, resulting in infinite wedge space
        coordinates.
    X Correctly handle the case where one vertex of the line segment
        intersects the plane passing through point V, so the unit test does not fail.
        X Split clipToLightSource into clipToVeWedge and ClipToEvWedge.
        X Implement clipToVeWedge.
            X This must set the endpoint identifier to vertex pairs VP or VQ depending
                on how the clipping goes. Other cases?
        X Implement clipToEvWedge.
            X This must set the endpoint identifiers.
        X Remove clipWedgeSpaceLineSegmentToWedge.
    X Uncomment WedgeIntersectorTest::testIntersectEvWedgeWithTriangleStraddleOccluder
        and make sure it passes.
    X Write more EV event unit tests.
        X Test the case when a triangle vertex is coincident with point V.
        X Test the case when a triangle vertex is coincident with point P.
        X Test the case when a triangle vertex is coincident with point Q.
    X Make sure EndpointIdentifiers are assigned correctly in all cases.
    X Create a separate LineSegment class to replace the one in WedgeIntersector.
    X Assign a FacePtr to each line segment. I'll need these because the line segments
        created by a particular wedge's intersections with the scene's faces/triangles.
        need to be sorted before a subset of them are assigned to the faces.
    X Write a class to keep track of a vector of critical line segments.
    X Check for intersections between critical line segments and split them if necessary.
        X For each intersection, record the parametric position and the worldspace position
            of the new point along that line.
        X Loop over each line segment again and create a new set of lines by splitting
            the original lines. To do this, sort the intersection points of the line segment
            and use them to create the new line segments.
        X Write unit tests.
            X Don't split line segments against each other if they share endpoints.
                Create a unit test for this case.
            X I have to split line segments where one line segment's endpoint
                intersects a point along another line segment.
                Create a unit test for this case.
    X Cull away the portions of the line segments that are not visible in wedge space.
        X Write a Region class to represent multiple disjoint 1D spans.
            X Write unit tests for Region.
            X Change Region::computeDifference so that LHS is a single span, not RHS,
                because that's what I'll need later.
                X Write unit tests for the new computeDifference.
                X Write the new Region::computeDifference.
            X I think Region has to keep track of EndpointIdentifiers, right?
                X When there's ambiguity, use the EndpointIdentifier of the lhs.
                    This means that the EndpointIdentifier of an occluder is projected
                    onto and overrides the EndpointIdentifier of a matching
                    point on a receiver.
                X Add two more union shared point tests where the segments
                    overlap instead of meeting at endpoints.
                    That's a better test of the endpoint ID's of shared points.
        X Add this functionality to LineSegmentCollection.
        X Order the endpoints of all the line segments so that their second endpoint is the one
            with the largest value of T.
        X Sort the line segments by the T values of the second endpoints.
        X Run through the list of line segments in the sorted order.
            X Subtract the existing range from the newly processed line segment. That's
                the new visible portion. Record it on the target face. For now, output it to
                an SVG file for testing.
            X Add the new line segment to the existing visible range.
            X If the existing range is full, stop.
        X Write unit tests for LineSegmentCollection::findVisibleLineSegments.
        X Write some test code to generate random line segments, output them to the SVG file,
            split them against each other, calculate the visible portions, and then write them out
            to another SVG file.
    X Write out a new RFM file with the original mesh, plus a set of degenerate
        triangles representing the critical line segments in 3D, so I can preview
        it in Silo.
        X There's an issue where I wind up with nearly degenerate triangles
            that appear in Silo as points. Maybe for VE events, there are triangles
            adjacent to the 'E' in the edge that when I compute intersections 
            with the wedge aren't being clipped properly, and I should explicitly
            check if those triangle vertices are the vertices
            that define the 'E' edge, and then recognize that they
            exactly intersect the wedge plane.
            X I think what is happening is that in WedgeIntersector::clipToVeWedge
                and WedgeIntersector::clipToEvWedge, if one of the line segment endpoints
                coincides exactly with P or Q, this results in a degenerate or extremely
                short line segment because of floating point error, 
                when in fact the line segment should be entirely clipped away.
                This will happen all the time when triangles adjacent to a line segment's
                endpoints are clipped against the line segment's VE wedge.
                A similar case exists for EV events.
            X clipToVeWedge isn't generating the short line segments I'm seeing in the
                output model. They're being created by 
                LineSegmentCollection::findVisibleLineSegments.
                My guess is that it is not robustly handling the case when line segments that
                share endpoints are clipped against each other.
                X Data point: In my cubes test, LineSegmentCollection does not believe
                    that any of the line segments in the wedges intersect and need
                    to be clipped against each other, so that's not the problem.
                X I verified that there the degenerate segments at 0.328829, 0.0, -1.51978
                    are not present before LineSegmentCollection::findVisibleLineSegments
                    is called, but they are present afterward.
                X It looks line the input to LineSegmentCollection::findVisibleLineSegments
                    contains line segments that in wedge space have s values that
                    stretch from 0 to 1, but don't quite hit these values exactly,
                    which causes the problems later on.
                    Where are these values being generated?
                X My guess is that in WedgeIntersector::testTriangle, 
                    after I clip the worldspace endpoints to the wedge,
                    and then convert those coordinates back to wedge space
                    coordinates, floating point error results in the near-0 and near-1 values.
                    X Have clipToVeWedge and clipToEvWedge make the calls
                        to convertWorldSpacePointToWedgeSpacePoint, rather than
                        testTriangle, because they have the information on handle
                        to know how the clipping went, and if the S values
                        should be set to exactly 0 or 1.
                        X I did this for clipToVeEvent, but not yet to clipToEvEvent
                            (not checked in yet).
                    X After that change, maybe I don't need eraseLineSegment any more
                        because clipToVeWedge and clipToEvWedge won't be adding
                        the line segments to the array if 
                        convertWorldSpacePointToWedgeSpacePoint fails.
                    X clipToEvWedge should also do the t = 1 - t adjustment
                        of the wedge space coordinates.
                    X In WedgeIntersector, remove mEp0, mEp1 if they are no longer used.
    X Reconsider my backfacing test. I'm creating a ray by averaging VP and VQ of the wedge
        and then doing a dot product of the face normal against that.
        That can't be right. Remove it completely and then see what the
        two cubes model outputs and see if I still get those funny segments.
        X I modified DiscontinuityMesher::projectWedge to consider the edges of the wedge
            and do the dot product against both of those vectors, and this broke
            the EV event case (because the edges and vertices are exchanged),
            and that made the spurious edges that I see disappear. So the EV events are
            generating them.
            X In my triangle-square test, it looks like VE events are also generating
                edges like these.
        X Maybe make a WedgeIntersector function that will return the edge vectors
            of the wedge correctly in both the VE and EV cases.
        X Be absolutely sure the backfacing test is working properly. What does it really mean
            when I'm dealing with an area light source?
    X Get rid of some of the superfluous edges in the output.
        X Only trace wedges for scene edges that are silhouette edges when viewed
            from the current light source vertex.
        X Only trace wedges for scene vertices that are adjacent to silhouette edges.
        X Only trace wedges for light source vertices and edges that lie
            on the light source's silhouette edge when viewed from the occluder's
            vertex or edge. (For example, if I have a spherical light source.)
        X Do not trace wedges for edges or vertices that are backfacing.
            X This should be added to DiscontinuityMesher::traceWedge,
                but it isn't entirely straightforward in the case of EV events,
                because a simple dot project relative to 'V' will have to be
                treated backwards if the face is between E and V.
        X Do not cast wedges from the back side of light source faces.
        X Do not cast critical line segments onto backfacing triangles.
        X Figure out how to only record the extremal lines.
            X Only trace a wedge when all of the faces adjacent to the vertex
                and the edge are on the same side of the wedge (the maximal boundary),
                or when the adjacent faces for the vertex are all on one side
                of the wedge and the adjacent faces for the edge are all on 
                the other side of the wedge (the minimal boundary).
            X If I do this, can I get rid of the silhouette tests I already have,
                or do I still need them?
                X I still need them or otherwise I'll wind up generating shadow 
                    line segments for interior edges and vertices.
            X This seems to work pretty well, but the following tests fail, and are
                missing line segments:
                X light-split
                X adjacent
        X The two-cubes test is missing an exterior extremal line segment
            (I thought I read that none of the exterior extermal line segments should 
            be missing because they're composed entirely of VE and EV events,
            not EEE events.)
        - DiscontinuityMesher::edgeIsSilhouette and vertexIsSilhouette should consider
            edges that border both light sources and occluders to be silhouette edges.
            - Create tests for these with light sources inset amongst occluders.
    X Put back the zero area triangle test I removed from WedgeIntersector::initializeTriangle,
        correcting it this time (it was completely wrong before),
        and also fix the similar test in initializeWedge.    
    X Do more tests to verify that the critical 3D line segments are being generated.
        X Do a test of a cube sitting on a triangle, contacting it, with a tiny
            light source casting a shadow off to the side.
            X This makes two asserts fail and if I comment those out,
                it looks like the shadow is missing a line segment leading from one
                of the small triangles in the shadow to one of the points of contact.
            X I think this case is generating sets of coincident line segments
                on the groundplane triangle. I guess that's OK because I'll
                filter them out later.
            X The problem is that DiscontinuityMesher::traceWedge's test for 
                discarding line segments above the occluder 
                is discarding line segments that it should not,
                because some of the T values are almost exactly 1 but not quite.
                X I think I need to exactly track the T=1 plane clipping in 
                    WedgeIntersector::clipToVeWedge and clipToEvWedge,
                    and assign the T values in those cases to exactly 0,
                    just as I assign exact values for S=0 and S=1 in the other
                    clipping cases.
                    X This didn't solve the problem, but I modified the traceWedge
                        comparison in a way that I think was fair.
        X Do a test of a cube interpenerating the groundplane triangle.
            This fails, with extra line segments that look like they're associated
            with the portions of the edges under the groundplane.
            See: http://traipse.com/discmesh/penetrating-cube.png
            X I am pretty sure this is failing because WedgeIntersector::clipToVeWedge
                does not clip edge DE against edge PQ, and treat the two segments
                that result from the split separately.
            X Rewrite both clipToVeWedge and clipToEvWedge in terms of 
                other more basic functions that make them easier to manage,
                and make the new clipToVeWedge handle the case of outputting two
                line segments by clipping the input line segment against line PQ.
        X The interpenetration test doesn't create any line segments where the objects
            interpenetrate, even though there would be a significant shadow
            discontinuity at that point.
            X Can I make the existing algorithm deal with that case, or is this
                something I have to handle as a preprocess?
                X I have to handle it as a preprocess.
        X Light source adjacent to occluder.
            X This causes an assert to fail.
            X I fixed the assert, but the adjacent.rfm test doesn't cast a shadow.
            X Now it casts a shadow, but one end of the shadow is open.
                X The tests DiscontinuityMesher::edgeIsInFrontOfLightSourceFaceAdjacentToVertex
                    and vertexIsInFrontOfLightSourceFaceAdjacentToEdge are culling
                    out this line segment.
                X Rather than do an epsilon test on the dot products in the frontfacing tests,
                    I should skip the frontfacing test entirely if I know that the
                    edge in the VE test or the vertex in the EV test is adjacent to the
                    face that is adjacent to the vertex or edge in those tests, respectively.
                    X However, in my test case, I am pretty sure these primitives aren't
                        actually adjacent. The light source and triangles don't
                        share an edge; they have two coincident edges.
                    X I modified adjacent.obj/rfm so that the light source face
                        and occluder face are adjacent.
                    X Implement this to assume correct adjacency, and then plan
                        to write a program to clean up the input data.
                        X Make a list of things that a future cleanup 
                            preprocessing program will have to do and plan it out.
                            (split intersecting triangles, remove degenerate triangles,
                            merge coincident geometry)
        X Occluder that straddles the plane of a light source. Should be half in shadow,
            with a critical line at the splitting plane.
    X For the extremal lines tests, try only adding interior extremal lines
        for VE events, but not for EV events. I think this might get rid of
        the superfluous interior extremal lines where the curve doubles back
        on itself. For EV events, only add exterior extremal lines.
        X This seems to work great.
    X The Discontinuity Meshing for Complex Environments papers says 
        "In addition to these visual events, visual events are included which
        result from scene polygons whose plane intersects the light source."
        Create a test case of a big light source with an occluder that fits
        that description and see what happens. Shouldn't it just work?
        X I tried this and it seems to work well enough. Even if I could improve
            the handling of this case by projecting additional line segments,
            it's not clear that this case will ever occur in real scenes
            or have any significance.
    X The four-boxes test output has a little line segment sliver under one of the boxes.
        Why is that?
        X It looks like it's a discontinuity from an EV event of the bottom corner
            of one of the top boxes, but since that corner lies in the plane of the
            top surface of the bottom box, its shadow is not projected onto the top
            of the bottom box as a point, but passes through it.
        X Fix this (see below).
    X In the four-boxes test, the shadow edges seem to creep underneath the edge of 
        that same box in two places. Why is that?
        X My representation of wedge space is flawed, because the transformation
            from world space to wedge space is nonlinear, which means that
            a vertex that intersects an edge in world space won't necessarily
            intersect it in wedge space.
        X Create a plan for revising my existing code to resolve this problem.
            (Detailed below.)
                    be maintained after the conversion.
    X See if it'd be possible to handle circular area light sources at infinity
        as a special case. Would use this use regular EV events, but a special
        version of the VE events with parallel lines?
    X Store each line segment with the faces they're cast against.
        X Don't use LineSegment to record these, because it has extra space-wasting
            baggage that we don't need. Make a FaceLineSegment class
            that's a little more compact. I think I only need a pair of world space coordinates
            and endpoint identifiers, and I'd really like to store the endpoint
            identifiers more compactly, if that's possible.
        X Make a map of faces to FaceLineSegmentVectors.
        X In DiscontinuityMesher::traceWedge, append the line segment to the
            FaceLineSegmentVector for the face, creating it if necessary
            and adding it to the map.
            X Add a Retriangulator to DiscontinuityMesher, initialize it,
                and call addFaceLineSegmentToFace repeatedly.
    X Write the code to tesselate the mesh faces using the constrained Delaunay
        triangulation code and the critical line segments.
        X Make sure I'm really identifying the endpoints uniquely. I think I'm not when
            multiple wedges intersect the same triangle edge, since they're all identified
            by the same edge pointer.
            X Maybe these endpoints should be identified both by the existing
                triangle edge, and the occluder edge or vertex.
            X I don't think it can be just the occluder edge/vertex, since multiple
                wedges may be projected from the occluder to the same edge.
            X Do I really have to include both the wedge edge and vertex, and then
                for distant lights, the light vertex index?
            X I think I can deal with this by giving each wedge a unique index 
                as they're traced, and recording the edge and wedge index
                as the unique identifier.
        X Implement Retriangulator::splitFaceLineSegments.
        X Implement Retriangulator::subdivideEdges.
        X Implement Retriangulator::subdivideFaces.
        X Make sure I have a way of symbolically determining which endpoints lie
            on a particular face edge.
        X Make sure I have a way of querying if an endpoint identifier
            references a particular edge.
        X Maybe as I go along I should create a map of edges to line segments whose
            endpoints lie on that edge, just as I create a map of faces
            and the line segments that lie on them.
            X Then split the edges as a first pass, before subdividing the faces.
        X Before making the CDT call, test to see if any of the input vertices
            have the same exact position in space, even if symbolically
            they are considered different. This might be the case if multiple light vertices
            together are perfectly colinear with respect to an occluder vertex.
        X Somewhere earlier in the algorithm, I will have to keep track
            of if a line segment endpoint corresponds to a triangle edge or vertex,
            so I can take that into account when using CDT to triangulate 
            the discontinuity mesh. Otherwise, I'll have situations where 
            a line segment vertex falls almost on a triangle, but not quite,
            because of floating point roundoff error, which will result
            in a poor triangulation near the edges of the triangle.
            Instead, I'll want to use this information to determine when to
            explicitly subdivide the triangle's edges.
        X Split all line segments against each other where they intersect.
            X When I clip the line segments against each other before creating the CDT,
                it's critical that I handle the cases when colinear line segments overlap,
                or when vertices intersect the middle of other line segments.
                I'm not sure my line segment clipping code handles these cases correctly.
        X As I create new triangle vertices around the edges, or add line segments
            that intersect existing triangle vertices exactly, I could create
            a map of EndpointIdentifiers to integers, and use those as
            vertex attributes to keep track of vertex correspondence
            (rather than trying to find some way of assigning EndpointIdentifiers
            directly as vertex attributes).
        - I think it's really important that neighboring triangles be taken into 
            consideration as each triangle is tessellated.
            - This will help in a situation were gaps along the umbra straddle
                existing triangle edges, and generally result in an overall better
                tessellation of the polygons.
            - Loop over all the triangles.
                - When a neighboring triangle hasn't yet been tessellated,
                    unfold that triangle so it lies flat on the plane next to the
                    triangle being tessellated.
                - Use CDT to tessellate the triangle along with the vertices and
                    constrained edges of the adjacent triangles that have not yet
                    been tessellated.
                - Clip the resulting set of triangles to the triangle being tessellated.
            - This won't handle the situation where a narrow triangle falls entirely
                in between the gap in umbra line segments.
                - This would suggest that I could do better by handling EEE events
                    explicitly.
            - If I can't handle EEE events, an even more robust approach would be to
                unfold as many adjacent triangles as I could into a plane,
                without causing overlaps, and triangulate them all at once.
    X Build the discontinuity mesh for each triangle.
        X Find the intersection points of all the discontinuity edges in the list,
            and split them, creating new edges.
            X What does my line segment set intersection code do with
                colinear line segments?
        X Build the set of points and edges I'll pass to the CDT code.
        X Endpoints of edges may lie on other edges or the edges or vertices
            of the triangle. Handle these cases.
        X It's possible that despite symbolic tests, I'll have two endpoints
            that are coincident on the face of a triangle. Disjoint polygons
            whose shadows are coincident at a single point
            could cause this.
            X This case must be dealt with or else the later Delaunay triangulation 
                step will fail.
        X I'll want a set of edges that do not intersect, and a set of vertices
            that lie on the triangle or on its edges.
            X If despite my best effort, line segments do intersect (based on the
                exact arithmetic test), throw out the shorter of the two line segments.
            X Does my exact line segment intersection code report colinear line segments?
            X Make absolutely sure I handle the case when line segments
                are colinear. They must be split and not intersect.
        X It should not be the case that I'll wind up with a vertex that has
            only one adjacent edge.
        X It's possible that once I consider a particular face, it'll no longer
            be a triangle, because some of its edges will already
            have been subdivided.
        X Split existing face edges that endpoints intersect, unless they've already 
            been split by processing of neighboring faces.
        X Use constrained Delaunay triangulation to retriangulate the triangle.
            Each line segment is a constraining edge.
            X It can't be the case that any vertices are coincident or that
                any vertices lie in the middle of any edges,
                (or that any edges overlap along their length).
        X Remove the old face.
        X Wire up the new faces into the mesh.
    - Illuminate the discontinuity mesh and compute the face vertex colors.
        X To view this, I'll need to write my own RFM file viewer first.
            X Actually I can do this with freewrl and by writing rfm2wrl.
        - Not sure how this is going to work. Maybe it'll use backprojections.
        - Create the backprojection by reusing the wedge tracing code.
        - Create a mesh of triangles representing the unobscured portion of a light
            triangle from a mesh vertex's point of view.
        - Still not sure how this will work but one paper casts a ray from
            each triangle center to the mesh vertex to see if there are any occluders.
    - Create an AABB hierarchy to speed up the algorithm.
        - Speed up the wedge tracing by stepping through the AABB tree incrementally
            along the wedge until the wedge span is fully obscured, rather than 
            by finding all the intersections with the wedge and stepping through them.
    - Triangulate the input, marking new edges, and then at the end, untriangulate 
        the mesh by removing temporary edges I added earlier.
        - Also turn pairs of triangles with "good" angles into quads.
        - Write this as two mesh library functions so I can reuse it again later,
            for example in CSG code.

X Support distant lights.
    X Figure out how EndpointIdentifier is going to work for distant lights.
        I can't use the light source vertex because I'll be changing its
        position all the time. I think I really want to use the the occluder vertex,
        plus an index indicating the angle around the light source, 
        plus a light source index (assuming there is more than one light source).
        Or, should I redo the EndpointIdentifiers in some other way?
        X Remember to handle multiple distant lights.
        X I think I need EndpointIdentifier::fromVertexAndInteger, where the index
            would uniquely identify the light source vertex or edge of the light source
            from the point of view of a particular vertex in the scene.
            X This has to be written in such a way that EndpointIdentifier comparison
                won't be confused when an integer identifier has the same
                numeric value as a vertex or edge pointer cast to an integer.
        X I'd reference the indices rather than the light source vertices or edges
            when creating the EndpointIdentifiers. 
        X Create the EndpointIdentifiers used in clipToVeWedge and clipToEvWedge
            in setVeEventWedge and setEvEventWedge, so that it's easier to create
            different values for the distant light source VE and EE event cases.
    X Figure out how to compute a radius for a polygonal circle that has the same
        area as an ideal circle with a specified radius.
        Given a circle with radius s, the radius (to each vertex) of an
        isogonal polygon with the same area is:
        r = sqrt(2*pi*s^2/sin(2*pi/n)/n)
    X Write a DistantAreaLight class with the parameters below, and support
        multiple distant lights even though they won't initially be supported
        via command line arguments.
        X Put this in a new library called 'light'.
    X Add the following command line arguments to rfm_discmesh:
        X Position of light source in the sky 
            X altitude (angle in degrees above horizon)
            X azimuth (angle in degrees from north, toward the east)
        X Angular diameter (in arcminutes, default = 32.15, the sun)
            X Because the light source will be polygonal, make sure this is interpreted 
                as the average diameter. 
        X Intensity (red, green, blue)
        X Sides (default = 6)
        X Up vector (default = 0 1 0)
        X Orientation (degrees, default = 0)
        X In the future, I'll define this information in an XML file,
            but for development purposes I'll use command line arguments.
    X Make DiscontinuityMesher not fail if there are no emissive triangles if
        a distant area light source is specified on the command line.
    X Rename DiscontinuityMesher::projectLightSources to projectEmissiveFaceLightSources.
    X Write a function that, given a vertex position in the scene, and the bounding box
        of the scene, and the light source description, computes a virtual light
        source vertex position just outside the bounds of the scene geometry.
        X Make this a member function of light::DistantAreaLight.
    X Write projectDistantAreaLightSources.
        X For each distant area light, loop over the vertices of the light source,
            and then over the edges of the light source.
            X Keep track of a unique index for each distant light source vertex and edge.
            X Using the function I wrote earlier, compute the required virtual light source
                vertex positions.
            X Trace modified VE events for each distant light source vertex.
            X Trace EE events for each distant light source edge.
        X First, do this without the extremal edge and silhouette testing. Then go back
            later and support those tests.
            X Make DiscontinuityMesher::vertexIsSilhouette
                and DiscontinuityMesher::edgeIsSilhouette take vector to the light source
                as their second argument.
                X DiscontinuityMesher::vertexIsSilhouette would only test one light
                    source vector at a time.
            X Add silhouette edge testing.
            X Add extremal edge testing.
            X Make sure that in the EE case, shadow line segments are correctly projected
                with parallel light rays as a rectangle, rather than as a wedge.
        X Also, the first time through, ignore the EndpointIdentifier issues.
            Support them in a later pass.
            X This may require looping over mesh elements and then light source vertices,
                rather than the other way around, as I have it now, to be able
                to maintain index correspondence. Although on the other hand,
                I'm not sure that's even necessary. Or, maybe it is in the EE case.
        X Make the following functions handle the distant light cases:
            X testTriangle
            X projectPointOntoEdgePQ
            X projectEdgePQPointOntoLineSegment
            X transformWorldSpacePointToWedgeSpacePoint
            X transformWedgeSpacePointToWorldSpacePoint
            X initializeWedge
            X initializeTriangle
            X triangleIntersectsWedgePlane
            X triangleIsFrontfacing
            X testTriangleVertices
            X testTriangleEdges
            X Draw pictures of how V, W, P, and Q are positioned in the four cases
                and then look over all the functions above again.
            X clipToPlane
            X recordClippableEndpointsAsLineSegment
    X Add a --no-emissive flag that ignores emissive faces, so I can easily
        run tests on my existing models with distant area light sources only.
    X This crashes:
        RUN cube --no-emissive --sun-azimuth 30 --sun-elevation 60 --sun-sides 6
        X It crashes in DiscontinuityMesher.cpp, line 416, I think because
            WedgeIntersector::vertexPtr is returning something bogus.
        X Also, DiscontinuityMesher::traceWedge calls WedgeIntersector::edgePtr
            and WedgeIntersector::vertexPtr, which might not necessarily return
            useful values in the case of distant lights.
    X This is a simple case which creates a degenerate edge where it should not.
        RUN triangle-four-square --no-emissive --sun-azimuth 80 --sun-elevation 60 --sun-sides 4
        X Actually the edge isn't even degenerate. It's just not culled
            when it should be.
        X It's an DISTANT_LIGHT_EV_EVENT.
        X I tracked this down to WedgeIntersector::triangleIsFrontfacing
            which does not appear to work properly in any of the cases 
            (except perhaps for the EE case).
        X I fixed WedgeIntersector::triangleIsFrontfacing.
    X This creates a degenerate single-point triangle.
        RUN pile-of-boxes --no-emissive --sun-azimuth 80 --sun-elevation 60 --sun-sides 12
    X This has degenerate isolated triangles.
        RUN temple --no-emissive --sun-azimuth 40 --sun-elevation 50 --sun-sides 12
    X This creates superfluous edges.
        RUN pile-of-boxes --no-emissive --sun-azimuth 45 --sun-elevation 90 \
            --sun-sides 24 --sun-angular-diameter 1000
    X This has superfluous edges and degenerate edges that aren't
        coplanar with any polygons.
        RUN well --no-emissive --sun-azimuth 40 --sun-elevation 50 --sun-sides 12
        X I'm pretty sure that this is happening because the well model
            contains several degenerate faces around the rim.
            X Can I use Silo to clean up these degenerate faces and try it again?
            X In well.obj, the well object has these stats:
                X 206 faces/triangles
                X 309 edges
                X 105 vertices
            X Upon closer inspection, this model is awful and contains many slivers. 
                Ignore it for now.
    X Write WedgeIntersector::setDistantLightVeEventWedge.
    X Write WedgeIntersector::setDistantLightEeEventWedge that takes two vertices and an edge.
        X Store the second vertex in mW.
        X Assert that the two rays are nearly parallel.
    X The EE event lines don't show up.

X In WedgeIntersector::initializeTriangle, I'm not sure that I need the vertex
    reordering (the swap calls) to improve floating point robustness, because
    I'm keeping track of vertex origins symbolically.
    X Changing this makes many of my unit tests fail, so leave it alone.

- After the critical line segments are projected onto the faces, I could safely simplify
    the resulting mesh further by doing the following, after splitting the edges
    against each other and merging vertices, but before the constrained Delaunay
    triangulation is calculated.
    - Collapse edges under a certain length, but choose one of the two vertices
        as the resulting vertex position, rather than averaging them. This is important
        for the backprojection to work correctly.
    - Remove vertices between pairs of nearly colinear line segments to within
        some tolerance.
    - Remove slivers.
    - Could a series of critical line segments that intersect, 
        creating superfluous line segments along the shadow's umbra, 
        be simplified by trimming the extra line segments at the points of intersection?
    - On second thought, I doubt I can do any of this until after the lighting
        has been calculated, without introducing visual artifacts.

X Write and unit test a cgmath function to calculate the closest point on two lines in 3D,
    given two pairs of points that define the two lines.
    X Rework WedgeOperations.cpp in terms of the new function.

X Write and unit test a cgmath function to clip a line segment defined by two points
    against a plane defined by a point and a normal.
    X Rework WedgeOperations.cpp in terms of the new function.

X Try to split out more of WedgeOperations into cgmath, with unit tests.

X Unit tests of executables aren't supported yet. Modify SConstruct so that
    libraries are built for each executable so unit tests can link against them.
    Building the .cpp files into the unit tests didn't work
    because SCons complained that they were referenced twice.

X Write general purpose code to compute the intersections in a set of line segments.
    X Figure out an API for a naive version of this.
    X Write unit tests that test the following cases:
        X No intersection between two lines, but whose bounding boxes overlap.
        X Intersection between two lines.
        X Two lines intersecting with a third line.
        X Vertical lines.
        X Horizontal lines.
        X Two lines intersecting at shared endpoints.
        X Three lines intersecting at the same point.
        X Five lines intersecting at the same point.
        X A line segment endpoint having the same X value as an intersection
            between two other lines.
        X A line segment endpoint having the same Y value as an intersection
            between two other lines.
    X Implement it.

X Make unit tests for cgmath::GetIntersectionOfTwoLines.

X Rename the arguments p1, p2, p3, p4 in GetIntersectionOfTwoLines
    to p0, p1, p2, p3 to be consistent with the others.
    (And intersectionPoint to ip, or rename the other function.)

X Get rid of my thread library and use boost::thread instead.

X I need support in SConstruct for a src/sandbox subdirectory for programs
    like boost_pool_test.

- Write rfm_view.
    - It should support a comparison mode to quickly toggle between two RFM files,
        maintaining the same camera position and orientation, to help with
        debugging, so I can see what the result of a change to an algorithm is.

- Write rfm_clean, to preprocess a mesh to make it well-conditioned input for rfm_discmesh.
    - Split intersecting triangles.
    - Split edges that have vertices that intersect them.
        (Detect and remove T intersections.)
    - Split colinear edges.
    - Clip coplanar faces against each other so that polygons are not coplanar.
    - Split faces that have edges/vertices that lie in them.
    - Merge coincident vertices.
    - Merge coincident edges.
    - Remove degenerate triangles.
    - Once I write this, then rfm_discmesh's LineSegmentCollection no longer has to
        try to split intersecting line segments, because there won't be any.

X Write a quick rfm2wrl file converter.
    X 'freewrl' at the command line runs the FreeWRL VRML viewer I downloaded.
    X /Applications/FreeWRL/tests/27.wrl is an example of how to specify vertex colors.
    X Also see http://graphcomp.com/info/specs/sgi/vrml/spec/part1/examples.html
    X Write a small file by hand containing two triangles with vertex colors.
    X Write rfm2wrl
        X Write out actual face vertex colors. Just assume for now that only
            vertex face colors are defined and that there is no lighting,
            because that's the only case I care about in the short term.

X Resolve the problem where my world space to wedge space transformation is nonlinear,
    which causes artifacts in the discontinuity mesh.
    X Systematically go through every file, determining what needs to be changed.
        X DiscontinuityMesher.cpp
        X WedgeIntersector.cpp
        X test/WedgeIntersectorTest.cpp
        X LineSegmentCollection.cpp
        X test/LineSegmentCollectionTest.cpp
        X Region.cpp
        X test/RegionTest.cpp
        X Endpoint.cpp
        X EndpointIdentifier.cpp
        X LineSegment.cpp
        X WedgeSpace.cpp
        X WedgeSpacePointCorrector.cpp
    X Before implementing any of this, work out the math by hand to the point where
        I am convinced it will work.
        X In particular, I am concerned about the case of off-axis PQ line segments.
            After I've computed all the 's' values for the endpoints and clipped
            the line segments against each other to compute visibility,
            how do I use those 's' values to compute the new worldspace coordinates
            for the visibility-clipped edges?
            I suppose I could always compute the intersection between the
            line whose endpoints are the point corresponding to 's' along VQ 
            and point V, and the line segment being clipped. That has to work.
            X Before implementing anything, first determine if I can do this
                entirely based on the values of 's'. I'll know the values of 's'
                for the endpoints of the line segment, and the new clipped
                endpoints, so given that it should be just a simple bunch of ratios
                if everything linear. Will this really work?
                If so, it'd be a cleaner solution.
                X I drew a picture where PQ is angled, and another edge spanning
                    the wedge is horizontal, and it clearly shows that the
                    projection of evently spaces points across the edge onto
                    PQ result in a non-evenly spaced set of points.
    X Create a branch for this change, so I can check things in as I go along
        but easily throw it all away if this turns out to be a bad idea.
    X Get rid of all the wedgePosition comparisons in WedgeIntersectorTest.cpp,
        but add specific tests at the end that ensure that the world to wedge space
        comparisons work.
        X Remove the wedgePosition comparisons.
        X Add a test of the world to wedge space conversion.
    X Deal with WedgeSpacePointCorrector.
        X WedgeIntersector::recordClippableEndpointsAsLineSegment ultimately stores
            the line segment as a pair of Endpoints in a LineSegment.
            Maybe to Endpoint I should add the projected 's' value of the
            endpoint (along line PQ), and compute it right there,
            snapping it to 0 or 1 if necessary.
        X Add mS to ClippableEndpoint.
        X In testTriangle, compute mS for the two endpoints based on their
            worldspace position within VPQ.
        X Make clipToPlane take an optional value of s as an argument (define
            UNDEFINED_S in Endpoint, as std::numeric_limits<float>::max()
             as an undefined value), and set it in the passed ClippableEndpoints
            whenever the line is clipped.
            I'll want to use UNDEFINED_S for the cases where I clip against edge PQ.
        X Get rid of WedgeSpacePointCorrector entirely.
        X Get rid of the correctWedgeSpacePoint calls in recordClippableEndpointsAsLineSegment.
        X Add mS to Endpoint, and accessor functions.
        X Assign Endpoint's mS values in recordClippableEndpointsAsLineSegment  
            before they're set in the output LineSegment.
        X Update the new WedgeIntersectorTest unit tests to ensure that
            the new values of 's' are being computed correctly.
    X Implement the new wedge space transformation.
        X Fix all the unit tests to reflect the new coordinate space.
            X Hopefully I only need to update the wedgePosition tests.
        X Have WedgeIntersector::initializeWedge set some member variables
            I can use to do the world space to wedge space conversion efficiently.
        X Move WedgeSpace.cpp's ConvertWorldSpacePointToWedgeSpacePoint function
            back as a member function of WedgeIntersector.
        X Put all line segments in a plain rectangular 2D wedge space, where the -Y axis points
            straight down the wedge between VP and VQ, and +X is 90 degrees off from that.
            X Make 'V' always be the origin, with always -Y pointing in the light direction,
                 consistently for the VE and EV cases, so I don't have to flip
                 the wedge space coordinates later before sorting.
        X Make sure the unit tests that have failed up to this point now pass.
    X Update LineSegmentCollectionTest to set values of 's' for the endpoints that
        match the wedge space 's' coordinates.
    X Update LineSegmentCollection::splitLineSegments.
        X It has to be updated to calculate new values of 's'
             for the newly created line segments as they are clipped against each other.
             X This should be as simple as adding additional linear interpolation
                 of 'S', just as now it interpolates the world and wedge space positions.
             X It's not that simple. I have to project the new point against PQ.
                 The mapping is nonlinear.
             X I have to pass the vertex back to WedgeIntersector for reevaluation.
    X Implement the new wedge space sorting.
        X Rename LineSegmentCollection::sortLineSegmentsByMaxT to sortLineSegments.
        X Sort the line segments using qsort with the following comparison logic:
            X If any endpoints of the line segment are shared, the line segments are equal.
                X This is not true. The ordering still matters in this case.
            X Considering the first line segment, find the normal vector of the line segment 
                that points toward V.
            X If the two vertices of the second line segment are on the same side as N 
                (test using a dot product), then the second segment is less than the first segment.
            X If the two vertices are on the back side of N, then the second segment 
                is greater than the first segment.
            X If the two vertices straddle the first line segment, then do the comparison 
                based on the second line segment instead of the first.
            X The logic must be reversed if the line segments are between V and the light source.
            X If the line segments are on opposite sides of V, this must be handled
                as a special case that overrides all the other cases.
            X This needs boatloads of unit tests.
    X Update LineSegmentCollection::findVisibleLineSegments.
        X Replace all references to wedgePosition()[0] with references 
            to the new 's' parameter of the Endpoints.
        X Calculate the wedge and world space coordinates by mapping 's' to a parametric
            position along a given line segment by doing this:
            Use 's' to find a point M along PQ in wedge space. Find the 
            parametric value of the intersection of line VM and the line segment
            along the line segment. Use that parametric value to 
            find the wedge space and world space coordinates.
    X Running TestLineSegmentCollection clearly generates some inaccurate results.
        I probably missed some cases in the line segment less than operator.
        X Fix what's broken.
            X I wasn't properly handling the case when endpoints of the line
                segments being compared were coincident.
        X I think what's happening is that the clipping that occurs
            in LineSegmentCollection is generating line segments that
            actually do intersect at small scales because of floating point
            roundoff error, and therefore confuse the LineSegment
            less than operator.
        X When I calculate the line segment intersections, can I record the world
            space position, the wedge space position, and the value of 's'
            for the intersection, calculated once, for both line segments,
            and then use that later so I'm guaranteed to have the clipped line segment
            endpoints in common?
        X I think LineSegment::operator< needs more work, and that's why
            TestLineSegmentCollection is failing.
            X I think this works now. My unit tests fail but I think that's in cases where
                A and B do not overlap from the point of view of V.
                X Fix the unit tests.
            X Maybe change LineSegment::operator< to use exact::TestOrientation2d 
                instead of the dot product, so it won't have floating point robustness issues.
        X Try running the test again with the light source in a different position.
            X Fix the tests in TestLineSegmentCollection that generate bogus output.
                X Some of them generate line segments that don't even coincide with
                    existing lines in the mesh.
            X This is still failing. There must be a subtle detail I am overlooking,
                or the algorithm is breaking because of floating point robustness issues.
                X It's possible I should rewrite this part of the code to use the
                    radial sweep line approach described in one of the papers,
                    if it seems obvious that it would be inherently more robust.
                X I threw a bubble sort into LineSegmentCollection::sortLineSegments,
                    which was probably a bad idea, and it didn't help either.
            X Look into the last test in TestLineSegmentCollection that has artifacts.
            X Run even more tests. I can't test this enough.
        X The problem is that there was more to Newell's algorithm that I didn't know about.
            X I found the Newell's Algorithm paper, so implement that.
                X If it turns out not to work, I can fall back on that other approach
                    based on 2D depth clipping of unsorted line segments.
                X I don't think I need to use exact arithmetic for any of this.
                X Sort the line segments in decreasing order of their minimum Y value.
                    The line segments with the smallest Y values (those farthest
                    away from the light source) will be at the end of the list.
                    X Rename LineSegment::operator< to LineSegment::occludes.
                    X Add a new LineSegment::operator< that compares the
                        minimum Y values and returns true if 
                        min(lhs.y0, lhs.y1) < min(rhs.y0, rhs.y1)
                        (so they are sorted in increasing order)
                X Loop over the line segments in the original vector
                    and store the results in a new vector which will be swapped
                    with the original.
                    X For each face P in the list, starting at the beginning of the list
                        (the line segments that are farthest away)
                        see if it occludes none of the line segments Q
                        that its min/max Y values overlap.
                        To do this, find the maxY value of the line segment,
                        and then work through the list, comparing it against
                        the min Y value of each line segment Q, until 
                        max(P.y0, P.y1) > min(Q.y0, Q.y1).
                    X If P occludes Q, move Q to the beginning of the list, and start over.
                        X Mark the line segment as having been reordered,
                            and assert that any line segment is not reordered twice.
                            (This should never happen if none of my line segments intersect.)
                    X If P occludes none of the considered line segments,
                        append it to the output vector.
                X Here's how to see if P occludes Q.
                    X If the projected "screen space" (X/Y) coordinates
                        of the two line segments do not overlap, P does not occlude Q.
                    X If P is not entirely behind the extended line of Q with respect
                        to the light source, then P does not occlude Q.
                        X Handle the case when endpoints of P and Q are coincident.
                    X If Q is entirely in front of the extended line of P with respect
                        to the light source, then P does not occlude Q.
                        X Handle the case when endpoints of P and Q are coincident.
                    X If all of these tests fail then P occludes Q.
                X Add an assert to LineSegment::occludes to ensure that 
                    the assumption we're making about depth in Y already being
                    worked out holds, and add a comment to that effect.
                X Handle the cases when P and Q are behind the origin.
                    X Will the projected "screen space" test work or not?
                    X The halfspace tests will have to be changed.
                X Handle the case when P and Q are on opposite sides of the origin.
                    X I believe I can assume that this will never happen because
                        it will already have been established that P and Q overlap
                        along the Y axis.
                X Handle the case where P or Q are degenerate.
                X Explicitly handle the special case when a vertex is coincident 
                    with the viewport (the origin).
    X 'RUN shadow-creep-bug' winds up with two superfluous vertices on the common edge
        near where the shadow creep artifact occurred.
    X 'RUN shadow-creep-bug' is missing line segments.
        X 'RUN contact-shadow' is also missing line segments.
        X When WedgeIntersector::clipToVeWedge is clips the line segment to PQ,
            it assigns UNDEFINED_VISIBILITY_PARAMETER,
            which throws off Newell's Algorithm later on, which is expecting
            well-defined visibility parameters.
            X Maybe at some point later on, when a visibility parameter
                is undefined, I should be computing it based on
                the world space coordinate.
    X 'RUN penetrating-cube' leaves a superfluous line segment.
        X I fixed this with an epsilon test in WedgeIntersector::occludesLineSegment.
        X This should be handled more robustly by simply keeping track of whether
            each line segment is in front of, or behind, the occluder, 
            when it is clipped to line PQ for VE events or point V for EV events.
    X 'RUN four-boxes' fails.
        X An assert in LineSegment::occludes fails.
        X Ifdef'ing out the assertion creates results which look OK,
            but this needs to be investigated further.
    X 'RUN cylinders' fails.
        X Two line segments are nearly colinear with two nearly coincident endpoints,
            which causes LineSetIntersector::findIntersections to fail an assert.
        X Maybe before I clip the line segments against each other, I should
            be snapping vertices based on their endpoint identifier.
            That would help me avoid these cases where two vertices are
            nearly coincident.
            X This would be performed at the top of 
                LineSegmentCollection::findLineSegmentIntersections.
            X Maybe just do a test of this to see if there are discrepancies
                in the wedge space positions.
        X After clipping the line segments against each other, I could do another
            pass to find line segments that still self-intersect despite the clipping,
            and then toss out the shorter of the two line segments,
            so that there are no intersections.
        X I decided not to bother with anything this sophisticated. I just throw out
            intersecting line segments in the Newell's algorithm code when they
            become a problem.
    X 'RUN coplanar' has a spurious line segment that extends above the plane
        of the polygons.
        X It's the result of a VE event. It goes away if I comment that code out.
        X The line segments are in the right planes coming out of
            WedgeIntersector::recordClippableEndpointsAsLineSegment.
        X Making LineSegmentCollection::splitLineSegments not actually split the
            line segments makes the spurious line segments go away.
        X cgmath::GetIntersectionOfTwoLines was generating bogus results when the
            two lines were nearly colinear. I fixed this by converting all the
            internal calculation to doubles.
    X 'RUN well' seems strange inside the well. Not sure if it's correct or not.
        X I'm assuming that as weird as this looks, it's geometrically correct,
            and just what I get by crudely approximating curved surfaces with triangles.
    X In DiscontinuityMesher::traceWedge, replace the <= 1.0 tests at the bottom
        with a test relative to the occluder. Or, tag each LineSegment
        with a boolean value indicating if it is above or below the occluder.
        X Can this be moved to LineSegmentCollection::calculateVisibleSegments?
        X Give LineSegmentCollection a pointer back to WedgeIntersector, and then
            add a test to WedgeIntersector to return if a given line segment
            is between the light source and occluder or not.
    X Merge the branch. (revisions 1097 to 1179).
    X Remove the branch.

X cgmath::LineSetIntersector is not robust. It outputs intersection points that,
    when used to clip line segments, result in line segments that intersect.
    X Reassess exact::TestLineSegmentsIntersect, taking into consideration
        page 10 of "Robust Plane Sweep For Intersecting Segments".
        X There isn't a straightforward implemenation of this in terms of
            the orient2d test I already have, so I'm not going to bother.
    X I've decided to just fudge around this, and assume that line segments that
        are ill-behaved enough to cause these problems can be discarded.
    X Also, I modified cgmath::GetIntersectionOfTwoLines to use doubles internally,      
        which should make this function a lot better behaved.

X Maybe to work around the disjoint line segments on faces near the silhouette edge,
    I would be justified in not recording line segments on faces past a certain angle
    (instead of a full 90 degrees), since those line segments won't be
    contributing much intensity variation anyway.

X Create a mechanism so I can automate the tests in rfm_discmesh/test.
    X Give rfm_discmesh a mode where it can generate the discontinuity line segments
        and output them to a text file, sorted, and then another mode where it'll
        read that same text file in and compare the test output against it
        to see if the output has changed.
        X Add DiscontinuityMesher::setWriteDebugLineSegmentsToRfmFile.
        X Add a debug-lines flag.
            X This should invoke the existing behavior.
        X Add the debug-lines flag to the RUN script.
        X Implement DiscontinuityMesher::writeCriticalLineSegments.
        X Add a write-lines flag.
        X Don't bother sorting the line segments because this can't be done
            consistently when there are floating point errors.
        X Write the line segments to a text file as sets of six floats per line.
        X Implement DiscontinuityMesher::testCriticalLineSegments.
        X Add a test-lines flag.
        X When this flag is specified, read the file and compare the existing
            line segments to the contents of the file, doing a brute force search
            and with an epsilon test based on the magnitude of the numbers.
            X Special case when a number is exactly zero.
    X Then write a test.py script that "itest" will run automatically.

X Do a test with multiple light sources.

X Dan W. says that a*(1-t)+b*t is much more numerically stable than a+t*(b-a).
    X Look through my code to see where I'm using the second expression and replace
        them with the first. Maybe make explicit Vector2f,3f,4f and float functions for 
        doing it the robust way and then make a point of using them instead.

- Reconsider how I could handle EEE events, because I am worried about shading 
    artifacts being caused by gaps in the umbra line segments that straddle small polygons.
    It'd probably even be fine to approximate EEE events as line segments
    instead of curves, since that's what the CDT would turn them into anyway.
    - I read that EEE events only occur when two VE event surfaces intersect.
        See p. 43 of "Dynamic Discontinuity Meshing", Adam Worrall.
    - This is covered in "Interactive High-Quality Soft Shadows in Scenes with Moving Objects".
    - This seems involved enough that I am now leaning toward not bothering with EEE events
        and hoping that in cases where they are a problem, subdivision of the
        triangle mesh driven by nonlinear changes in intensity along triangle edges 
        will help enough.

- To efficiently calculate the intersections in a set of line segments,
    add one line segment at a time, comparing it against the existing line segments
    that fall within the bounding box of the new line segment.
    Build a hierarchical data structure to speed this up as you go along.
    This is what David Hedley did in his thesis.

X See if there's anywhere in the code I could benefit from doing computation with doubles.

X Add a command line option to obj2rfm to specify a material that should be considered
    a light source, and an emission color that should be assigned to it.
    X Add the command line arguments.
    X Write a function in the str library to parse colors specified on the command line
        of the form "red,green,blue" (e.g. 255,255,255 for white), 
        returning it as a Vector3f in the range 0 to 1 (not 0 to 255).
    X Test if the specified material exists in the MTL file and print an error 
        if it does not.
    X Find the RFM mesh attribute material index for that material name.
    X Set the emission component in the RFM file based on the color and intensity.
    X Update the rfm_discmesh/RUN script to read the OBJ files directly,
        convert them to RFM on the fly in a temp file, setting the 
        emission attribute of the material named "LightSource", which I have
        consistently set in the MTL files.
    X Remove all the RFM files in rfm_discmesh/test.
    X A general solution to this problem, which would handle more than one light,
        would be an rfm_setattr program.

X All the functions in mesh/StandardAttributes.h should be renamed to start with "Get".

X Get rid of inline definitions in mesh library, make them not inline.

X Make retro-cpp-style.el hunt up the directory tree for the build/TAGS file.

- Maybe .level XML files would look something like this:
    - Actually, keep a separate XML file per fragment (subsection of a level).
    <level>
       <environment mesh="foo.rfm" />
       <distantAreaLight azimuth="30" altitude="50" angularSize="32" sides="12"
           intensity="1" color="255,255,245" />
    </level>
    - If it would ever be useful, I could embed XML in a .mesh file as a string.

X Running 'build' in a source directory does not rebuild the build/TAGS file.
    This only happens when 'build' is run at the top level, because it
    runs 'scons -u'. Is there any way to resolve this?

X Ctrl+C,J failed in a header file on this expression:
    const cgmath::Vector3f &up() const;
    Perhaps because the string "up" is too short.

- Is it possible I could recover some version of the interior EEE edge gaps
    by relaxing the constraint on what's an extermal edge and what's not,
    in the functions DiscontinuityMesher::wedgeIsExtremal
    and DiscontinuityMesher::distantAreaLightEvWedgeIsExtremal?

X Add some code to the con library to support standard boost::program_options
    for setting the log level, along with --quiet, --verbose, and --debug.
    Make all programs use these.
    X Redo the handling of the verbose flag in rfm_discmesh to use con::info.

X Add --verbose flag con::info messages to existing programs that do not have them.

X Get rid of unnecessary includes in header files.
    X cgmath
    X con
    X delaunay
    X exact
    X except
    X light
    X mesh
    X objfile
    X opt
    X rfmfile
    X str
    X timevalue
    X unittest

X Move all the ComparisonFunctor classes in Retriangulator.h to somewhere
    in the mesh library. Better yet, add comparision operators to the mesh primitives
    and then get read of all comparison functors throughout the code.

X For portability I want to define my own macros like WIN32 that are either 0 or 1,
    and do #if WIN32, rather than #ifdef _WIN32, because if there's a typo
    in the latter case, it'll silently cause an error.
    X Make all my NDEBUG or DEBUG symbols consistent. I use both. Maybe define RETRO_DEBUG
        as 0 or 1.

X Make unittest/UnitTestMain.cpp call con::SetProgramName, and then fix up all
    the unit test linking.
    X Then change the con::err call in Retriangulator.cpp to call con::error instead.
        (Otherwise, this can't be called because it'll fail because the program name
        has not been defined.)

X Rename the platform directory to config, and Platform.h to Config.h, and define
    RETRO_DEBUG in it, instead of in SConstruct.

- Try to get rid of any redundancy that might be in Retriangulator::subdivideFaces.
    - Maybe there are some maps or tests I don't really need.

- Reorder the code in subdivideFaces so that the test for coincident CDT points
    happens first, to make it impossible to submit the same CDT coordinate twice.

X I think cgmath::GetPrimaryAxesMostOrthogonalToVector might have to be modified
    to flip the order of the axes when the component with the greatest
    magnitude is negative. Otherwise, the CDT calculation will result in
    triangles whose point order is backwards.

X Add the test for degenerate edges on line 1025 of PointTriangulator.cpp to
    PointTriangulator::validate.

X Fix the RegionTest unit tests that I broke when I changed Region::computeDifference
    to assign unique identifiers to projected points.

X These tests fail:
    X coplanar
    X cube-light
    X cylinders
    X eee-test
    X eight-cubes
    X four-boxes
    X man
    X pile-of-boxes
    X shadow-creep-bug
    X temple
    X three-spheres
    X triangle-four-square
    X triangle-square
    X two-cubes
    X two-triangles
    X waffle
    X wall
    X well

X 'RUN two-triangles' looks good at first glance, but contains a few nearly coincident
    vertices on the groundplane, and several nearly coincident overlapping edges
    along the the edge of the yellow triangle, immediately below the pink triangle.
    X Maybe the problematic edges on the yellow triangle are caused
        by the CDT creating slivers around the triangle edge because when we
        subdivide that edge, it results in a polygon that is no longer convex.
        X Should I be using delaunay::PolygonTriangulator instead?
            X Maybe one answer is to modify PolygonTriangulator to take
                 auxilliary constraining edges as input.
                 X PolygonTriangulator::edgeIsConstraining should be 
                     modified to only return true for the polygon perimeter edges,
                     not for the auxilliary constraining edges.
            X Modify Retriangulator to use PolygonTriangulater instead.
            X It's important that my input polygon edges/vertices are specified
                 in counterclockwise order.
            X Make sure the slivers go away.

X 'RUN three-spheres' winds up with coincident edges/vertices in the groundplane.

X I'm worried my implementation of Retriangulator has serious flaws. It's passing bogus
    input to the CDT, and maybe it's not properly collapsing nearly coincident input
    vertices that should actually be considered equivalent.
    I don't think this is something I can trivially patch up.

X I think that when two faces share an edge, and each face dictates that the edge
    should be subdivided at a particular point, I'm subdividing the edge twice,
    instead of reusing the new vertex when the second face tries to redundantly
    handle the point.
    X Add EndpointIdentifier-based equality tests.

X Retriangulator can output polygons with more than 3 sides if it splits an edge,
    and then later only processes one of the adjacent faces. 
    X This happens on the 'man' input model, on the back of his left calf.
    X Write additional code that makes sure that every such face has been triangulated,
        even if it has no face line segments.

X I really should comment the typedefs at the bottom of Retriangulator.

X 'RUN two-triangles' has coincident vertices on the groundplane, and these seem
    to coincide with the points where the shadows of the two triangles intersect.
    Is it possible that I generate pairs of unique endpoint identifiers in these cases,
    when only a single endpoint identifier should be shared?
    X This doesn't seem to be the case. The code looks like intersecting
        critical line segments are being handled correctly, at least with respect
        to the unique endpoint identifiers.
    X The problematic vertices correspond to discontinuity mesh endpoints
        interior to the discontinuity mesh that look like they should be shared.
        Is it possible that I'm not assigning correct EndpointIdentifiers
        for these points in DiscontinuityMesher?
        X These look like critical line segments generated by VE events.
        X It's possible that I'm being bitten by the four
            EndpointIdentifier::createUniqueIdentifier calls that I recently
            added to Region.cpp.
        X I need some way of doing this without the createUniqueIdentifier calls,
            such that the same identifier is created for the shared vertex from
            both directions.
        X Maybe have WedgeIntersector::setVeEventWedge make its EdgePtr available,
            and then have LineSegmentCollection query it and somehow combine it
            with the EdgePtr derived from either of the endpoint identifiers in
            LineSegmentCollection::findVisibleLineSegment
            (queried via EndpointIdentifier::getEdgePtr).
            X Maybe add EndpointIdentifier::fromEdgePtrPair for this.
            X Assign this EndpointIdentifier instead of calling createUniqueIdentifier.
        X I think I can't just use two edges as unique identifiers. I can
            imagine scenarios were the same edge, projected from multiple vertices
            onto another common edge results in multiple projected vertices that
            would all have the same resulting identifier.
        X So, I guess I'd need an identifier that consisted of a vertex and two
            edges for the VE case. But for distant light sources, I really need
            two vertices and two edges, and the two vertices are referenced by
            index (or something else?), not by vertex pointer.
        X Also I need to figure out what needs to happen for the EV case, both
            for local and distant light sources. I need to visualize when these
            cases would occur. It's not immediately obvious.
    X How do I solve this problem?
        X In Region::computeDifference, rather than call
            EndpointIdentifier::createUniqueIdentifier, I need to come up with
            a new identifier that will be the same for the two line segment endpoints.
            X These endpoints will have the following in common:
                X The span's ID must come from and edge, and that edge must be
                    folded into the new ID.
                X The wedge that generated the Region must also have an edge (PQ)
                    which must be folded into the new ID.
                X The new ID must also reference vertices V and W of the edge.
                    X ID comparisons must find that if V == W then they match at least
                        one of the vertices of the other ID,
                        or both V and W are matched in the other ID.
                    X Along with V and W, each vertex needs an optional
                        light vertex index as well.
            X So here's what I do:
                X Add edge pair support to EndpointIdentifier.
                X Make a WedgeIdentifier that takes two vertices as input,
                    and two optional unsigned light vertex indices (set to ~0 by default).
                    X Should support an equality operator.
                    X Should support an inequality operator.
                    X Should support a comparison operator.
                X Make WedgeIdentifier a member variable of EndpointIdentifier
                    and write accessor functions.
                    X Add the WedgeIdentifier to the equality and comparision operators.
                X Add WedgeIntersector accessors to expose a WedgeIdentifier
                    created from its V and W and light vertex indices,
                    and set this WedgeIdentifier in the functions
                    like setVeEventWedge, as appropriate.
                X Have WedgeIntersector make its input EdgePtr available,
                    and also add a function to check if it was defined at all.
                X Make Region::computeDifference also take a WedgeIntersector
                    as an argument.
                X Where before, Region::computeDifference called
                    createUniqueIdentifier, have it create a new identifier
                    based on the old ID's edge pointer,
                    the WedgeIntersector's edge pointer, and the WedgeIntersector's
                    WedgeIdentifier.
                    X If the old ID has no edge pointer or the WedgeIntersector
                        has no edge pointer, call createUniqueIdentifier instead.
                X I tested this and it doesn't work!
                    X I made a few typos when I wrote the code.

- 'RUN cylinders' and 'RUN contact-shadow' appear to have coincident line segments.
    - When there's a contact shadow, the vertex that contacts the surface projects
        the vertices of the light source onto the ground plane as usual, but they're
        not spread out, and are all collapsed nearly to a point.
    X To deal with this, I'm pretty sure I have no choice but to add an epsilon test.
    - The epsilon test helped in the contact-shadow case, but I still see nearly coincident
        line segments/vertices in the cylinders and shadow-creep-bug case.

X Refactor Retriangulator::subdivideFaces. It's too large.
    X Create a new FaceSubdivider class.
    X Add a mMesh pointer to FaceSubdivider.
    X Move mFacePtrToOriginalFace to FaceSubdivider.
    X Move subdivideFaces to FaceSubdivider.
    X Split up subdivideFaces.

- Redo all the epsilon tests as described in the collision detection book.
    - Make a standard global comparison function, and ones for Vector2f/3f/4f.
    - Comment this function and describe how its use should be avoided.
    - Replace all the epsilon-based comparisons in the unit tests with these functions.
    - Use Vector3f::maxAbs to compute epsilon instead of Vector3f::length.

- FaceLineSegment edges that intersect the face's original perimeter shouldn't
    be discarded, but should split the face's edges.
    - Same for FaceLineSegment endpoints.
    - Is it possible that this is always happening in situations where the face's
        perimeter has already been subdivided, but for whatever reason,
        there's no correspondence of the FaceLineSegment endpoint with
        the subdivided edge point?

- 'RUN temple' complains that input line segments to the CDT intersect in debug mode.
    I can modify the code to reject edges that intersect with the polygon's
    exterior edges, and then it'll work.
    However, if I run it in optimized mode without rejecting those edges, it'll work,
    but then also if I examine the edges that had been rejected by the debug version,
    nothing will seem wrong with them.

- Maybe Retriangulator::addFaceLineSegmentToFace, in addition to checking
    for edges, should check for vertices.
    - FaceSubdivider::subdivideFace does actually call EndpointIdentifier::getVertexPtr.
        Is it possible that this snapping should happen before the FaceLineSegments
        are split against each other?
    - I modified FaceSubdivider to write out an SVG file when it fails in debug mode.
        - The output looks fine on the surface, but must have problems. Pinpoint
            exactly what is going wrong and work backwards from there.
        - It looks like part of the problem is triangles whose edges contact the
            surface of other triangles.
        - Maybe, within the wedge, I could handle differently the case when a line segment 
            endpoint lies on another line segment. I wouldn't split the line segment
            in that case, or I wouldn't change the EndpointIdentifier.

- Now I'm thinking that in FaceSubdivider::subdivideFace, right when I decide I should
    create a new vertex by calling Mesh::createVertex, I should first see if any
    of the mesh vertices (including the ones created by edge splitting) lie close to the
    position of the new vertex. If so, I should reuse that vertex rather than
    create a new one.
    - The distance check should rely on an epsilon test based on the values of
        each vertex.

- However, analyzing the failure, it looks like what's happening is that for occluder
    edge PQ, one of the triangle vertices receiving the shadow is one of the
    vertices of edge PQ. (It's not just nearly coincident, it's the same vertex).
    So, I should take a detailed look at WedgeIntersector and see if
    that case is being handled properly.

- It's possible the epsilon tests in WedgeIntersector::snapClippableEndpointToPQ and 
    snapClippableEndpointToV could be improved. See the code in the collision detection book.

- Maybe in WedgeIntersector::clipToVeWedge, instead of relying on snapClippableEndpointToPQ
    and its epsilon test, I should explicitly test if either of the input points 
    are P or Q, symbolically, or exactly.

X A fallback plan would be that Retriangulator, in addFaceLineSegmentToFace,
    would test of the line segment endpoints not already associated with edges lay within
    an epsilon of any of the exist face edges, and set themselves up to split those edges.
    First, however, there would be a test to see if the endpoints lay within a slightly
    larger epsilon of the face vertices. If so, the endpoints would be reassigned
    to those vertices.
    X This seems to have helped, but it causes other problems because now I'm
        left with coincident vertices that are treated as unique.

- Maybe Region::createProjectedDifferenceEndpointIdentifier shouldn't create a unique
    identifier if the points involved are within some epsilon of each other.
    That way, it would retain the edge association that we want.
    - I think I want to test if points are near each other, and if points are near
        other line segments. Or, at least, test if endpoints are near each other
        after the line segments are clipped against each other.
    - When vertices/edges of one object contact a face of another, I think this is
        a potential source of problems. Ideally, a single vertex with a single
        EndpointIdentifier should be created. If this doesn't happen, I'm guessing
        it could be easy to wind up with two nearly coincident vertices,
        and that perhaps this winds up creating some of the slivers I see on the groundplane.
       
- I tried to do some endpoint snapping of line segments within a line segment vector,
    and that didn't work.

- Maybe what I need to do is another pass to snap endpoints that aren't associated with
    any particular vertex or edge. I'd snap them to the endpoints that I knew were
    already associated with specific existing geometry, or with other endpoints 
    that were within an epsilon.

X I'm starting to doubt that this is going to work reliably, and I feel that I rushed 
    through it. Spend some time planning it all out again, using a simpler
    epsilon-based approach, and see how far I can get with that.
    X Last time, I rushed too fast and took steps that were too large. This time,
        break it down into tiny little pieces and test each one thoroughly.

X OK here's the new plan.
    X Design a new algorithm.
        X Determine what all of the special cases are ahead of time.
        X Figure out how to handle each of the special cases.
        X Break the algorithm down into as many small parts as possible that I can
            test in isolation.
    X Copy Retriangulator and FaceSubdivider to an 'old' directory.
    X Create a new stub Retriangulator class with the same API.
    X Write the new code.
    X Verify that it works.
    X Remove the 'old' directory.
    X Assuming I no longer rely on EndpointIdentifier, remove it everywhere.

- The inputs to Retrianguator are:
    - A mesh.
    - A collection of FaceLineSegments associated with mesh faces.

- Special cases:
    - The face might be nearly degenerate.
        - A vertex might be nearly coincident with another.
        - A vertex might be nearly coincident with an opposing edge.
    - While splitting existing mesh edges:
        - A mesh edge may be need to be split by FaceLineSegments associated
            with one or more adjacent faces.
        - We might try to split the edge at its endpoints.
        - We might try to split the edge beyond its endpoints.
        - A FaceLineSegment intersecting an edge might be nearly degenerate.
        - A FaceLineSegment intersecting an edge might be nearly colinear
            with the edge.
        - A FaceLineSegment might be colinear with the edge, and straddle
            one or more other newly introduced vertices along the edge.
        - A FaceLineSegment may intersect a face edge and protrude outside it
            far enough that an epsilon test of its endpoint lying near the edge
            would fail.
            - In this case, we'd like to test if the FaceLineSegment intersects
                the face edge at all, before testing if any of its endpoints
                intersect the face edge.
    - While splitting the face:
        - A FaceLineSegment intersecting the face might be nearly degenerate.
        - The endpoint of a FaceLineSegment may nearly intersect another FaceLineSegment
            along its edge.
        - A FaceLineSegment might be colinear with one of the edges of the Face.
        - The endpoints of two or more FaceLineSegments may be nearly coincident.
        - FaceLineSegments may be nearly colinear with each other.
            - A FaceLineSegment might lie on, and be a subset of, another FaceLineSegment.
            - Two or more FaceLineSegments may partially straddle each other.
            - Two or more FaceLineSegments may be coincident.
        - A FaceLineSegment might lie outside the face to which it is assigned.
    - Splitting the edges may result in a face that is no longer strictly convex.
        - Use PolygonTriangulator, instead of PointTriangulator, 
            to avoid creating slivers around the face perimeter in this case.

- The new algorithm:
    - Associate each FaceLineSegment with its corresponding face as they are submitted.
    - Loop over all faces that have associated FaceLineSegments.
        - If the face is degenerate, discard the face's FaceLineSegments.
            - A face is degenerate if any of its vertices are within an epsilon
                distance of the opposing edge, or the other vertices.
        - Loop over the face's FaceLineSegments.
            - If the two endpoints of the FaceLineSegment are within an epsilon
                distance of each other, discard the FaceLineSegment.
    - Split the mesh edges.
        - Loop over each face.
            - Loop the FaceLineSegments associated with the face.
                 - Loop over the endpoints of the FaceLineSegment.
                    - Find the nearest point on any of the face edges relative to the endpoint.
                    - If the point is within an epsilon distance to the nearest edge,
                        or is outside the face, then:
                        - If the nearest point is within an epsilon distance of any of the
                            face vertices, snap the nearest point to the nearest one.
                            - Otherwise, if there are any other points already recorded for
                                that edge within an epsilon distance of the point, snap the point
                                to that point.
                 - If the two endpoints are both detected to the close to the same edge,
                     discard the FaceLineSegment.
                     - Otherwise, record the (possibly adjusted) nearest points with the edges,
                         and snap the FaceLineSegment endpoints to that nearest point.
        - Loop over each edge that is known to need splitting.
            - Calculate 't' for each recorded point along the edge.
            - Sort the points along the edge by 't'.
            - Loop over the sorted points.
                - Assert that the value of 't' is not <= 0 or >= 1.
                - Split the edge at each point.
            - If the edge's adjacent faces have no associated FaceLineSegments,
                add them to the list, so they will be properly triangulated later
                after their edges are split.
    - Split the mesh faces.
        - Loop over each face.
            - Loop over the FaceLineSegments associated with the face.
                - Loop over all the other FaceLineSegments.
                    - If the endpoints of the FaceLineSegments are nearly coincident,
                        snap them together.
            - Loop over the FaceLineSegments associated with the face.
                - Loop over all the other FaceLineSegments.
                    - If the first FaceLineSegment's endpoints are coincident
                        with those of the second FaceLineSegment, discard 
                        the first FaceLineSegment.
                    - If the first FaceLineSegment's endpoints both lie
                        along the second FaceLineSegment, discard the first FaceLineSegment.
            - Loop over the FaceLineSegments associated with the face.
                - Loop over all the other FaceLineSegments.
                    - If the first FaceLineSegment has one endpoint along the length
                        of the other, and vice versa, then merge the two FaceLineSegments
                        into the second, and discard the first.
            - Loop over the FaceLineSegments associated with the face.
                - Loop over all the other FaceLineSegments.
                    - If the two FaceLineSegments intersect, but not at their endpoints,
                        record their intersection point as a split point along
                        both FaceLineSegments for later splitting.
                    - Otherwise, if one FaceLineSegment endpoint nearly intersects
                        the other, snap the endpoint to the other FaceLineSegment,
                        and record the intersection point on the second
                        FaceLineSegment for later splitting.
            - Loop over the FaceLineSegments associated with the face.
                - If the FaceLineSegment has any recorded split points,
                    - Compute the value of 't' for each split point.
                    - Sort the split points by 't'.
                    - Split the FaceLineSegment at each split point.
            - Compute the CDT of the polygon using PolygonTriangulator, 
                given the polygon perimeter and all of the FaceLineSegments.

- Think about this for a while longer.
    - Maybe the first step, before splitting edges or faces, should be to 
        find all groups of endpoints that are within an epsilon distance of one another,
        and snap them to their average location.
        - In the case of vertices near the original face vertices, we'd snap
            to the original face vertex.

- The new algorithm, version two:
    - Submit all endpoints to a class that snaps groups of endpoints all within
        some epsilon of each other.
        - The point merging class will need the ability to merge groups as it goes along,
            if they are discovered to be close together.
        - The last thing this class should do is snap all the endpoints in each group together.
            - The original vertices of the mesh should be used as the snapping points,
                rather than the average position, if they are involved in a group.
                - If multiple mesh vertices are involved in the same group,
                    the face is degenerate and should be skipped entirely.
    - Discard degenerate line segments.
        - Use FaceLineSegment::isDegenerate to test for this.
    - Merge nearly colinear line segments.
        - Use FaceLineSegment::mergeIfColinearAndIntersecting.
    - Discard line segments that are colinear with the face edges.
        - Use FaceLineSegment::liesOnEdge.
    - Split line segments where they are intersected by other line segments
        or line segment endpoints.
    - Split face edges where line segments or line segment endpoints intersect them.
    - Repeat all the steps above until no more line segments need to be split.
        - I'm concerned about the case where small point movements during
            line segment splitting create new situations in which line segments intersect,
            which the CDT would choke on.
    - Triangulate the face.

- In Retriangulator, I'm going to need a map of EdgePtr's to points along each edge
    that the edge should be split at.

- PointSnapper should consider these edge points as well, and snap them if necessary,
    so we can later discard them.

X I think it's a problem that I'm doing a lot of this computation in 3D space.
    I think this risks overlooking edges that, when projected to 2D, will actually intersect.
    It really should all be happening in 2D.
    X This is going to require a bunch of restructuring.

X Write the code that retriangulates the faces in a polygon mesh given
    a set of line segments on those faces as a separate library, so that there's a chance
    I could use it again in the future if I wind up writing CSG code.
    X Move FaceLineSegment to the separately library too.

X Get rid of EndpointIdentifier completely?
    X See if I can reenable the ifdef'd unit tests.
        X I was able to reenable all but two in LineSegmentCollectionTest.cpp
            Fix the tests that don't work.

X The new algorithm, version three:
    X For each face that has FaceLineSegments associated with it, 
        compute or keep track of:
        (In Retriangulator, create a vector of structures containing
            the following items for each face, assigning a temporary index attribute
            into the vector for each face.)
        X The two axes most orthogonal to the normal, and the third axis.
            (Call cgmath::GetPrimaryAxesMostOrthogonalToVector.)
        X An appropriate epsilon value based on the face vertices (in 2D).
        X A vector of FaceLineSegments.
        X A backpointer to the face.
    X For each edge adjacent to a face that has FaceLineSegments, 
        maintain a temporary index into a vector of structures containing:
        X A vector of 3D points along the edge to direct later splitting of the edge,
            with line segment pointers and endpoint indices, and a FacePtr,
            and a value of 't'. (I'm not sure if the FacePtr is really needed.)
            X Call this structure EdgePoint.
        X A backpointer to the edge.
        X An epsilon value based on the 3D endpoints of the edge.
    X For all faces:
        X If the face is degenerate (in 2D), discard all line segments.
            X A face is degenerate if it has a vertex that is within an epsilon
                distance of an opposing edge (in 2D).
    X Keep repeating the following until no new line segments are split:
        (By repeating, this handles the case where splitting edges results in 
        perturbed edges that induce additional snapping or splitting, ensuring that
        no intersecting edges are submitted to the constrained Delaunay triangulation code.)
        X For all edges:
            X Discard all EdgePoints computed on the previous step, because
                we're going to calculate them all over again.
        X For all faces:
            X Discard line segments whose endpoints lie nearly on the same
                face edge (in 2D).
                X I can't simply remove them from a RetriangulatorFace's
                    FaceLineSegmentVector, because that would invalidate
                    the FaceLineSegmentPointers of any RetriangulatorEdge's
                    EdgePoint that pointed at it.
                    X I need a mechanism so I can delete FaceLineSegments,
                        and at the same time, any EdgePoints that point at them.
                    X Make RetriangulatorEdge and RetriangulatorFace into actual classes.
                    X Make EdgePoint a class in a separate file.
                    X Change EdgePoint to reference the FaceLineSegment
                        via a RetriangulatorFace pointer and index.
                    X Write a RetriangulatorEdge function to delete 
                        a RetriangulatorEdgePoint referencing a FaceLineSegment.
                        X Copy the last element of the vector over the
                            deleted element.
                    X Write a RetriangulatorFace function to delete a FaceLineSegment,
                        and EdgePoints of all neighboring edges that reference
                        the FaceLineSegment.
            X Record pointers and indices to line segment endpoints, and faces,
                along face edges when they lie near or intersect them 
                and snap the endpoints to the face edges (in 3D).
                (Perform the proximity test in 2D, but record the 3D coordinate along the edge.)
                X This should never happen, but handle the case where a line segment
                    extends out through an edge beyond the range where the endpoint is
                    considered close to the edge.
        X For all edges:
            X Use PointSnapper to further group together points along edges.
                snapping them to face edge endpoints (mesh vertices), if necessary (in 3D).
                Move the associated line segment endpoints as well, so that they
                are snapped to the new averaged point positions.
        X For all faces:
            X Merge nearly colinear line segments (in 2D).
                X Handle the case when the endpoints of two line segments are both
                    coincident.
                X Handle the case when one line segment's endpoints both lie
                    along another.
                X Handle the case when two line segments mutually straddle each other.
                    (One endpoint of a line segment lies along another, and vice versa.)
                X Handle the case when two line segments share one endpoint,
                    and are approximately colinear.
            X Snap together nearly coincident line segment endpoints (in 2D).
                X Snap them to points added along edges if they're nearly coincident (in 2D).
                X Snap them to original face vertices if they're nearly coincident (in 2D).
                    (Choose the closest of all edge points and face vertices.)
                X The snapping should occur in 2D, but the full 3D coordinate of each
                    snapped endpoint should be calculated.
            X Split all intersecting line segments where their edges intersect
                and also when an endpoint intersects along another line segment (in 2D).
                X Give edge/endpoint intersections priority over edge/edge intersections.
                X Split all edges at 'T' intersections first. 
                    Write new code for this.
                X Then split edges at 'X' intersections second.
                    Do this using LineSetIntersector.
            X Discard nearly degenerate line segments (in 2D).
    X Split all the mesh edges.
        X Compute 't' for each point, sort, and split.
        X Remove all temporary mesh element attributes assigned earlier, just before
            each edge is split.
    X Retriangulate all the mesh faces.
        X This needs more elaboration, but I already have code for this
            in rfm_discmesh/old.
            X Interpolate vertex and face vertex attributes.
        X If the face has no FaceLineSegments, leave it alone. However, it still has to
            be triangulated if it has more than three vertices at this point,
            due to edge splitting.
        X Even if a face has no FaceLineSegments, retriangulator it anyway if it
            has more then three edges because some of them were split earlier.
            X Make sure we consider every face in the mesh for splitting.
        X Remove all temporary mesh element attributes assigned earlier,
            just before each face is split and our FacePtr becomes invalidated.
    X 'RUN cylinders' fails. I think there are issues where I delete FaceLineSegments
        from faces, which causes indices to become invalidated.
    X Now all the test cases get caught in an infinite loop
        because each pass through the loop splits more edges.
        X Line merging was undoing the line segment splitting.
    X Now it crashes because of bad CDT input (intersecting line segments).
    X Now it crashes because of bad CDT input (degenerate edges).
        X Maybe the problem is the CDT input line segments generated
            by the face perimeter edges.
    X Now it fails trying to access an invalid FaceLineSegment index.
        X This is because in Retriangulate::splitMeshEdges, the call to addTriangulatorFace
            grows the vector of RetriangulatorFaces, potentially
            invalidating all the RetriangulatorFace pointers referenced
            by EdgePoints, which causes later RetriangulatorEdge::splitMeshEdge calls to fail.
    X Now it crashes because I think I forgot to pass the polygon vertices to the CDT.
    X Make sure all tests run.
        X 'RUN well' fails in debug mode.
        X 'RUN temple' fails in debug mode.
        X 'RUN man' fails in debug mode.
        X 'RUN waffle' loops forever or runs for a long time in debug mode.
    X RUN 'pile-of-boxes' seems to be missing edges on the upper right part of the shadow
        from the light's point of view, near the edge of the groundplane triangle.
        The edge that should be casting this shadow edge appears coplanar with
        a light source edge. 
        X Output the original discontinuity line segments and see if
            the edges are present. That'll tell me if the retriangulator code
            is stripping them out or not.
            X Yes, it's the retriangulator code.
        X The problem appears to be in RetriangulatorFace::createEdgePoints,
            where it calls deleteFaceLineSegmentAndReferencingEdgePoints.
            If I comment that out, the line segments don't disappear.
            However, it creates an extra edge along the original triangle edge,
            which I do not one because it results in slivers.
        X Disabling RetriangulatorFace::mergeNearlyColinearFaceLineSegments also makes
            the problem go away, which makes me wonder if the two line segments
            adjacent to the face edge are erroneously merged with the line segment
            that is coincident with the face edge, and then the resulting line segment
            is deleted.
    X Remove meshretri/old.

X Fix all the ifdef'd functions in src/mesh to be appropriately epsilon-based.
    X Write unit tests for all of these.

X Ctrl+C,J fails in some of the functions in mesh/FaceOperations.cpp.

- If Ctrl+C,J is used on a CPPUNIT_TEST line whose function name does not being with "test",
    It seems to get stuck in an infinite loop.

X If I use Ctrl+C,J on getRetriangulatorFaceFromMeshFace in Retriangulator.h, it fails.

X It'd be great if doing a build in an executable directory would automaticaly
    build all the libraries that the executable was dependent on,
    rather than just that local directory.
    X It looks like it does this already.

X 'RUN cylinders' is crashing. Why?
    X Point::position is called, and it fails trying to access an EdgePoint.
    X The EdgePoint's FaceLineSegment index is out of range when
        passed to RetriangulatorFace::faceLineSegment.

X Write code to compute direct illumination of the mesh.
    X Do this as part of rfm_discmesh, not in a separate library.
    X Loop over each vertex and compute the colors of the adjacent vertices.
        X Compute the light contribution from all emissive polygons.
        X Compute the light contribution from all distant lights.
    X First, build a vector of all emissive faces.
    X To light a vertex, for each light source face, 
        X Loop over all the edges of the occluder faces in the scene.
            X Create VE wedges based on these edges and the vertex we're lighting.
            X Don't bother with edges that are on the back side of all of the
                faces adjacent to the vertex being lit.
            X Trace the wedge toward the light source.
                X Instead of using DiscontinuityMesher::traceWedge, write a new function,
                    traceBackprojectionWedge, that tests all occluder polygons in the scene,
                    plus the light source polygon.
                    X Write this in such a way that it can be used both for
                        emissive faces and for distant lights.
                        X The function will take the light source face as input.
                            For distant lights, I'll maintain a special temporary face
                            that I'll move around in space to represent each light source
                            face I'm considering. The existing rfm_discmesh and meshretri
                            code is deeply dependent on this.
                            X See if I can get away with a single multisided face for
                                distant light sources, rather than chopping them up
                                into triangles first. This would reduce the number of 
                                wedges that needed to be traced.
                                X This doesn't look possible because 
                                    WedgeIntersector::testTriangle really wants a triangle.
                    X Test the light source face first. If the wedge does not intersect it,
                        don't bother looping over all the rest of faces in the scene,
                        because that would be a huge waste of time.
                    X Loop over the resulting line segments, looking for those line segments
                        that lie on the light source face.
                        X Add the light source face line segments to a special
                            instance of Retriangulator used only for backprojection.
            X Trace VE wedges from the vertex through all adjacent faces, to see if they
                intersect the light source, to handle horizon effects correctly.
                X If only half the light source is visible over the horizon from a vertex,
                    only that portion of the light source should wind up contributing
                    illumination to it.
                    << I'm not sure if this is exactly the right thing to do. >>
        X Then call Retriangulator, but instead of Retriangulator::retriangulate,
            write a new function, Retriangulator::retriangulateBackprojectionFace,
            that retriangulates only a single face, and returns
            a vector of triangles (represented as 3D point triplets) 
            that the face has been subdivided into, without actually retriangulating the mesh.
            X If no line segments were stored on the light source face, don't bother
                calling Retriangulator::retriangulateBackprojectionFace at all.
                This will be the most common case.
        X Make sure all that mBackprojectionRetriangulator and any other temporary objects
            we'll reuse again has been completely reset.
        X For each triangle that the light source face was split into, compute
            its lighting contribution.
            X << The following steps are flawed. Each collection of face vertices
                with the same normal should wind up with the same shading. >>
                X << This is not strictly true for vertices with D0 discontinuity.
                    In that case, neighboring face vertices could be illuminated
                    differenently. >>
                X << So the question is, how do I handle D0 discontinuity cases correctly,
                    while still shading standard case vertices correctly?
                    Could I detect when a vertex must have a D0 discontinuity and
                    then treat it differently? >>
            X Fire a ray from the centroid of the subface back to the point being lit
                to see if that portion of the backprojection is occluded.
            X Compute the sets of face vertices that have unique normals,
                and which share the same visibility from the light subface, 
                as determined by firing a ray from the light subface centroid
                to a point nudged by a small value toward the lit face centroid.
                Face vertices so occluded should have no light contribution.
                X I might not have to bother with this if the geometric normals
                    of all faces adjacent to the vertex with this shared face vertex normal
                    point toward the light source.
            X For all sets of adjacent face vertices with unique normals,
                X For all non-occluded light source subfaces, compute the form factor.
                    X See game/src/mesh_radiosity/main.cc, ComputeFormFactor.
                    X There might be more appropriate versions of this in some of the papers.
                        X See 'High Fidelity Radiosity Rendering at Interactive Rates',
                            section 6.1.
                        X 'Exact Illumination in Polygonal Environments using Vertex Tracing'
                            section 2 also looks useful.
                    X Remember that distant light sources are effectively infinitely far away,
                        and so their intensity should not fall off with distance.
                X Compute the illumination for the face vertex, taking the light form factor
                    and existing material and vertex colors into account.
                    X Later, we'd take the local texture color into account as well,
                        so sketch this code out.
                X Update the contributed illumination to the face vertices
                    that share this normal, but store it in a temporary illumination attribute.
                    X Later I might want to keep this information around,
                        so I can store both the shadowed and unshadowed colors of the mesh.
                        The shadowed color would be all the indirect illumination,
                        but no direct illumination.
    X Make sure I've deleted the temporary light face.
    X Copy all temporary illumination attributes for face vertices back to the
        vertex color attribute.
    X Write AABB-based code to accelerate ray shooting.
        X Put this in a separate library so I can reuse it during later global 
            illumination computation.
    X Write AABB-based code to accelerate tracing wedges.

- If later I decide that I need to handle EEE events, it looks like this is covered
    in the paper 'A Fast Shadow Algorithm or Area Light Sources Using Backprojection',
    section 3.3. It looks like they are able to identify the EEE events efficiently by
    tagging certain EV events as they are generated.

- If I tagged edges resulting from critical line segments in the scene as
    interior extremal and exterior extremal, could I use this information later on
    to help me efficiently identify vertices that could be trivially illuminated
    because they are outside the penumbra or inside the umbra, perhaps by flood-filling
    regions of connected mesh faces?

X The form factors around the penumbra in some places appear to be infinite.
    I'm guessing this is because the normals are zero, because if I don't use the
    face vertex normals, but use the geometric normals of the faces
    in the computation in DiscontinuityMesher::lightFaceVerticesAdjacentToVertex,
    then everything looks OK. I suspect that the mesh face vertex attribute code
    isn't working right when edges are split.
    X Prove that this is what is really happening.
        X In DiscontinuityMesher::lightFaceVerticesAdjacentToVertex, when
            I call mesh::GetFaceVertexNormal, it's returning NaN values
            for some of the face vertices. Where are these coming from?
    X Fix it.

X 'RUN cylinders' has a polygon vertex in the foreground that is dark, but which
       should be illuminated.

** Subdivide the mesh in areas where there are large errors in the computed lighting
    at edge midpoints as compared to interpolated values.
    - I don't want to do this in a way that precludes using an AABB tree to
        speed up ray intersection testing.
    - Here's how it could work:
        - Loop over all edges and mark the ones that need to be subdivided by
            storing the new shaded color value for the future midpoint.
            - Restrict this based on an error tolerance and a minimum edge length.
        - Subdivide all the edges that have been marked.
        - Retriangulate all the faces which are now no longer triangles.
        - Recompute the AABB tree based on the new mesh.
        - Keep repeating this until no more edges are split.
            - Don't reconsider edges that have already been considered before.
                (These should also be marked.)
        - This should generate a relatively nice regular triangulation with proper anchoring.
    - I'm going to want to use all this mesh AABB tree ray intersection 
        and subdivision stuff later on when I compute first bounce lighting, 
        and with the photon maps, so put it in a separate library.
    - This has to take into account the fact that all lighting calculations are performed
        in linear space, but the graphics hardware will do the interpolation
        in gamma space.

** Make sure that all of the intensity calculations are performed in linear space.
    - A nice way to do this would be to assume that all RFM file values are linear,
        and modify obj2rfm and rfm2wrl to do the conversions.
    - If I do this, then when I'm determining when to subdivide edges,
        I have to assume that the graphics hardware linearly interpolates vertex colors
        in gamma space, and perform the same calculation in my error comparison.
        - Isn't this going to cause an explosion of subdivision, because the interpolated
            midpoints are always going to have a lot of error, when comparing
            gamma to linear?
    - One crazy way I could do this is to do everything in linear space,
        but when dealing with backprojections, somehow consider the visible
        portion of the light source in gamma space. This would not be accurate,
        but the results might look better.
        - I'm not sure if this is possible or makes any sense.

- Write unit tests for GetEpsilonFromFace and GetEpsilonFromEdge and 
    call it in the places where I've already computed an epsilon by hand.

X Where D0 discontinuties occur, would it help to ensure that the vertex inserted into
    the target face has exactly the same position as the polygon vertex casting the shadow?
    I'm wondering if there is a problem now where slightly offset points from
    these events are causing shading artifacts.
    For example, here's the vertex that was causing me problems:
        Point at base of cylinder:
            -0.216506 0 1.14278
        Point on groundplane:
            -0.215707 0 1.14199
        The distance between these two points is 0.001124.
    X: Cylinder point is to the left of the groundplane point.
    Z: Cylinder point is in front of groundplane point.
    So, it looks like the cylinder is blocking the groundplane point from rays/wedges
    trying to reach the light source.
    X Verify that this is what is causing the problem via epsilon fudging.
    X If this is really what is going on, try to fix the code that creates the vertices
        in the first place so the shadow vertices are coincident with the
        shadow caster vertices.
        X Maybe in DiscontinuityMesher::traceWedge, before calling
            mRetriangulator.addFaceLineSegmentToFace, snap the line segment endpoints
            to the occluder edge or vertex if they're within some epsilon distance of it.
            X This didn't work so well. Setting the tolerance high enough to fix
                the problem caused artifacts elsewhere.
    - I might have to write rfm_clean in order to condition the input data so that
        it won't have this problem.
    X Before writing rfm_clean, be sure that it would really work. Write code to
        move the one problematic vertex in the retriangulation output to the
        position that I really want it to be in, and make sure that works first.
        X This didn't work either.
    X Another approach would be to preprocess the mesh immediately before shading it,
        and snapping together vertices that are nearly coincident.
        I could limit this to only moving vertices that I had created
        via retriangulation, and snapping them to existing mesh vertices.
        I wouldn't snap newly created vertices to each other.
        X To test this quickly, do it without an AABB hierarchy.
            X Before retriangulating the mesh, tag all the original vertices with
               a temporary attribute.
            X After retriangulating the mesh, do a lame O(n^2) pass (for now),
               snapping the newly created vertices to original vertices.
        X This seemed to work.

- Put more comments in the header files for DiscontinuityMesher and MeshShader.

X 'RUN contact-shadow' has light leaks.

X 'RUN well' has light leaks.

X 'RUN wall' still has nasty artifacts.

X 'RUN cylinders' has a grazing edge artifact on a cylinder on the right side of the scene,
    as seen from the light source.
    X I think this is because the two triangles that make up this face of the cylinder
        each wind up with "lonely edges" because of the sharp grazing angle and numerical
        instability.
        X Could I detect lonely edges and extend them at their endpoints until they run
            into other edges or the edges of the face?
        X Also, look more closely at the code that generated these line segments
            in the first place and see if I can make it more tolerant of
            precision issues.
    X I'm pretty sure this is because the face that the wedge is cast onto creates
        a line segment in wedge space that is almost exactly pointing back at 'V'.
        X I wonder if I could resolve this problem by sprinkling more doubles
            in functions like LineSegmentCollection::findVisibleLineSegments,
            or in Region.h.
            X Also perhaps LineSegment::Intersection::mT.
        X Before randomly changing anything, track down exactly where in the code
            these endpoints are being generated.
            X The line segments are initially created by WedgeIntersector::testTriangle.
        X Oh now I suspect the problem is because faces adjacent to the faces that
            wind up with degenerate line segments are also putting line segments in
            the wedge, and they're causing the line segment intersection/sorting code
            to truncate line segments.
            X What I should do is dump out an SVG file of the wedge contents
                for this problematic wedge, and then try to fix the problem
                while looking at the SVG output.
        X I'm pretty sure the core of the problem is in 
            LineSegmentCollection::findVisibleLineSegments, because there are a lot of
            transformations too and from different spaces, that might be
            susceptible to floating point roundoff error.
            X Is it possible I could special case the situation where an edge
                is known to not be occluded at all, and then not bothering to
                perform all the transformations which lose precision?
            X Could I reformulate this function completely so it simply doesn't
                have this problem?
            X Draw some pictures to help figure this out.
            X I'm particularly suspicious of the calls to projectEdgePQPointOntoLineSegment,
                which call GetClosestPointOnLines. That function uses doubles
                internally somewhat, but not entirely.
                X I rigged up this function with more doubles, and it made a big improvement.
                    X The out-1.svg case was improved, but the line segment is still
                        missing in out-0.svg.
                        X Consequently, this didn't actually fix the shading artifact.
                    X Decide what to do with this function. Should I go ahead
                        and create a whole set of Vector3d's and everything else?
            X Now, why isn't the second line segment showing up?
            X I think I can imagine an arrangement of vertex normals on an approximated
                curved surface whereby the normals are facing toward the light source,
                but the adjacent face's geometric normal is facing away from the light source,
                and which therefore would not wind up with line segments
                projected onto it.
                X If this is the situation I've encountered, it's not going to work
                    even without floating point error.
                X Maybe I should use the approach used to correct for this situation
                    in stencil shadows, which is to bend certain normals away
                    from the light source.
                    X Before trying to implement this, write test code
                        to detect what I think would be problematic faces
                        in the cylinder test and highlight them in red.
                        X First test marking all faces with X < 0 vertices in red.
                        X Mark all faces whose geometric normal points away from
                            at least one emissive face vertex when viewed
                            from any of the face vertices,
                            but which have at least one face vertex normal that
                            points toward any vertex of the emissive face,
                            when viewed from the vertex with the face vertex normal 
                            in question.
                    X What would the test above do in a scene that had two light sources,
                        illuminating the scene from 90 degrees apart? 
                        X I'm concerned that this trick only applies 
                            to individual light sources, and that in the 90 degree
                            dual light source case, suddenly half of the normals in
                            the scene will be considered problems and will
                            be bent toward one or more of the light sources.
                        X Could I apply it separately to each emissive face, in isolation?
                        X What would it mean to bend normals toward multiple light sources
                            at once?
                        X Could I bend normals toward a given emissive face
                            only when calculating the shading involving that face?
                        X I think this might work for multiple light sources, and or
                            treating the faces of light sources individually.
                            X The lighting for each face, individually, would look smooth,
                                so adding these together should look smooth too.
                        X Solve this problem by not bothering to illuminate face vertices
                            that share normals with another neighboring face that is
                            geometrically backfacing with respect to the light source face, or
                            any face vertices of faces that are backfacing.
                            X Do this test in MeshShader::shadeFaceVerticesAdjacentToVertex
                                within the AdjacentFaceIterator loop.
                            X Write faceIsBackfacing, which takes a FacePtr and 
                                a (light source) Triangle as input.
                            X Write faceVertexSharesNormalWithAdjacentBackfacingFace, which takes
                                a FacePtr, a VertexPtr, and a (light source) Triangle as input.
                            X If either of these is true with in the AdjacentFaceIterator loop,
                                then 'continue'.

X 'RUN pile-of-boxes' has some funny artifacts on the left edge of the shadow,
    as seen from the light source.

X 'RUN pile-of-boxes' has a light leak under the top box.

X Use the actual emissive face intensity.

X Shade emissive faces with their emissive intensity, rather than
    leaving them black.

X Take the existing face vertex or face colors into account
    when shading the vertices.
    X I also have to take into account material colors.
    - Later I'll also want to sample the texture map.

X Don't forget about shading with distant light sources. See notes above.

X Could the shading code in DiscontinuityMesher be broken out into a separate class?
    DiscontinuityMesher is getting too large.
    X Split out MaterialVector as a member variable of a new class, MaterialTable.
    X Add these functions to MaterialTable:
        X (public) initialize
    X Move these functions into MaterialTable:
        X buildMaterialVector
        X getEmissiveFaceIntensity
        X getFaceVertexDiffuseColor
    X Create a new class, MeshShader.
    X Add these new functions:
        X (public) setMesh
        X (public) setMaterialTable
    X Move these member variables and initialize them in MeshShader::setMesh.
        X mIlluminatedColor3fAttributeKey
    X Copy these member variables and initialize them in MeshShader::setMesh.
        X mMaterialIndexAttributeKey
        X mColor3fAttributeKey
    X Add these member variables:
        X mRetriangulator
    X Move these functions into MeshShader:
        X (public) shadeMeshVertices
        X initializeFaceVertexColors
        X shadeEmissiveFaces
        X createEmissiveFaceVector
        X copyIlluminatedVertexColorsToStandardVertexColors
        X shadeMeshVertex
        X shadeMeshVertexWithEmissiveFace
        X traceBackprojectionWedge
        X shadeFaceVerticesAdjacentToVertex
        X rayIntersectsMesh
        X computePointToPolygonFormFactor

X Move InterpolateVector3f from PointOperations.cpp to Vector3fOperations.cpp,
    and do the same for InterpolateVector2f.

X Rename functions like LineSegment::aboveOccluder to isAboveOccluder so they read better
    where they're used. (Change setAboveOccluder to setIsAboveOccluder, etc.)

X Write unit tests for Vector2d, Vector3d (copy these from Vector2f, Vector3f).

X Work backwards through changes made on 2009-06-10 after 20:24 to see if the change
    I made then introduced the side artifact on the rear center cylinder,
    and try to back it out.
    X The artifact was introduced with revision 2079 of file
        src/cgmath/LineOperations.cpp.

X Define TOLERANCE in cgmath/Tolerance.h,cpp rather than declaring it everywhere.

X Fix the D0 discontinuity problems.
    X 'RUN contact-shadow' has an incorrectly shaded D0 discontinuity point.
    X The vertex with the problem is:
        -0.5 0 -0.5
    X The face with the problem is:
        -0.5 0 -0.5
        -1.10918 0 -0.224295
        0.164813 0 1.10669
    X The face that should be shadowing this vertex:
        -0.5 0 -0.5
        -0.5 1 -0.5
        0.5 1 -0.5
      or:
        -0.5 0 -0.5
        0.5 0 -0.5
        0.5 1 -0.5

X Back out the change where I started using GetPrimaryAxesMostOrthogonalToVector
    because that doesn't match the logic in the book.

X Comment RayIntersectsFace to make it clear that it doesn't handle
    concave faces, and add an assert for that case.

X 'RUN pile-of-boxes' has an incorrect dark vertex in the foreground.
    X I disabled the vertex nudging code entirely, and the vertex is still dark.
        This implies it is being considered occluded for other reasons.
    X Disabling the faceVertexSharesNormalWithAdjacentBackfacingFace call 
        makes this dark vertex go away.
        X This doesn't make any sense, because the vertex in question
            only has frontfacing vertices adjacent to it.
        X Could one of the adjacent vertices be degenerate?
        X One of the adjacent faces was degenerate.

X 'RUN pile-of-boxes' has a dim light leak on the right side, in one of the shadows,
    and also on the left side.
    X It looks like there's an edge that extends under a box, and the near end of the
        edge is illuminated when it should be shadowed.

X 'RUN shadow-creep-bug' has improperly illuminated face vertices in the shadow
    on the backside of the face that contacts the groundplane.
    X This can be fixed by increasing the nudge distance even more.
    X I think the problem here is that the nudging direction is closely aligned
        with the surface of the polygon that the ray hit test is later performed against,
        and so the ray doesn't intersect it.
    X This might be interacting with the near epsilon test on the ray.
    X I need a more robust solution for determining the nudge distance.
    X For this really to work, I probably need a fully connected mesh as input.

X Flip the boolean return value result of:
    X AabbTree::applyBoundingBoxToIntersection
    X AabbTree::applyToTriangleVectorListener
    X AabbTree::applyToTetrahedronIntersection
    X These should all stop processing when the listener returns true instead of false
        as it currently does.
        X This will be consistent with the behavior of occludesRaySegment,
            and fix up awkward logic in MeshShaderOcclusionTester.
    X Correct for the changes above in:
        X mesh::FaceIntersector
        X mesh::EdgeIntersector
        X MeshShader
        X MeshShaderOcclusionTester

X The rear base vertices of the front pillars of the temple wind up disconnected 
    from the groundplane.
    X Check if they're in this position as originally modeled.
    X They're modeled that way!

X Figure out why the polygons in front of the temple are discolored. I'm
    guessing this is because occasionally when the backprojection to a
    light source triangle is calculated, it'll be erroneously considered
    in shadow.
    X Track down what's going on with this vertex:
        -0.699271, 0, -1.20238
        - I think the ray to the light source triangle was failing the epsilon test.
    X Here's another:
        -0.780229, 0, -0.7
    X The problem was floating point error. Very small form factors were being
        multiplied by very large emissive face intensities.
        I converted all the form factor computation over to doubles
        and now it looks great.

X There's an incorrectly illuminated polygon on the left side of the temple.
    X The bright end of one of the edges isn't being marked as a D0 discontinuity.
    X I marked the FaceLineSegment endpoints that are being set to D0 when
        they are passed to meshretri::Retriangulator, and the endpoints
        are being set correctly on the way in. Somehow they're losing this
        indication somewhere in the meshretri library.
        X The SVG file shows that thre are overlapping FaceLineSegments in this case.
        X I verified that these are merged by MergeFaceLineSegmentsIfColinearAndIntersecting2f
            in the first case (0--1, 0--1) in that function,
            and that the D0 discontinuity flags remain set on both ends
            of the resulting line segment.
        X These two points are within 0.1 units to the endpoints of the line segment.
            cgmath::Vector3f x0(-0.529081, 0.002, -1.34264); 
            cgmath::Vector3f x1(-0.222172, 0.002, -1.34264);
        X Maybe this is one of those cases where I encounter the same vertex
            twice, and I should be marking it D0 the second time it's visited,
            but I currently neglect to do that.
            X Stream output I added to FaceSplitter.cpp strongly suggests
                that this is the case.

X Optimize face vertex shading by detecting the case when a vertex is adjacent to
    a D0 discontinuity, and only shading the adjacent face vertices that share
    normals independently in that case.
    X Write code to mark vertices with red boxes for debugging.
        X Create a meshprim library for creating geometric primitives.
    X Figure out how to identify the D0 discontinuity vertices.
        X I added code to DiscontinuityMesher::traceWedge to mark line segment endpoints
            that are coincident with the wedge edge endpoints, and this works pretty
            well except that it doesn't correctly handle the case
            of 'RUN shadow-creep-bug'.
            X Figure out how to handle this case correctly.
                X Maybe instead of flagging vertices that are at the endpointts
                    of WedgeIntersector edges, flag all vertices that
                    lie along the WedgeIntersector edge.
                X Also only do this marking of edges in the VE edge case.
                X Also, in meshretri, when two line segments intersect and their endpoints
                    are both D0 discontinuities, make sure that the vertex
                    created by their intersection is also marked as a D0 discontinuity.
            - Another possibility is to punt on this case,
                because it is not a manifold surface, and maybe I just 
                won't handle that.
    X When I know an endpoint is a D0 vertex, flag this in 
        the meshretri::FaceLineSegment. 
        X Add FaceLineSegment::setIsDegreeZeroDiscontinuity, isDegreeZeroDiscontinuity.
        X In RetriangulatorFace::splitFaceLineSegment, when a line segment is split,
            if its endpoints are D0 discontinuities, make sure that all the endpoints
                of the resulting line segments are as well.
        X In FaceSplitter::createEdges, pass this value to addPointFromVector3f.
        X In addPointFromVector3f, if the point is a D0 discontinuity,
            set a boolean attribute of the newly created vertex.
            X I modified the code to handle this case and it marks some vertices 
                in red that I don't want it to mark in red.
                X For example, in the cylinders test, the vertex at:
                    -1.92256, 0, 0.0101057
                X Figure out where in the code this vertex is being marked and why.
                X Clue: Disabling RetriangulatorFace::mergeNearlyColinearFaceLineSegments made
                    some, but not all, of the superfluous points go away in the cylinder case.
                    X It doesn't affect the shadow-creep-bug case at all.
                X In the shadow-creep-bug test, the bad vertex is at:
                    -1.06355, 0, 0.806741
                X I rigged up the FaceLineSegment accessor functions to fail when
                    this point is either marked as D0 discontinuous, or a D0 discontinuous
                    point is moved to this location, but it never seems to happen.
                    X How is this vertex getting created?
                    X RetriangulatorFace::splitFaceLineSegment wasn't setting
                        FaceLineSegment::setIsDegreeZeroDiscontinuity correctly.
            X This still happens on one point in the cylinders test because
                merging of face line segments messes up the D0 discontinuity of the endpoints.
            X I don't yet handle the case in the four-boxes test where there is
                an overhang. 
                X How is this case defined? I thought I was already marking as 
                    D0 continuous points that lay along a WedgeIntersector edge.
                X Oh, it's possible this is one of the cases where the D0 FaceLineSegment
                    endpoint lies along an existing face edge.
                    X These vertices are created by the mesh::SplitEdge call 
                        in RetriangulatorEdge.cpp.
                X I still am not handling the case of D0 FaceLineSegment endpoints
                    that coincide with existing mesh vertices. These vertices
                    are not being marked as D0 continuous.
                    X Create a test case that demonstrates this problem first
                        before trying to fix it, so I can prove to myself
                        that it is fixed.
                        - contact-shadow-d0-coincident
                    X Perhaps in FaceSplitter::createPolygonFromFaceVertices after each
                        vertex is created, I could check if it is coincident
                        with a face line segment endpoint that is D0 discontinuous.
            X If the vertex already exists, and the vertex is D0 discontinuous,
                set the boolean attribute for the existing vertex just in case.
                X findPoint will have to be updated to optionally return a VertexPtr
                    via a third argument.
                X This isn't easy to do with the current code.
                X We're not going to bother with this until it becomes a problem.
                    X It became a problem. It turned out to be easy to fix.
    X Modify the shading code to only do the extra work and ray firing
        for the D0 discontinuity vertices.
        X Do a before/after timing test.
            X Optimized build, waffle test, before:
                X 176.4 seconds
                X 176.5 seconds
                X 178.3 seconds (mean)
                X 178.6 seconds
                X 179.3 seconds
            X After:
                X 173.9 seconds
                X 173.9 seconds 
                X 173.9 seconds (mean)
                X 173.9 seconds
                X 177.2 seconds
        X In MeshShader::shadeFaceVerticesAdjacentToVertex,
            test for the vertex attribute set earlier, and only if it's set
            do the nudging and call rayIntersectsMesh.
            X When a vertex has the attribute set, mark it with a red box.

X Accelerate shading with an AABB hierarchy.
    X Port AabbTree.h and AabbTreeNode.h over from the game/src/math.
    X Write a unit test.
    X Change AabbTree::applyCallbackToBoundingBox so that it uses
        a listener class instead of a callback.
    X Change AabbTree::occludesRaySegment to use a listener instead of a callback.
    X Add cgmath::BoundingBox2f,3f support to mesh::AttributePossessor.
    X Add cgmath::BoundingBox2f,3f support to the RFM file format.
    X Write mesh::RayIntersector.
        X Add setMesh.
        X Add initialize.
            X Should calculate the bounding boxes of all faces and
                store them as temporary attributes.
            X Should build the AABB tree.
        X Add occludesRaySegment.
            X Should take an origin and direction as input.
            X Output should be a boolean value.
            X Only return true if the ray is occluded. Don't bother
                determining which face is intersected first, as this probably
                requires more computation.
    X Try to change some ints in AabbTree to size_t and get rid of the int-casting.
    X Hook RayIntersector up to rfm_discmesh.
        X Oops, I need to be able to ignore certain faces. Derive a class
            from RayIntersector to perform the additional tests.
    X Figure out some way of making RayIntersector work with wedge tracing.
        X This would be based on triangle-box intersections,
            with two triangles for the EV case.
        X In cgmath/BoundingBox3fOperations.h, add BoundingBox3fIntersectsPlane.
            X Write unit tests.
        X In cgmath/BoundingBox3fOperations.h, add BoundingBox3fIntersectsTriangle.
            X Write unit tests.
        X Add RayIntersector/AabbTree code to support BoundingBox3fIntersectsTriangle.
            X Add a function to test for the intersection of N triangles.
            X Write unit tests.
        X If I perform an intersection test against the two triangles 
            of an EV wedge separately, it's likely I'll wind up visiting some faces twice.
            This would be bad, so I probably need an AabbTree function that takes
            a full EV wedge description as an argument, perhaps as a triangle pair.
        X What about distant light EE wedges that are really rectangles?
            I could describe these as a triangle pair as well (the union of which
            forms a quadrilateral)
        X Finish hooking this up.
    X MeshShader::shadeMeshVertexWithEmissiveFace needs an AABB function that
        returns all objects that intersect a prism-like volume,
        or a bounding box that is not axis-aligned.
        X Figure out what kind of volume to use for the intersection test.
        X Write the intersection code.
        X I should reorganize the code to do the plane tests as it goes along,
            rather than accumulate them in a vector.
        X I forgot about the set of planes created by sweeping the AABB over
            the edges of the tetrahedron.
            X This third case is to sweep the edges of the AABB over the edges
                of the tetrahedron.
        X Make a unit test that would have failed for the old version
            without code for the third case, but that now passes.
            X The final unit test ifdef'd out in BoundingBox3fOperationsTest.cpp
                fails, even though I am pretty sure it should pass.
        X Hook it up to AabbTree.
        X Rename mesh::Intersector to FaceIntersector so it doesn't clash with EdgeIntersector.
        X Write mesh::EdgeIntersector.
        X Hook up cgmath::AabbTree::applyToTetrahedronIntersection to mesh::EdgeIntersector.
        X Hook it up to MeshShader.
        X Timing test before the optimization:
            obj2rfm.debug test/models/waffle.obj /var/tmp/rfm_discmesh.temp.rfm --reset-normals
            time rfm_discmesh /var/tmp/rfm_discmesh.temp.rfm /var/tmp/out.rfm
            X Timing tests before optimization:
                281.747u 1.727s 4:43.60 99.9%   0+0k 0+2io 0pf+0w
                280.988u 1.283s 4:42.57 99.8%   0+0k 0+3io 0pf+0w
                281.380u 1.697s 4:43.36 99.8%   0+0k 0+3io 0pf+0w
                281.034u 1.213s 4:42.45 99.9%   0+0k 0+3io 0pf+0w
                281.477u 1.613s 4:43.24 99.9%   0+0k 0+3io 0pf+0w
            X After optimization:
                (full tetrahedron test)
                325.285u 2.079s 5:29.79 99.2%   0+0k 0+5io 0pf+0w
                (bounding box of tetrahedron only test)
                182.334u 3.275s 3:10.23 97.5%   0+0k 0+4io 0pf+0w
                (partial tetrahedron test)
                192.273u 3.868s 3:21.16 97.4%   0+0k 0+2io 0pf+0w
                (bounding box specific code test)
                171.024u 1.262s 2:52.80 99.6%   0+0k 0+2io 0pf+0w

X Should my Aaabb listeners be called visitors?
    X No, that means something else.

X Rename AabbTree::applyToBoundingBox to applyToBoundingBoxIntersection for consistency.
    X Same for mesh::EdgeIntersector::applyToBoundingBox.

X Modify all ray segment intersection function to take the two endpoints of the ray
    as arguments, rather than a ray and a non unit length direction,
    which is confusing and error prone.
    Rename the 'direction' arguments to 'endpoint'.
    X Update cgmath::BoundingBox3fIntersectsRaySegment and all calls.
    X Update mesh::RaySegmentIntersectsFace and all calls.
    X Update Intersector::objectOccludesRaySegment and all calls.
    X Update AabbTree::RaySegmentOcclusionListener::objectOccludesRaySegment and all calls.
    X Update AabbTree::occludesRaySegment and all calls.
    X Update AabbTree::occludesRaySegmentForSubtree.

X In MeshShader, prefix mLineSegmentCollection and mEmissiveFacePtr
    with 'Triangle', just as the mBoundingBox member variables are prefixed.

X Change the names of all the AabbTree '*Tests*' functions to be ray-agnostic,
    and then update all the underlying functionality to update the values
    in all the non-ray tests.

X Make rfm_discmesh print total statistics about AABB usage.

X Rename RayIntersector, since it intersects more than rays.

X Accelerate discontinuity meshing with the AABB tree.

X 'RUN temple' has some dark patches under the arches in the foreground.

X Move BoundingBox3f::intersectsRaySegment into BoundingBox3fOperations.h,cpp.

X Move BoundingBox3f::intersectsBoundingBox3f into BoundingBox3fOperations.h,cpp.

X Move BoundingBox2f::intersectsBoundingBox2f into (newly created) BoundingBox2fOperations.h,cpp.

X Get rid of the listener in AabbTree::occludesRaySegmentForSubtree,
    and just call a member function of the template object type.
    X Same for BoundingBoxListener.
    X I am assuming this won't require these to be defined unless functions
        like occludesRaySegmentForSubtree are actually called.
    X This doesn't work well with RayIntersectorFaceListener because
        RayInterectorAabbTreeNode doesn't have access to RayIntersector.
        X This functionality could be moved to AabbTree.
    X Stick with the listeners.

- Update the AABB ray intersection code so that it'd be possible
    to fire rays and find out the object first intersected and the
    coordinate of the intersection.
    - Add a separate set of functions for this.

- I'm pretty sure when I am computing backprojections, I don't handle the case
    where the plane of the face being shaded intersects the emissive face.
    I really should calculate this intersection (triangle with a plane)
    and make sure that the emissive face is subdivided along this additional line segment.
    - Create a test scene that demonstrates this problem before trying to fix it.
    - I think I am already handling this case correctly when calculating discontinuity
        line segments in the scene, as in 'RUN light-split'.

X I don't think I'm calculating form factors correctly.
    X Look at GPU Gems 3, Chapter 12, "High Quality Ambient Occlusion".
    X I'm not normalizing the gamma term.

X Make the accessor function creation macros not add "const &" when the variable
    type ends in "Ptr".

X Tune the number of objects added to each AABB leaf node:
    1: 170 seconds
    2: 171 seconds
    3: 173 seconds
    4: 175 seconds

- When merging meshes, one way to resolve the potential for attribute key name/type
    conflicts is to get rid of types as a second argument to Mesh::getAttributeKey
    altogether, and fold the type information into the name of the key.

X RetriangulatorFace::mergeNearlyColinearFaceLineSegments merges colinear edges
    who meet at their endpoints, and then Retriangulator will immediately split
    them again where other line segments meet the original point of intersection.
    X Modify MergeFaceLineSegmentsIfColinearAndIntersecting2f so it doesn't merge
        line segments in this case.

X Add 'equivalent' functions to all the vector types, that take an epsilon argument.

X Make rfm_discmesh print out the min, max, and average vertex color
    intensity, and the scaling factor that would be required to 
    bring the max value up to 1.

- Create a scene in which a triangle has zero area. 
    Then WedgeIntersector::initializeTriangle will fail.
    - Fix this case.

- When I make levels consistent of multiple fragments, make sure that the geometry
    of each fragment is centered around its own localized origin, and render everything
    relative to this coordinate space, including the camera.
    This will help with floating point issues for large levels.
    - If I do this, how do I calculate lighting for each fragment?
        - One approach would be to include adjacent fragments in the level for
            purposes of casting shadows, but not bother shading the adjacent fragments.
            - This would increase overall lighting time, but allow me to
                relight individual fragments much more quickly when only a single
                fragment has changed, which is probably what will happen most often.
            - This might tend to make the lighting time performance linear on the number
                of fragments, rather than nonlinear.
            - Try to keep this really general, so rfm_discmesh does not wind up
                tied to my level description. Make rfm_discmesh take additional
                RFM files and offsets for these files as arguments.
                - On second thought, I really will need the XML to specify
                    information like the sun position and the texture maps
                    for the sky box, to provide correct global illumination.
                - Temporarily add the adjacent geometry to the mesh when
                    calculating the discontinuity mesh, but only record edges on,
                    subdivide and shade faces on the original mesh faces.
                    Afterward, delete all the faces on these adjacent fragments.

X There's an artifact at the top of the arch shadow inside the temple, to the left.
    X Groundplane face vertices at the following positions are being
        shaded incorrectly:
        -0.221091, 0, -1.34264
        -0.207643, 0, -1.34264
    X I partially fixed this by firing rays not from the center of adjacent faces,
        but from the average of the face center and the vertex being shaded.
        This fixes the case of first vertex above, but not the second.
    X I'm curious what the backprojection looks like for the second vertex,
        because debugging shows that only two of the six light source polygons
        are visible, and that none of them are subdivided.
        X Add some code to dump out the backprojection for this vertex.
        X Is the backprojection code working at all? Is it really recording
            line segments on the emissive faces?

X Create a test with a single triangular occluder and a single large 
    triangular light source, and a groundplane that is already subdivided 
    into a fine grid of triangles, so I can clearly see if the backprojection
    is being calculated correctly at the points between the umbra
    and the penumbra.

X This fails with a CDT error:
    RUN contact-shadow --no-em --sun-az 0 --sun-el 0 --sun-sides 12
    X This looks like a shadow discontinuity line segment is coincident with
        one of the edges of a face.

X This fails with a CDT error:
    RUN four-boxes --no-em --sun-az 60 --sun-el 90 --sun-sides 12

X This fails with a CDT error:
    RUN cylinders --no-em --sun-az 45 --sun-el 80 --sun-sides 12

X This fails with a CDT error:
    RUN four-boxes --no-em --sun-az 45 --sun-el 70 --sun-sides 12

X This fails with a CDT error:
    RUN four-boxes --no-em --sun-az 180 --sun-el 80 --sun-sides 12

X This fails with a CDT error:
    RUN four-boxes --no-em --sun-az 185 --sun-el 80 --sun-sides 12

X This has a funny artifact: 
    RUN pile-of-boxes --no-emissive --sun-az 60 --sun-el 60 --sun-sides 6

- This has a funny artifact:
    RUN four-boxes --no-em --sun-az -45 --sun-el 60 --sun-sides 12

X This has a funny artifact:
    RUN four-boxes --no-em --sun-az 135 --sun-el 60 --sun-sides 12
    X It looks like this vertex is being shaded incorrectly:
        0.433592, 0, 0.190901
        X It almost looks like that vertex should be a D0 discontinuity,
            but is being shaded as if it is not.
        X It's not a contact point, so I'm not sure how it could
            be a D0 discontinuity.
        X Aren't there other D0 discontinuity cases though, like
            when certain edges on the light source and on the models
            are parallel to each other?
        X Wild guess: In meshretri, when I discard line segments
            that are colinear, or other features, I should mark these
            as being D0 discontinuities.
    X Test if I get better results if I force the vertex above
        to be treated as a D0 discontinuity, individually shading
        the face vertices around it.
    X Looking at the scene geometry, I bet there are actually two vertices at this location,
        or two vertices have collapsed into one.
    X The vertex can only see 4 of the 12 light source triangles.
        I think that's a problem, because we're expecting that
        all or none of the light source triangles are visible, as would be the case
        for a true D0 discontinuity vertex.
        We're trying to shade an adjacent face vertex whose face should be
        visible to the entire light source.
        X Forcing the vertex to act as if all 12 light source triangles are visible
            and that the vertex is a D0 discontinuity
            gets rid of the artifacts.
            That's nice to know, but it's unclear how I'd decide to do this
            automatically.
        X If I hack up meshretri::PointGroup::snapPointPositions to leave the
            points around the problematic vertex alone, then the shading artifact
            goes away.
            X So, this is looking like I should make 'meshretri' only filter
                the line segments when it is strictly necessary to provide
                valid input to the CDT code. What I'm doing now is
                far too liberal in its filtering.

X I think this case is similar: (It's not.)
    RUN two-slabs --sun-az 180 --sun-el 38 --sun-sides 12 --sun-diam 90
    X So what I'm thinking now is that the retriangulator code I have that snaps
        vertices together, or vertices to line segments, is a problem in these
        cases because it's moving points around, and then later when I test if the
        light source is visible from the newly adjusted vertex,
        the ray is occluded, when it wouldn't have been if it
        had not been shifted.
    X How could I handle these cases?
        X Don't shift the vertices. But if I do that, is it possible that I'll
            still be susceptible to floating point issues?
            X One way this could work is keep track of the unshifted position
                of each vertex, so I could use that for the visibility test
                instead of the actual vertex position.
                Maybe I could store this as an attribute of each vertex.
       X Somehow, relax the light source visibility test so that small grazing
           occlusion events are ignored.
    X Maybe the problem is caused by the point snapping I do in 
       DiscontinuityMesher::snapNewMeshVerticesToOriginalMeshVertices.
       If so, this function could be modified to store the original vertex position
       as a temporary vertex attribute, and then I'd test both the snapped and unsnapped
       positions for visibility, acting as if the light source was visible
       if either of the two vertices are visible.
       X This could only help in the two-slabs case, but would not help
           for the four-boxes case, since it isn't being snapped to
           an original mesh vertex.
       X Maybe the light leak in the upper left shadow corder of the two-slabs
           test is also caused by snapping.
       X I'm really starting to think that the snapping is a problem.
           It's too dangerous to move vertices around.
    X I suspect that when meshretri's point snapping code snaps two distinct
       vertices together, the resulting vertex should then be treated
       as a D0 discontinuity, because without snapping, it could have
       been two vertices shaded with different intensities.
    X Try these test case with all snapping disabled.
    X Is there any light source visibility information I can assume, just by
       knowing which light sources created specific edges in the mesh?
    X Try skipping the snapping I do in
       DiscontinuityMesher::snapNewMeshVerticesToOriginalMeshVertices
       on the two-slabs model, and see if the artifacts go away.
       If that's the case, then keeping the original vertices around
       and testing both the snapped and unsnapped vertices for visibility,
       and using only the visible one might work.
       X This fixes the artifacts in the two-slabs case.
       X What I'm pretty sure I should do is only try to snap the vertices
           that are flagged as D0 discontinuities. There's no reason
           to snap the others.
           X If that works, then maybe I could also get rid of that snapping code
               entirely and pre-snap the D0 vertices right at the point
               where I initially mark them as D0.
           X This doesn't work in the two-slabs test, because the problematic
               vertices are all being flagged as D0. I'm not sure why.
           X Surprisingly, disabling the snapping doesn't make the cylinders
               artifacts return, so another I've made since adding
               the snapping must have corrected that problem as well.
               X Get rid of the DiscontinuityMesher snapping code.
                   X I removed this in revision 2570.
    X First, demonstrate that the snapping is a problem.
        X In the two-slabs model, in Retriangulator::filterFaceLineSegments,
            it's critical that mergeNearlyColinearFaceLineSegments is called,
            or else the CDT will fail. I can remove nearly everything else
            from Retriangulator::filterFaceLineSegments and it will succeed.
        X None of this seems to have any effect on the shadow light leak
            problem in the two-slabs test.
        X The upper left light leak shadow is really messed up.
            X There's a D0 discontinuity vertex there that makes no sense.
            X There are three vertices that are shaded incorrectly, not just one.
            X Here are the bad vertices:
                X This vertex is fully illuminated, but should be 50% illuminated:
                    -2.95648, 0, -2.60988
                X This vertex should be fully occluded, but is only partially occluded:
                    -2.95771, 0, -2.54039
                    X Debugging shows that it is able to see the center of a few of the
                        light source polygons.
                    X Figure this out.
                    X I suspected that maybe the AABB tree wasn't working.
                        I tried disabling the AABB tree entirely, but this
                        introduced an additional artifact on the opposite corner,
                        which is even more mysterious.
                        X This could all be consistent with the ray/triangle
                            intersection code having issues.
                            X Switching mesh::RaySegmentIntersectsFace over to
                                use doubles everywhere makes the artifacts go away
                                in this case, but not any of the four-boxes or
                                pile-of-boxes cases.
                            X Look over this 'double' version of RayIntersectsFace,
                                again, comment it, and then check it in.
                                X Maybe get rid of the epsilon test entirely,
                                    and test against zero. This might be OK now that
                                    I am using doubles.
                X This vertex is D0 but should not be, and one adjacent face vertex
                    is incorrectly shaded:
                    -3.04352, 0, -2.50988
    X Then, reconsider everything in Retriangulator::filterFaceLineSegments,
        in terms of exact predicates. The goal should to only filter the 
        line segments when it is strictly necessary to make the CDT code not fail.
        Otherwise, we shouldn't be moving the FaceLineSegment endpoints around.
        X Perhaps when nearly colinear line segments are merged, it's a mistake
            to replace them with a single line segment. Instead, maybe I should
            replace them with a series of line segments so that the existing
            mesh endpoints are preserved.

X After I do everything above, go back to the original four-boxes test case
    and dump the backprojection for the problematic vertex to an SVG file.
    X Check in the MeshShader.cpp code in such a way that I can dump
        backprojections easily for debugging in the future, when needed.

X Now I'm suspecting that backprojections aren't working for distant lights.
    Do a test of this.
    RUN distant-backprojection --sun-az 0 --sun-el 90 --sun-sides 6 --sun-diam 6000
    X Looks good to me.

X This test, although I fixed part of it above, has a weird light leak
    in the upper left corner of the shadow.
    RUN two-slabs --sun-az 180 --sun-el 38 --sun-sides 12 --sun-diam 90

X 'RUN wall' fails an assertion.
    X Is a face degenerate?

X 'RUN shadow-creep-bug' fails an assertion.

X 'RUN backprojection' fails an assertion.

X 'RUN four-lights' fails an assertion.

X Backout the debugging code I accidentally checked into MeshShader.cpp,
    probably in revision 2543.

X This has artifacts:
    RUN four-boxes --no-em --sun-az 185 --sun-el 75 --sun-sides 12
    X The two incorrectly shaded vertices on the top of the box are:
        (right) -0.160411, 0.999999, 0.947383
        (left) -0.356854, 0.999998, 0.776118
        X It's as if no line segments are being created on the faces on the top
            of the box where it intersects the VE wedge formed by the edge
            on the base of the upper box.
        X Maybe in WedgeIntersector I should handle the case where edge PQ
            lies in the plane of the triangle being tested by 'testTriangle'
            in the case of a VE wedge.
            X Do some testing to determine that this is actually the problem.
                X Check for the case of the problematic triangle being passed,
                    when PQ is the edge of the upper box.
            X One of the two lower box top faces is:
                -0.511984, 1, 1.24512
                0.488016, 1, 1.24512
                0.488016, 1, 0.245116
            X The top box lower edge is:
                -0.364711, 1, 0.769268
                0.012169, 1, 1.09784
        X In WedgeIntersector::clipToVeWedge, when the line segment is clipped
            to the volumes above and below edge PQ,
            it's a problem when the line segment is nearly colinear with edge PQ.
            What I'd like to do is earlier detect that edge PQ lies in the plane
            of the triangle being clipped, and then when I reach clipToVeWedge,
            if this is the case, don't clip it against edge PQ,
            but return it as lying entirely below PQ, so it'll be tagged as
            being below the occluder, and therefore won't be discarded.
    X There are other dark vertices on the groundplane between the boxes.

X This has artifacts:
    RUN four-boxes --no-em --sun-az 190 --sun-el 75 --sun-sides 12

X This has a very subtle artifact between the two cylinders that
    are closest together:
    RUN cylinders --no-em --sun-az 45 --sun-el 80 --sun-sides 12

X This has artifacts:
    RUN four-boxes --no-em --sun-az 45 --sun-el 70 --sun-sides 12
    X There a black smear between the two boxes.
    X The tiny bit of shadow on right side of the leftmost top box (as viewed
        from the light source) has a light leak.

X This has artifacts:
    RUN four-boxes --no-em --sun-az 180 --sun-el 80 --sun-sides 12

X This has a weird fuzziness in the shadow under the overhanging box:
    RUN four-boxes --no-em --sun-az 185 --sun-el 80 --sun-sides 12 

X Display the number of distant light sources in the log output, after
    the number of emissive faces.

X Change the 'opt' library code so that the --help and --help-debug flags appear
    at the bottom of the usage message, not in the middle. (r2650)
    Merged to trunk in r2652.

X This has artifacts:
    RUN two-slabs --sun-az 0 --sun-el 60 --sun-sides 12

X This has a very subtle like leak in the shadow:
    RUN two-slabs --sun-az 180 --sun-el 38 --sun-sides 12

X This has a light leak in the upper left of the shadow:
    RUN two-slabs --sun-az 180 --sun-el 38 --sun-sides 12 --mark --sun-diam 100

X This has a light leak in the upper left of the shadow:
    RUN two-slabs --sun-az 180 --sun-el 38 --sun-sides 12 --mark --sun-diam 90

X Teapot
    RUN teapot --sun-az 95 --sun-el 70 --sun-sides 6 

X Redo 'meshretri' so that it never moves points around, which 
    is what's screwing up the shading in this case:
    RUN four-boxes --no-em --sun-az 135 --sun-el 60 --sun-sides 12
    X The new code must have the following restrictions:
        X Vertices must never be moved.
        X Vertices must never be deleted.
        X Only vertices which have exactly the same 2D positions, without any
            tolerance in the comparison, should be merged.
        X Don't even delete vertices from degenerate faces.
    X The CDT code requires that:
        X No two vertices are coincident.
        X No line segments intersect.
        X No vertices intersect another line segment.
    X The new code must handle degree zero vertices just as the old code does.
    X The new code should use exact predicates, and should not
        require definition of any tolerances.
        X I decided that tolerances were acceptable when dealing with
            line segment endpoints that intersected with existing face edges,
            because the triangle wedge intersection code can't possibly
            output vertices that exactly intersect the edges.
    X The new code must handle retriangulation of backprojection faces,
        just as the old code does.
    X If it's at all possible, reuse most of the existing code.
    X After this change, the word "nearly" should not show up in the names of any functions.
    X If I could get rid of epsilon tests everywhere, that might also be ideal.
    X The unit tests for 'meshretri' also have to be stripped of the word "nearly",
        and their logic must be changed to reflect that.
    X I might be able to get rid of the functions like
        RetriangulatorEdge::deleteEdgePointsReferencingFaceLineSegment
        and RetriangulatorEdge::remapEdgePointsReferencingFaceLineSegment
        that are necessary because I delete things during the filtering process.
    X I might not need PointSnapper at all, because the whole idea is to not
        move any vertices around.
    X RetriangulatorEdge::sortEdgePoints could be made more robust by
        identifying the longest axis of the edge, and sorting the points
        along that axis, rather than by computing the value of 't' along the edge.
        X If I do this, remember to worry about the direction of the edge
            along this axis. I can't copy the values for the axis straight to 't'.
            Half the time, I'll have to negate them.
        X I opted not do this, and use doubles for 't' instead.
    X It's critical that I plan this out in detail before doing anything, and examine
        each function to make sure that epsilon tests have been removed everywhere
        and replaced with exact tests.
        X Make a list of all the functions that look even remotely suspicious,
            and then check them off as I've verified whether or not they need to be changed.
            Add each function that needs work to yet another todo list
            that'll track the actual work.
    X Do this work in a branch so if it turns into a mess I can throw it away.
    X When we intersect line segments with the original face edges and split them,
        don't snap the line segment endpoint to the original face edge.
        Instead, route the face edge through the line segment endpoint,
        so we don't wind up moving the endpoint.

X Here's the plan to make 'meshretri' not be lossy.
    X Remove RetriangulatorFace::deleteAllFaceLineSegments.
    X Remove Retriangulator::deleteFaceLineSegmentsFromDegenerateFaces.
    X In Retriangulator::filterFaceLineSegments, remove the call to
        deleteFaceLineSegmentsFromDegenerateFaces.
    X Remove RetriangulatorFace::deleteAllDegenerateFaceLineSegments.
    X Remove Retriangulator::deleteAllDegenerateFaceLineSegments.
    X In Retriangulator::filterFaceLineSegments, remove all calls to
        deleteAllDegenerateFaceLineSegments.
    X Remove MergeFaceLineSegmentsIfColinearAndIntersecting2f.
        X The plan is, if line segments intersect, we'll split them.
            If they're nearly colinear but don't intersect, we'll leave them alone.
        X If line segments are exactly colinear and intersect, we'll handle
            this as a special case of the splitting in a way that 
            results in up to three line segments, without discarding
            any endpoints.
    X Remove RetriangulatorFace::mergeNearlyColinearFaceLineSegments.
    X Remove Retriangulator::mergeNearlyColinearFaceLineSegments.
    X Remove the do-while loop from Retriangulator::filterFaceLineSegments.
    X Remove RetriangulatorEdge::deleteAllEdgePoints.
    X Remove Retriangulator::deleteAllEdgePoints.
    X Modify RetriangulatorFace::createEdgePoints.
        X This function must continue relying on epsilon tests, because
            the line segment endpoints output by the triangle wedge intersection code
            will generally not lie exactly on the face edges.
        X In the first comparison, when both line segment endpoints lie on the edge,
            don't delete the line segment, but mark the line segment, indicating
            that it is colinear with a mesh edge, so that later on, we won't
            submit it as a CDT constraining edge.
            X Add FaceLineSegment::setIsColinearWithExistingMeshEdge. (r2637)
            X Also, continue with the existing tests in createEdgePoints,
               so that both endpoints will be recorded.
        X There might be a problem here, because inserting points along the 
            existing face edges will alter the polygon perimeter, which may
            cause it to intersect with still more line segments.
            Or, can we assume that the epsilon test will make us avoid this problem?
            X If this turns out to be a problem, we'll just have to do repeated passes,
                comparing against the split version of the face perimeter each time,
                until no more splitting occurs.
                X The repeated passes must be over the whole mesh, because changes
                    to each face's perimeter could affect line segments on
                    neighboring faces. I'd just keep making passes over the whole mesh
                    until no changes were made.
    X Remove RetriangulatorEdge::snapTogetherNearlyCoincidentEdgePoints.
    X Remove Retriangulator::snapTogetherNearlyCoincidentEdgePoints.
    X In Retriangulator::filterFaceLineSegments, remove the call to
        snapTogetherNearlyCoincidentEdgePoints.
    X Remove RetriangulatorFace::snapTogetherNearlyCoincidentFaceLineSegmentEndpoints.
    X Remove Retriangulator::snapTogetherNearlyCoincidentFaceLineSegmentEndpoints
    X In Retriangulator::filterFaceLineSegments, remove the call to
        snapTogetherNearlyCoincidentFaceLineSegmentEndpoints.
    X Remove RetriangulatorFace::splitAllFaceLineSegmentsIntersectedByFaceLineSegmentEndpoints.
    X Remove Retriangulator::splitAllFaceLineSegmentsIntersectedByFaceLineSegmentEndpoints.
    X In Retriangulator::filterFaceLineSegments, remove the call to
        splitAllFaceLineSegmentsIntersectedByFaceLineSegmentEndpoints.
    X Modify RetriangulatorFace::splitAllMutuallyIntersectingFaceLineSegments.
        X First call exact::TestPointIntersectsLineSegment for each endpoint on each
           line segment, to check for all six cases where the line segments
           intersect exactly, previously handled by 
           MergeFaceLineSegmentsIfColinearAndIntersecting2f.
           X Add exact::TestPointIntersectsLine.
           X In these cases, we'll split the line segments, resulting in
               up to three line segments.
           X Most of the time, we'll wind up with three line segments,
               in order to preserve the original endpoints of the line segments.
           X Preserve the D0 discontinuity flags of the endpoints.
           X Write a function to help with the splitting in the cases when 
               two line segments result, and when three line segments result.
               X Create the function RetriangulatorFace::splitColinearFaceLineSegments. (r2648)
               X In the three line segment case, we'll have to create
                   an additional line segment.
               X This function must correctly preserve D0 discontinuities,
                   and wedge identifiers.
               X Write unit tests for this function.
           X Deal with the cases when one or more of the line segments are degenerate.
        X Call exact::TestLineSegmentsIntersect instead of GetIntersectionOfTwoLineSegments,
           and then call cgmath::GetIntersectionOfTwoLines
           instead to get the intersection point, so that it always succeeds.
    X Modify RetriangulatorFace::splitFaceLineSegment to introduce
        D0 discontinuities in the middle of a line segment intersected by another
        line segment that has D0 discontinuties on both endpoints.
    X Modify RetriangulatorFace::splitFaceLineSegment to make sure that
        wedge identifiers are properly preserved.
    X In FaceSplitter::createEdges, don't submit face line segment edges
        that have been marked as 'isColinearWithExistingMeshEdge'. (r2639)
        X Don't even bother submitting their endpoints as vertices, because it's
            assumed that this happened early when the polygon boundary
            was submitted to the CDT.
    X Modify Retriangulator::addEdgePointToRetriangulatorEdge so it no longer snaps
        the face line segment endpoint to the mesh edge. (r2635)
    X Remove PointSnapper, PointGroup, and Point classes.
    X Remove RetriangulatorFace::deleteFaceLineSegmentAndReferencingEdgePoints if it's
        no longer referenced anywhere.
    X Remove RetriangulatorEdge::deleteEdgePointsReferencingFaceLineSegment
        if it is no longer used.
    X Remove RetriangulatorEdge::remapEdgePointsReferencingFaceLineSegment
        if it is no longer used.
    X Remove RetriangulatorEdge::addEdgePointsToPointSnapper.
    X Remove Retriangulator::addEdgePointsToPointSnapper.
    X Remove FaceLineSegmentIsDegenerate2f if it's no longer needed.
    X Remove RetriangulatorFace::setFaceLineSegmentEndpointPosition if it's
        no longer needed.
    X Remove the word 'nearly' from all function names, as appropriate.

X I think in the plan above, there's a problem when a wedge intersects
    multiple faces. 
    X The endpoints of line segments from adjacent faces, meeting
        at a shared edge, might cause unnecessary duplication
        when they are not exactly coincident.
    X I think I could fix this problem by assigning each wedge an integer identifier
        as it is traced, and then recording this identifier with each
        FaceLineSegment.
        X Then, when edge points are recorded along RetriangulatorEdges,
            if endpoints of FaceLineSegments from the same wedge occur,
            I'd merge them by choosing the point that lies closest to
            the original edge.
        X This must all happen before FaceLineSegments for each face are split
            against each other, because it will result in small shifts
            of the FaceLineSegments, as their endpoints will be adjusted.
    X Add meshretri::FaceLineSegment::setWedgeIdentifier
        and make DiscontinuityMesher call it. (r2627)
    X Add some code to meshretri somewhere to merge FaceLineSegment endpoints
        that meet at a mesh edge and came from the same wedge.
        X Add RetriangulatorFace::getFaceLineSegmentWedgeIdentifier. (r2630)
        X Add RetriangulatorEdge::mergeEdgePointsCreatedFromCommonWedge. (r2632)
        X Add Retriangulator::mergeEdgePointsCreatedFromCommonWedge. (r2633)

X Use 'svn switch' to get back to the trunk and then merge the branch.

- Maybe when line segments endpoints nearly intersect other line segments,
    I should split the intersected line segment without moving the
    intersecting endpoint.

X Because of floating point error, splitting two line segments against each other
    could perturb them enough to cause them to intersect with still more line segments.
    So, it'll still be necessary to loop repeatedly until no more intersections occur.
    X I modified the code to do this, and now it fails the assert at the
        end of RetriangulatorFace::splitColinearFaceLineSegments with the following state:
        a0, a1 = -1.10918, -0.5
        b0, b1 = -1.23248, -0.5
        X This means that I'm not handling the following case:
                +---+
            +=======+
            and I'm not handling this case either:
            +---+
            +=======+
        X Add unit tests for these cases.
        X Implement the code to handle these cases.

X Run the contact-shadow test, and test when the duplicate edges along
    the contact point show up, and then explicitly test to see if they intersect
    and what happens to them.
    The edges are:
        0.5, 0, -0.5 and -0.5, 0, -0.5
        0.5, 0, -0.5 and 0.5, 0, 0.5
    X I determined that the duplicate edges that happen here are not
        exactly duplicates of each other. Their endpoints differ by a small epsilon.

X In Retriangulator::filterFaceLineSegments, call 'createEdgePoints'
    and 'mergeEdgePointsCreatedFromCommonWedge' after all the line segments are split.
    I'm pretty sure this is a good idea, although I can't think of any cases
    where it avoid errors.

X I think there's a problem with RetriangulatorFace::createEdgePoints.
    X 'RUN triangles' fails an assert at src/meshretri/FaceSplitter.cpp, line 523.
    X Face edges are being redundantly added in a backprojection triangle.
    X Adding debugging info to FaceSplitter::createPolygonFromRetriangulatorEdgeArray shows:
        (A) point 0, 0.161541 3.55387 0.435954      initial face vertex
        (B) point 1, -0.255449 3.55387 0.327518     another face vertex
        (C) point 2, 0.0469538 3.55387 0.0206121    point on edge
        (B) point 3, 0.046954 3.55387 0.020612      another face vertex
        (C) point 2, 0.0469538 3.55387 0.0206121    point on edge
    X What's happening is that two vertices corresponding to point 2 above,
        with the same position in space, are being added to adjacent edges,
        causing the same sub-edge to be created twice.        
    X I think this is because createEdgePoint's epsilon tests are too greedy.
        X I'm pretty sure that the way createEdgePoint is written, the same line segment
            endpoint can be submitted to multiple edges if it lies near more than one.

X 'RUN triangles' still fails.
    I think the problem now is that RetriangulatorFace::createEdgePoints causes
    problems when a line segment straddles an edge and nearly intersects a mesh vertex.
    If the shared endpoints of the split line segments are the same,
    but are assigned to different mesh edges, this will cause
    FaceSplitter::createPolygonFromRetriangulatorEdgeArray
    to fail later on.
    X I want to somehow ensure that identical endpoints are always 
        assigned to the same edges. Furthermore, it's critical that
        the mesh edges don't fold back on themselves.
    X This makes me generally suspicious of RetriangulatorFace::createEdgePoints.
        Maybe it shouldn't act on each face independently.
    X Would it be enough to examine existing edges and check if the endpoints
        already existed there? In that case I'd do nothing, because the
        endpoint was already represented on an edge.
    X When I intersect triangles with wedges, can I keep track of which mesh
        edges or vertices correspond to the line segment endpoints,
        and then use this information RetriangulatorFace::createEdgePoints
        to decide which edge to associate a vertex with,
        and sidestep this problem entirely?

X Try passing mesh vertex/edge intersection information along with
    face line segment endpoints, and then make
    RetriangulatorFace::createEdgePoints use this information rather
    do an epsilon test against edges.
    X Create yet another branch for this work!
        X Created file:///Users/drew/lib/svn_repositories/retro/branches/endpoint-origin.
    X In WedgeIntersector, add vertex and edge pointers.
        Also define a variable that keep track of whether or not the endpoint
        is coincident with a vertex, an edge, or no feature.
        X Make this a new class, EndpointOrigin, and then make Endpoint use it.
            X Put this class in meshretri, because we'll want to use it
                in meshretri::FaceLineSegment later.
    X In WedgeIntersector::testTriangleVertices,
        set EndpointOrigin member variables if any of the triangle vertices intersect exactly
        with the wedge.
    X In WedgeIntersector::testTriangleEdges,
        set EndpointOrigin member variables if any of the triangle edges intersects
        with the wedge. The vertex pair (AB, BC, CA) to edge mapping is described 
        in the header file comments.
    X Add EndpointOrigin to ClippableEndpoint.
    X In testTriangle, set the EndpointOrigins of the two ClippableEndpoints.
    X In clipToPlane, if an endpoint modified by the clipping,
        reset its origin to 'no feature'.
    X In WedgeIntersector::recordClippableEndpointsAsLineSegment, 
        assign the ClippableEndpoint's two EndpointOrigins
        to the Endpoints of the LineSegment that is returned.
    X Add EndpointOrigin to meshretri::FaceLineSegment.
    X In RetriangulatorFace::createEdgePoints, examine the FaceLineSegment
        EndpointOrigins to determine which mesh edges to add the 
        endpoints to.
        X Assert that the endpoints are within an epsilon distance of the mesh edge
            they're being added to.
        X If the endpoint is associated with a vertex, then assert that the
            mesh endpoint has the same position as the vertex.
            X It might be appropriate to snap the endpoint to the vertex in this case.
        X My initial attempt at this is not working, I believe because 
            LineSegmentCollection::splitLineSegments
            and LineSegmentCollection::findVisibleLineSegments
            are not copying over the EndpointOrigins to the new line segments.
            X It looks like splitLineSegments does preserve EndpointOrigins.
        X Now 'RUN contact-shadow' fails.
            It seems that there is a degenerate line segment
            coincident with a face vertex, which is causing the CDT to fail.
    X After the splitAllMutuallyIntersectingFaceLineSegments call 
        in Retriangulator::filterFaceLineSegments,
        do an additional pass that tests for exact intersections of
        FaceLineSegment edges against the new triangle perimeter, 
        taking into account the existing edge points we've added.
        X This will require sorting the edge points first.
        X If there are new intersections, add more split points,
            and then repeat the pass (over the whole mesh)
            until no more splitting is required.
    X If all of this seems to help, merge this back to the exact-meshretri branch,
        starting with revision 2608.
    X This was a mess and I threw it away.

- In traceBackprojectionWedge, if the line segment collection only
    contains one line segment, can I optimize away the call
    to lineSegmentCollection.calculateVisibleLineSegments
    or perform any other optimization?

X 'RUN cylinders' gets caught in an infinite loop because
    RetriangulatorFace::splitAllMutuallyIntersectingFaceLineSegments
    gets caught in a situation where it's always splitting line segments.
    X It wasn't actually an infinite loop, it was just really slow in debug mode.
        I think this was because now that I'm not merging vertices as aggressively,
        many more points were submitted to the CDT, and the debug mode checking
        was causing exponential behavior

X 'RUN triangles' fails with a degenerate edge near one of the triangle
    vertices during shading.
    X I added some code to avoid submitting duplicate vertices or edges
        in the CDT polygon perimeter, but it's still entirely possible
        that because of floating point error, the CDT perimeter could fold back 
        on itself, causing the CDT to fail.
        X This can happen when an nearly degenerate edge is nearly
            coincident with one of the triangle's vertices.
        X I have to figure out some way of submitting clean input to the CDT,
            but without getting tripped up by nearly degenerate input.

X 'RUN triangle-square' fails in a crazy way, with the wrong end of a line segment
    getting assigned to an edge of the face.
    X Curiously, ifdef'ing out the splitAllMutuallyIntersectingFaceLineSegments
        calls in Retriangulator::filterFaceLineSegments
        corrects the edge of the polygon (but leaves split edges).
    X The problem here is that in Retriangulator::retriangulate,
        filterFaceLineSegments creates the points along the edges,
        but only records the endpoints as line segment indices and endpoint indices,
        rather than positions, and then the line segment endpoints are modified by 
        splitting them against each other,
        and then splitMeshEdges finally queries the line segment endpoint positions,
        and they've already moved.
        X I implemented it this way so that in the original version of the code,
            when I snapped edge points together, I could modify the
            original line segment endpoints, so it would be taken into
            account when line segments were split against each other.
        X Now that I'm not allowed to move endpoints,
            I should get rid of all this, and only store the actual endpoints.

X Well, this sucks ass.
    X I tried to take too big of a step all at once.
    X It devolved into a lot of bugs I don't understand.
    X I have no confidence that what I'm attempting will actually work anyway.
    X I'm concerned that there are fixes that I made in the two
        branches that should be merged back to trunk.
        X Figure out some way of looking over all changes I made systematically,
            and identify revisions that should be merged to trunk.
    X Merge the changes to doc/TODO.txt back to trunk.
    X Before attempting this again, come up with a much more detailed plan,
        and be confident it's going to work.
    X Break the new plan down into many small steps, and make sure that each
        is well tested in isolation.

X Changes I might want to merge back to trunk or exact-meshretri from
    file:///Users/drew/lib/svn_repositories/retro/branches/endpoint-origin
    X 2721 - RetriangulatorFace::splitColinearFaceLineSegments now chooses longest axis 
               of the two primary axes for the face, not from all three axes.
    X 2720 - Added unit test.
    X 2704 - Now writes to /var/tmp/backprojection.svg
    - 2731 - skip
    - 2732 - skip
    - 2733 - skip
    X 2734 - Added more doubles to GetIntersectionOfLineWithPlane.
    - 2735 - Added extra checks to avoid submitting duplicate edges to the CDT 
               when specifying the polygon perimeter.
    - 2737 - Added additional tests to avoid specifying duplicate points or edges 
               to the CDT perimeter

X Now I'm leaning toward merging the changes above back to the exact-meshretri
    branch, and attempting to do everything with epsilon tests again
    along the mesh edges and against mesh vertices.
    X I'm tempted to just let this sit for a few days and think about it
        and draw pictures until I come up with a solution
        that I think is robust and that will not perturb the line segment endpoints.
    X The thesis "Discontinuity Meshing for Complex Environments" appears
        to do epsilon tests, so maybe if I can do it without moving endpoints around,
        I'll be OK.

X RetriangulatorEdge::mergeEdgePointsCreatedFromCommonWedge
    must move the FaceLineSegment endpoint corresponding to the point
    that's deleted. Otherwise the face splitting code is going to run into
    problems because it's still going to try to create a vertex at the location
    of the deleted point.
    X It's critical that this happens before faces are split against each other,
        because otherwise the FaceLineSegment endpoint move will modify
        the wrong point.

X I turns out that I do want to snap together line segment endpoints that
    were products of the same mesh edges or mesh vertices.
    X So I'll need to record these identifiers and then, later on,
        merge the points together by adjusting one of the line segment endpoints,
        before any of the line splitting takes place.
    X If I don't merge these endpoints, I'm pretty sure that a very large
        number of slivers will be created.

- WedgeIntersector could be improved by converting mWedgePositiveXAxis, etc.
    to Vector3d's, and making alternate double precision versions of functions
    like GetIntersectionOfLineWithPlane, to improve accuracy.
    - This would help transformWorldSpacePointToWedgeSpacePoint
        and transformWedgeSpacePointToWorldSpacePoint as well.

X Sheesh.
    X Write out yet another plan.
    X Do it all again in small steps.
    X Heavily unit test each step as I go along.
    X Don't rush it.

X What are the problems I need to solve?
    X Face line segment endpoints that meet along a mesh edge should be merged
        if they were generated by the same wedge.
        X I'm probably handling this already in FaceLineSegment::wedgeIdentifier,
            but this needs unit tests.
    X Face line segment endpoints that were generated from the same mesh endpoints
        need to be merged.
        X Choose one of the two endpoints, but don't average them.
        X I'll need to an endpoint identifier class again, and then ensure that
            this information is passed along correctly all the way through
            from WedgeIntersector to RetriangulatorFace.
    X I need to handle the case when a face line segment endpoint nearly
        intersects another face line segment along its length.
        X However, don't weld endpoints to line segments in this case when the
            endpoint lies within an epsilon distance of the other line segment's endpoints.
    X I need to somehow handle the cases when EdgePoints are close to the mesh vertices.
        This causes problems in my existing approach for defining the polygon
        perimeter passed to the CDT polygon triangulator.
        X In WedgeIntersector::testTriangleEdges, I call GetIntersectionOfLineWithPlane
            to find the intersection point of the wedge with the triangle edge,
            and because of floating point error I assume it's entirely possible
            that when the wedge plane intersects the edge extremely close to
            one of its endpoints, the calculated intersection point
            can be beyond one of the endpoints (that is, not inside the
            bounds of the triangle).
            X Write a function for the 'exact' library to ensure that,
                given a point and a line segment, the point lies strictly within
                the two bounding planes perpendicular to the line segment.
                The function should snap the point to the nearest plane
                if the point lies outside the bounding planes.
                X This function must handle the case of degenerate line segments.
                X This must be heavily unit tested.
            X Use this function in WedgeIntersector::testTriangleEdges.
            X However, now I'm thinking that maybe it'd be better to do
                an epsilon test in WedgeIntersector::testTriangleEdges, and snap
                the intersection point to the triangle edge endpoints
                if it's at all close to them.
                Maybe if I do this in WedgeIntersector,
                rather than in meshretri, I can keep the tolerance low,
                or maybe this is somehow safer.
    X I need to somehow deal with the problem of submitting the same point
        to multiple mesh edges as EdgePoints.
        X Create a line segment passing through each face vertex
            and the polygon center, and then use exact arithmetic comparisons
            to determine which edge to assign the point to.
        X I'm thinking that maybe I want to use the EndpointOrigin code after all.
            There are cases where, due to floating point error,
            if I try to determine which triangle edge a line segment endpoint
            is closest to in 'meshretri', I may choose an edge different
            from the one that WedgeIntersector decided was the intersecting edge
            via exact arithmetic.
            X I would only perform these comparisons if no EndpointOrigin
                information was available.
    X I have to deal with the case of nearly colinear face line segments that overlap
        along their length.
    X I have to deal with face line segments that are nearly colinear with the 
        edges of the face.
    X In all of these operations, line segment endpoints must never be moved,
        except to other endpoints that I know they are equivalent to.
    X Determine what the best ordering is for the calls 
        in Retriangulator::filterFaceLineSegments and be sure of it.
    X It gets worse. I can imagine situations with nearly degenerate triangles,
        where the perimeter is horribly self-intersecting.
        X I need an algorithm that is much more robust, and can deal with
            input geometry that is, because of floating point error, complete nonsense.

X Maybe it'd be enough to have a pass that, from the point of view of each face,
    in 2D, tested if any of its edges, as they would exist after subdivision,
    self-intersected, and corrected the self-interections by snapping
    all affected face line segment endpoints to the nearest mesh vertex.
    X For each triangle, exhaustively test if any of the perimeter line segments,
        before actually splitting the edges, exactly intersect other perimeter line segments.
        X When this is the case, collapse all edge points between the intersection
            point and the nearest vertex, along the two edges, to that vertex.
            X Snap the line segment endpoints that generated
                these EdgePoints to the vertex as well.
        X Keep doing this until no remaining non-degenerate perimeter line segments intersect.
        X Unit test this code heavily.

X Here's the new algorithm:
    X The priorities for the algorithm are:
        X FaceLineSegment endpoints should be moved as little as possible, if at all.
        X All intersecting line segments, including those of the face perimeter,
             must be resolved.
    X For each FaceLineSegment endpoint, find the adjacent mesh edge that 
        it is closest to, and test if it is within an epsilon distance
        of the edge. If it is, create an EdgePoint from it.
        X This isn't good enough.
        X As each new EdgePoint is added, I have to include it in the new
            triangle perimeter that is tested against for future tests,
            in case the newly modified perimeter puts it in contact
            with additional FaceLineSegment endpoints.
            X This test should be done in 2D, from the point of view
                of each face, to ensure that I correctly deal with
                all intersecting line segments.
            X Do epsilon tests against the original mesh edge, but exact intersection tests
                against the new perimeter that includes EdgePoints added so far,
                so the new perimeter can't creep too far.
    X Merge EdgePoints whose origin was the same wedge.
    X As described above, loop over all faces, and examine the EdgePoints 
        of adjacent edges, and filter out exact intersections,
        moving FaceLineSegment endpoints if necessary.
        X After this step, is it necessary to repeat the previous 
            step of EdgePoint creation to ensure that moving the
            line segment endpoints hasn't created further intersections?
    X Then, for each face, filter its FaceLineSegments.
        X Merge FaceLineSegment endpoints that are identified as originating
            from the same occluder edge endpoint during the wedge tracing.
            X Do this both for VE wedges and EV wedges.
            X For EV wedges, the endpoint identifier will have to work for
                distant light sources, even though no mesh elements are involved.
            X I'll have to resurrect EndpointIdentifiers.
        X Split line segments that are nearly colinear.
        X Test for FaceLineSegment endpoints that nearly intersect
            other FaceLineSegments along their length, and split these FaceLineSegments.
            X Don't do this if the FaceLineSegment endpoint is within an
                epsilon distance of either of the other FaceLineSegment's endpoints.
        X Split line segments that intersect.

X Now I'm thinking that it'd be best to completely remove all epsilon tests for
    line segment endpoints nearly intersecting mesh edges or other line segments,
    and rely entirely on explicit information provided by WedgeIntersector.
    X This would mean I'd revert back to the endpoint-origin branch, 
        because I'll need that class after all.

X High level steps:
    X Describe the new algorithm in detail.
    X Prove to myself that this is going to work.
    X Write extensive unit tests for all of the code below.
    X Add new code to filter EdgePoints.
    X Add new code to filter intersecting FaceLineSegments without moving vertices.

X The new algorithm, version two:
    X (1) Merge FaceLineSegment endpoints that are identified as originating
        from the same occluder edge endpoint during the wedge tracing.
        X Do this both for VE wedges and EV wedges.
        X For EV wedges, the endpoint identifier will have to work for
            distant light sources, even though no mesh elements are involved.
        X I think I can extend EndpointOrigin to keep track of this information.
        X Merge all equivalent endpoints to one endpoint position.
            Don't average them, just in case the averaged position is somehow invalid,
            although this seems unlikely.
    X (2) For all line segments with assigned EndpointOrigin edges,
        assign EdgePoints to their corresponding mesh edges.
        X I'll use EndpointOrigin to figure this out, so this means I have
            to go back to the endpoint-origin branch.
        X Line segments whose endpoints both lie on the same mesh edge
            must be marked as 'isColinearWithExistingMeshEdge', so they will
            not be submitted to the CDT.
        X Add EdgePoints that are coincident with existing EdgePoints,
            because I may want to reposition their corresponding 
            line segment endpoints in later steps.
    X (3) Within each edge, merge EdgePoints whose origin was the same wedge.
        X Choose one of the EdgePoint positions as the new position.
            Don't average them.
        X Don't merge EdgePoints that came from the same line segment,
            as would be the case for line segments that were colinear
            with an edge.
    X (4) For all other line segments, test, in 2D, if they exactly intersect
        the face perimeter, and create EdgePoints for them.
        X Line segments whose endpoints both lie on the same mesh edge
            must be marked as 'isColinearWithExistingMeshEdge', so they will
            not be submitted to the CDT.
        X Add EdgePoints that are coincident with existing EdgePoints,
            because I may want to reposition their corresponding 
            line segment endpoints in later steps.
        X The new EdgePoints added in the previous step must be
            taken into account, as well as the new EdgePoints that have been
            added in this step so far,
            when determining the perimeter of the face.
        X I must test for the case when both line segment endpoints
            lie outside the face perimeter, according to exact computation.
            X I'll need an exact 2D polygon inside/outside test
                that can handle concave polygons.
                X It'd probably be enough to test against a line segment
                    from the endpoint being tested to the point at the
                    center of the triangle, or the vertex of the triangle
                    opposite the edge, and use my existing
                    line segment intersection test.
        X Line segments whose endpoints both lie on the same mesh edge
            must be marked as 'isColinearWithExistingMeshEdge', so they will
            not be submitted to the CDT.
        X As new EdgePoints are modified, I must repeatedly loop over the faces
            of the mesh, testing for potential new intersections
            caused by neighboring faces.
    X (5) For each triangle, exhaustively test if any of the perimeter line segments,
        before actually splitting the edges, exactly intersect other perimeter line segments.
        X When this is the case, collapse all edge points between the intersection
            point and the nearest vertex, along the two edges, to that vertex.
            X Snap the line segment endpoints that generated
                these EdgePoints to the vertex as well.
            X Call updateEdgePoints on the two RetriangulatorEdges.
        X Also handle the case when two or more EdgePoints of the same face,
            but on different edges, are coincident.
        X Also handle the case when an EdgePoint exactly intersects another
            line segment of the face, but for which it is not an endpoint of.
        X Also handle colinear line segments along edges.
        X Keep doing this until no remaining non-degenerate perimeter line segments intersect.
        X This modifies the face perimeter, so when this happens, it's necessary
            to repeat steps 4 and 5 again in case new perimeter EdgePoints are added.
    X (6) Split FaceLineSegments that are exactly colinear.
    X (7) Split FaceLineSegments that are exactly intersected by another
        FaceLineSegment's endpoint.
    X (8) Split FaceLineSegments that intersect.

X (1) Merge FaceLineSegment endpoints that are identified as originating
        from the same occluder edge endpoint during the wedge tracing.
   X Remove EndpointOrigin. I'll use EndpointIdentifier instead.
       X Do this by switching back to the exact-meshretri branch.
           X Copy TODO.txt back over.
           X Also merge revision 2785 from endpoint-origin to exact-meshretri.
   X Resurrect EndpointIdentifier, which I removed in revisions 1633, 1634.
       X Record the revision for this in case I need to back it out.
           rt ; svn merge -c -1633 $retro/trunk
           rt ; svn merge -c -1634 $retro/trunk
       X Merge the changes to FaceLineSegment.h,cpp explicitly, since I moved
           them from rfm_discmesh to meshretri.
     mr 
     svn merge -c -1633 $retro/trunk/src/rfm_discmesh/FaceLineSegment.h@1633 FaceLineSegment.h
     svn merge -c -1633 $retro/trunk/src/rfm_discmesh/FaceLineSegment.cpp@1633 FaceLineSegment.cpp
        X I don't need the "is degenerate" function that was in FaceLineSegment.
   X Move EndpointIdentifier from rfm_discmesh to meshretri.
   X Revision 1928 defines WedgeIdentifier, but I'm pretty sure
       I can use a counter instead.
       X Maybe I could bring back this revision and then modify it
           to use DiscontinuityMesher::mWedgeIdentifier,
           which I should probably move to WedgeIntersector.
   X I have both DiscontinuityMesher::mWedgeIdentifier
       and WedgeIntersector::mWedgeIndex, which are redundant. 
       Can one of these be removed?
       X It doesn't look like WedgeIntersector::mWedgeIndex is used any more. Remove it.
   X It looks like EndpointIdentifierToVertexPtrMap is unused. Remove it.
   X I brought back EndpointIdentifier as revision 2800 in the exact-meshretri branch.
   X Do some tests to verify that EndpointIdentifier is actually working as I need it to.
       X When I view the OBJ file output by 'RUN triangles --no-shading',
           there are nearly coincident edges.
       X In Retriangulator::filterFaceLineSegments, I should be able to examine all the
           line segment endpoints, find ones with matching EndpointIdentifiers,
           and print out their coordinates. These should correspond the endpoints
           of the coincident edges in the 'RUN triangles' test.
   X Then go ahead and implement the code for this step, as described above.
       X I could perform this welding step by creating a multimap of
           EndpointIdentifiers to vertices, and then iterating over the map.
       X Before I weld vertices, do an epsilon test to make sure that they
           are actualy close together.
       X 'RUN triangles --no-shading' triangulated output file, before code change:
           47 faces
           75 edges
           31 vertices
       X After:
           27 faces
           45 edges
           21 vertices
       X Write unit tests.

X (2) For all line segments with assigned EndpointOrigin edges,
    assign EdgePoints to their corresponding mesh edges.
    X I got rid of EndpointOrigin, so I'll use EndpointIdentifier instead.
    X Call EndpointIdentifier::getEdgePtr to get the edge. 
        Returns false if there's no edge.
    X Line segments whose endpoints both lie on the same mesh edge
        must be marked as 'isColinearWithExistingMeshEdge', so they will
        not be submitted to the CDT.
    X Add EdgePoints that are coincident with existing EdgePoints,
        because I may want to reposition their corresponding 
        line segment endpoints in later steps.
    X Write unit tests.
    X Write a unit test for the 'isColinearWithExistingMeshEdge' case.
    X Test that this is really working by running 'RUN triangle-four-square'
        and adding print statements to show that edges are being added correctly.

X (3) Within each edge, merge EdgePoints whose origin was the same wedge.
    X Choose one of the EdgePoint positions as the new position.
        Don't average them.
    X Don't merge EdgePoints that came from the same line segment,
        as would be the case for line segments that were colinear
        with an edge.
    X Write unit tests.
    X Do I even need wedge identifiers in FaceLineSegments?
        X Can I use EndpointIdentifiers instead, to identify equivalent EdgePoints?
        X Experiments suggest that yes I can do this.
        X Make sure FaceLineSegment::wedgeIdentifier isn't used for anything else.
        X Switch RetriangulatorEdge::weldEdgePointsCreatedFromCommonWedge
            over to use EndpointIdentifier.
        X Strip out FaceLineSegment::wedgeIdentifier everywhere,
            and everything it depends on.

X 'RUN triangles' fails with:
    Assertion failed: (mType != UNDEFINED), function operator<, 
    file src/meshretri/EndpointIdentifier.cpp, line 201.
    X This implies that EndpointIdentifiers are not getting set in all cases
        when backprojection wedges are traced.

X 'RUN triangle-four-square' fails and the SVG file that is output
    shows that the face perimeter has been modified in a way I've seen before.
    X I brought back revision 2731 from the endpoint-origin branch to fix this.

X Write a function to call EdgePoint::setPosition on all EdgePoints,
    and call it after the FaceLineSegment endpoints have all been moved around,
    but before they have been split.
    X Also get rid of existing calls to setPosition.

X (4) For all other line segments, test, in 2D, if they exactly intersect
    the face perimeter, and create EdgePoints for them.
    X Test as a special case the situation when an endpoint of a faceline segment
        exactly intersects the face perimeter.
    X Don't test line segments for which 'isColinearWithExistingMeshEdge' is true,
        because they're already known to lie on mesh edges.
    X Line segments whose endpoints both lie on the same mesh edge
        must be marked as 'isColinearWithExistingMeshEdge', so they will
        not be submitted to the CDT.
    X Add EdgePoints that are coincident with existing EdgePoints,
        because I may want to reposition their corresponding 
        line segment endpoints in later steps.
    X The new EdgePoints added in the previous step must be
        taken into account, as well as the new EdgePoints that have been
        added in this step so far,
        when determining the perimeter of the face.
    X I must test for the case when both line segment endpoints
        lie outside the face perimeter, according to exact computation.
        X I'll need an exact 2D polygon inside/outside test
            that can handle concave polygons.
            X It'd probably be enough to test against a line segment
                from the endpoint being tested to the point at the
                center of the triangle, or the vertex of the triangle
                opposite the edge, and use my existing
                line segment intersection test.
        X If both endpoints are outside the face perimeter,
            the line segment must be marked 'isColinearWithExistingMeshEdge'.
    X Line segments whose endpoints both lie on the same mesh edge
        must be marked as 'isColinearWithExistingMeshEdge', so they will
        not be submitted to the CDT.
    X As new EdgePoints are modified, I must repeatedly loop over the faces
        of the mesh, testing for potential new intersections
        caused by neighboring faces.
    X Write unit tests.

X Remove the sortEdgePoints call from RetriangulatorEdge::splitMeshEdge
    if it's no longer necessary.

- Write unit tests to ensure that RetriangulatorFace::createEdgePointsFromPerimeterIntersections
    works correctly when there are degenerate spans on an edge.
    We'll be creating these frequently in step 5.

X (5) For each triangle, exhaustively test if any of the perimeter line segments,
    before actually splitting the edges, exactly intersect other perimeter line segments.
    X If none of the face's edge's have EdgePoints, return immediately.
    X Write a function that returns the number of spans on the perimeter of a face.
    X Write a function to return the N'th span for a face.
    X Write a function to return the RetriangulatorEdge associated with the N'th span of a face.
    X Exhaustively test if any of the spans intersect.
        X If the only intersection point is one of the endpoints,
            this is not an intersection.
        X If one span intersects the other at both endpoints,
            this is considered an intersection.
        X If two spans intersect:
            X Find the vertex that is adjacent to both edges of the intersecting spans.
            X For each adjacent edge, starting at the vertex,
                step along the EdgePoints, moving their FaceLineSegment endpoints
                to the same position as the vertex,
                stopping after an EdgePoint of the intersected span for that edge is reached.
            X Update the EdgePoints of the two edges.
            X Break out of the span intersection loop, and retest the face 
                for intersections again.
    X Write a separate set of unit tests for RetriangulatorFace::perimeterSpansIntersect.
        X Test two spans that intersect somewhere along their lengths.
        X Test a span that intersects another span only at a single point.
        X Test a span that intersects another degenerate span somewhere along its length.
        X Test two colinear spans that intersect along their lengths, with no shared endpoints.
        X Test two colinear spans that intersect along their lengths, with one shared endpoint.
        X Test two colinear spans that intersect along their lengths, with two shared endpoints.
        X Test two spans that intersect at a single shared endpoint.
        X Test two colinear spans that intersect only at a single shared endpoint.
        X Test a degenerate span intersecting another span.
        X Test two degenerate spans intersecting.
        X Test two spans that do not intersect.
    X Write unit tests for the whole function.

X 'RUN triangle-square' fails with:
    rfm_discmesh.debug: Shading mesh vertices.
    Assertion failed: (cgmath::GetDistanceFromLineSegmentToPoint2f(edgePoint0, edgePoint1, lineSegmentPoint) < 10.0*mEpsilon), function createEdgePointsFromEndpointIdentifierEdgePtrs, file src/meshretri/RetriangulatorFace.cpp, line 206.
    X What's happening here is that there's a degenerate FaceLineSegment midway along
        one edge of the face. One of it's assigned EdgePtr's is for the edge that
        both line segment endpoints are coincident with, and the other is for one of the
        other edges on the face. This looks like the line segment has been clipped earlier,
        but the FaceLineSegment's endpoint's EndpointIdentifier's EdgePtr is not
        getting reset.
    X Fix all the ifdef'd out tests in rfm_discmesh/test/RegionTest.cpp to ensure
        that the expected EndpointIdentifiers are being assigned.
        X Add a testDifference unit test of this case, where the top line segment
            is fully subtracted away, leaving a single point or no line segment at all.
            // .   .   .   .   . 
            //         +-------+ 
            //     +===========+ 
        X If necessary, write a function in RegionTest to test a span's endpoints,
            which can also handle the case of unique identifiers that are created.
    X It looks like Region::computeDifference's handling of EndpointIdentifiers
        is not the problem. 
        X Starting with the failed assertion, figure out a way to trace backwards
            through the code to the point where the degenerate edge is being calculated,
            to figure out why it's not being assigned the correct EndpointIdentifier.
            X The world space position of both endpoints of the degenerate edge is:
                -0.0978471 3.55387 0.368501
            X When Retriangulator::addFaceLineSegmentToFace is called,
                the FaceLineSegment is already degenerate.
            X Before LineSegmentCollection::calculateVisibleLineSegments is called,
                the endpoints are:
                0.0757453 3.55387 0.124972
                -0.0978472 3.55387 0.368502
                X But after this function is executed, the line segment is degenerate.
            X In LineSegmentCollection::findVisibleLineSegments,
                the span that is output by Region::computeDifference
                doesn't have the EndpointIdentifiers I'm expecting.
            X The weird thing here is that the visibility parameters of the two
                endpoints of the line segment are both nearly 1,
                which, I am guessing, does not match up with the
                world positions of the endpoints, which are very different.
            X The visibility parameters of the endpoints are both 1
                when WedgeIntersector::recordClippableEndpointsAsLineSegment
                is called. (They're not UNDEFINED_VISIBILITY_PARAMETER.)
            X The visibility parameters are both 1 when they are first assigned
                in WedgeIntersector::testTriangle.
                X In this VE wedge, mV is coincident with mQ,
                    and mV, mP, and mQ are all approximately in the plane Y = 0.
                    mV = 1.15729 -2.38419e-07 0.0762264
                    mP = 0.525815 -2.38419e-07 0.962111
                    mQ = 1.15729 2.38419e-07 0.0762264
                X We're shading mesh vertices, so this is a situation
                    where we're trying to shade a vertex on the groundplane
                    that is nearly coincident with some other occluding edge.
                X In the CDT triangulated version of the groundplane in triangle-square,
                    the line segment endpoint at mV/mQ is nearly coincident with,
                    but is distinct from, the endpoint of another line segment.
                    X So, that poses a deeper question. Why are these two particular endpoints
                        distinct, and why aren't they welded together?
                    X Using --debug-lines it looks like it's possible that
                        these two line segment endpoints
                        just happen to be nearly coincident.
                    X Figure out if the two endpoints have the same EndpointIdentifier.
                        X The code in RetriangulatorFace::weldFaceLineSegmentEndpoints
                            suggests that they do not, but add some print statements
                            to make sure that's the case.
                            X This is happending because the EndpointIdentifiers
                                are not considered equal because they have
                                different WedgeIdentifiers, which are getting assigned by
                                Region::createProjectedDifferenceEndpointIdentifier.
                            X So the question now is, what should I be assigning
                                in Region::createProjectedDifferenceEndpointIdentifier
                                instead, to handle the case it's handling,
                                while still keeping EndpointIdentifiers appropriately equal?
                            X Figure out exactly what is going with
                                Region::createProjectedDifferenceEndpointIdentifier
                                and why it is doing what it does.
                                X Wild guess: EndpointIdentifier::setEdgePtrPair
                                    shouldn't swap the endpoint identifiers,
                                    because the order matters, depending on which edge
                                    is doing the clipping. (Probably wrong.)
                                X Would it make sense to store a FacePtr with the
                                    two edges in the EndpointIdentifier, rather than
                                    the WedgeIdentifier, if it's possible?
                                    The FacePtr would be the face that the edges are
                                    projected onto.
                    X Before making that fix, though, I should add code that handles
                       the nearly degenerate wedge case. I don't want this to be
                       a future source of failure. 
                       X Should I simply discard these?
                       X Maybe I want to leave around an assert check for them,
                           because in this case, they were an indicator of another problem.

X 'RUN four-boxes' fails with:
    rfm_discmesh.debug: Shading mesh vertices.
    Assertion failed: (mEdgesAlreadySubmitted.find(std::make_pair(lastPointIndex, firstPointIndex)) == mEdgesAlreadySubmitted.end() && mEdgesAlreadySubmitted.find(std::make_pair(firstPointIndex, lastPointIndex)) == mEdgesAlreadySubmitted.end()), function createPolygonFromRetriangulatorEdgeArray, file src/meshretri/FaceSplitter.cpp, line 528.

X 'RUN temple' fails with:
    rfm_discmesh.debug: Retriangulating mesh.
    rfm_discmesh.debug fatal: CDT input is invalid: Some input edges intersect. The exterior
        perimeter polygon is not counterclockwise.
    Wrote problematic face to "/var/tmp/retriangulator_dump.svg".
    Assertion failed: (0), function triangulate, file src/meshretri/FaceSplitter.cpp, line 596.

X Reconsider the implementation of setWedgeVertexPtr.
    X Rename setEdgePtrPair to setEdgePtrPairAndVertex, and make it another type.
    X Get rid of setWedgeVertexPtr.
    X Get rid of WedgeIdentifier if it's no longer used.
    X Then check this in.

X Make sure Region::createProjectedDifferenceEndpointIdentifier
    works with distant light sources.
    X Test this on 'RUN triangle-square' to be sure.
    X This fails:
        RUN triangle-square --no-em --sun-az 0 --sun-el 60 --sun-di 200 --sun-si 3
        Assertion failed: (position.equivalent( faceLineSegment.worldPosition(endpoint.mEndpointIndex), 10.0*mEpsilon)), function weldFaceLineSegmentEndpoints, file src/meshretri/RetriangulatorFace.cpp, line 181.
        X The positions being compared in the assertion are:
            0.340312 0 1.36566
            0.269601 -9.53674e-07 1.46329

X This now fails during shading with invalid CDT input:
    RUN triangle-square --no-em --sun-az 0 --sun-el 60 --sun-di 200 --sun-si 3 --sun-in 10
    X It's the common problem of a degenerate line segment near
        one of the face vertices.
    X The face perimeter really is folding over itself, very close to the problematic vertex.
    X The problem was that Retriangulator::retriangulateBackprojectionFace
        was calling updateBackprojectionEdgePoints, which was only necessary in an earlier
        version of the algorithm, and was messing up the perimeter edges.

X 'RUN four-boxes' fails during shading with invalid CDT input.
    X It looks like RetriangulatorEdge::updateEdgePoints
        is calculating values of 't' along the edges that are less than ideal.
        X Try implementing this in terms of a dot product instead.
        X The dot product doesn't make any difference at this scale.
    X Step 2 results in line segments that intersect the perimeter,
        but for some reason these are not detected and corrected in later steps.
    X Why isn't Retriangulator::createEdgePointsFromPerimeterIntersections
        detecting the intersections of the line segments with the perimeter?
        X These intersection tests are skipped, because we've already
            added all these line segment endpoints to the perimeter.
    X Maybe I need another step after step 5 that conclusively tests for multiple
        intersections of line segments with the perimeter and collapses neighboring sequences 
        of EdgePoints until this isn't the case.
        X First add some code so that'll dump an SVG file of the problematic face,
            even after I've corrected it, so I can see what my fix actually does.
        X For each edge, for each EdgePoint, test if the associated line segment
            intersects any of the other spans along the edge. If it does,
            collapse the span's two EdgePoints to the original EdgePoint.
            Leave mesh vertices unmodified.

X 'RUN coplanar' fails an assertion.

X 'RUN pile-of-boxes' fails on bad CDT input.
    X Somehow, it winds up with a face whose perimeter self-intersects.
    X I'd expect that Retriangulator::filterFaceLineSegments
        would have corrected this already.
    X Write a function that tests if the perimeter of the particular face 
        I'm interested in self-intersects.
        X Call this function at each step of Retriangulator::filterFaceLineSegments.
        X See where the self-intersection arises.
    X The problematic face is in mAdditionalRetriangulatorFaceVector,
        not mRetriangulatorFaceVector, so no attempt is being made to
        check for self-intersections and correct them.

X 'RUN pile-of-boxes' now runs, but is too aggressive when it
    corrects for intersections. It's essentially discarding critical line segments.
    X The problem is the code I added to FaceSplitter::createEdges
        that discards FaceLineSegments that are colinear with existing mesh edges.
        This value seems to be getting set incorrectly.        

X 'RUN pile-of-boxes' now fails with a CDT error.
    X The problem is that at a small scale, there is line segment that straddles
        and intersects and existing mesh vertex. It would get filtered out if
        if its endpoints where coincident with unique edges, but they're not.

X 'RUN cylinders' fails an assertion.

X 'RUN four-boxes' has a light leak on the back side in the shadow.

X 'RUN contact-shadow-d0-coincident' has huge light leaks.

X 'RUN four-boxes' fails with a CDT error.
    X The problem is that there is a line segment with one endpoint on a mesh edge
        very close to a mesh vertex, and the other endpoint intersects
        the other mesh edge adjacent the mesh vertex.
    X For some reason, this case is not being detected and dealt with appropriately.
    X Here's what I should do:
        X Wire up the code so I do before/after comparisons of what happens
            with this code change.
        X For each edge-adjacent line segment that I know doesn't already intersect
            an edge at its other endpoint, test if it intersects an edge span
            somewhere alongs its midsection.
        X If I find such an intersection, collapse the original endpoint as follows:
            X If the span is on the same edge, collapse the endpoint with
                all edges between the original endpoint and the intersected span.
                X I'm already handling this case.
            X If the span is on another edge, collapse the endpoint with
                all edges between the original endpoint and mesh vertex that the
                other edge and the original edge have in common.

X 'RUN four-boxes' fails with a CDT error.
    X The perimeter self-intersects at a single point at span endpoints.
    X I need a function like correctSelfIntersectingFacePerimeter
        but that compares EdgePoint positions of edges against those of other edges.
    X Rename correctSelfIntersectingFacePerimeter to
        correctSelfIntersectingFacePerimeterLineSegments.
    X Call the new function correctSelfIntersectingFacePerimeterEdgePoints.

X 'RUN well' gets stuck in an infinite loop retriangulating the mesh.

X 'RUN two-cubes' gets stuck in an infinite loop shading mesh vertices.

X 'RUN eight-cubes' gets stuck in an infinite loop shading mesh vertices.
    - RetriangulatorFace::correctSelfIntersectingFacePerimeterLineSegments loops forever.
    - There are intersecting perimeter edges that are colinear and coincident.
    - Write RetriangulatorEdge::getFarthestEdgePointFromSpan,
        and use that in the case when the two line segments are colinear.

X 'RUN pile-of-boxes' fails an assertion.

X 'RUN coplanar' fails an assertion.

X 'RUN eight-cubes' runs out of memory and fails.

X This has artifacts because two faces aren't being triangulated properly:
   RUN four-boxes --no-em --sun-az 135 --sun-el 60 --sun-sides 12
   X It's as if two EdgePoints are being discarded.
   X The first incorrectly triangulated face is:
       -0.511984, 1, 1.24512
       0.488016, 1, 0.245116
       0.488016, 1, 1.24512
   X The second incorrectly triangulated face is:
       -0.511984, 1, 1.24512
       0.488016, 1, 0.245116
       -0.511984, 1, 0.245116
   X correctSelfIntersectingFacePerimeterLineSegments is collapsing
       edge points too aggressively.
       X It wasn't correctly handling spans that intersected
           but where on the same mesh edge.
   X I think that just like RetriangulatorEdge::weldEdgePointsCreatedFromCommonWedge,
       I should weld together EdgePoints that have
       exactly the same value of 't'.
       X Print out the edge points and their 't' values first to make sure
           this would actually help.
       X Yes, this is the problem. The EdgePoints all have the same 't',
           even in double precision.

X This was the original case I encountered on July 5.
    RUN four-boxes --no-em --sun-az 135 --sun-el 60 --sun-sides 12

X 'RUN eight-cubes' now fails an assertion. It's trying to weld together
    two EdgePoints on the same edge.
    X 'RUN temple' also fails in this way.
    X These both occur while shading.

X 'RUN coplanar' fails.

X 'RUN wall' gets stuck in a loop.

X Start debugging the light leaks by looking at 'RUN contact-shadow-d0-coincident'.
   X At the two D0 vertex positions, there are (probably nearly) coincident
       pairs of vertices on the groundplane, rather than the one vertex
       we're expecting, and this is causing the creation of degenerate faces
       in the groundplane.
   X The contact-shadow-d0-coincident model is a single 
       set of connected faces. The cube is not sitting atop the groundplane,
       as in 'contact-shadow'.
   X So, somehow, another vertex is begin created immediately adjacent
       to the original D0 discontinuity vertices.

- If I implement exact D0 vertex tracking,
    do I really need EdgeIntersector::snapClippableEndpointToPQ
    and EdgeIntersector::snapClippableEndpointToV?
    Maybe they're doing more harm than good.

- DiscontinuityMesher::traceWedge loops over all the faces in the scene.
    This should be accelerated using an AABB tree.
    - However, the algorithm is grossly dominated by the shading time,
        so maybe it's not really worth it.

X 'RUN pile-of-boxes' seems to have more fundemental problems, so I'm trying to
    fix it first.
    X Here are the two triangles I'm interested in:
    X (A) left
        -0.603634, 1.57123, 0.500869 (top vertex)
        -0.72346, 1.14643, 0.5 (lower left vertex)
        -0.414565, 1.254, 0.503 (right vertex)
    X (B) right
        -0.603634, 1.57123, 0.500869 (left top vertex)
        -0.414565, 1.254, 0.503 (left bottom vertex)
        0.27754, 1.254, 0.503 (right vertex)
    X I'm wondering if in DiscontinuityMesher::traceWedge, rather than rely on
        an epsilon test to determine D0 discontinuity,
        I could calculate this information exactly in WedgeIntersector
        in WedgeIntersector::clipToVeWedge (which is also used for distant light EE events).
        X Could I also snap the world space line segment endpoint
            position here exactly, and bypass the clipping
            which might mess it up?
        X Before trying this, I'd like to verify that it would actually help.
    X It looks like the wedge to world space transformation performed
        by LineSegmentCollection::findVisibleLineSegments is moving
        the line segment endpoints away from the vertices that they
        were already coincident with.
    X It's worse than that. Here is what findVisibleLineSegments does:
        X Each span's parameteric 'S' values are transformed into world space coordinates.
        X The world space coordinates are used to calcuate wedge space coordinates.
        X The wedge space coordinates are transformed back into world space.
    X In LineSegmentCollection::findVisibleLineSegments, it looks like the input
        visibilityParameters are often exactly 0 or 1.
        X So, maybe I could handle the cases where the span endpoints
            are exactly 0 and 1 by copying the line segment endpoints directly,
            without any extra transformation.
        X I added experimental code for this to LineSegmentCollection::findVisibleLineSegments
            but left it #ifdef'd out because it didn't solve the whole problem.
    X I should probably map out the flow of line segments from WedgeIntersector
        through LineSegmentCollection, detailing where deviations occur from    
        the exact P and Q vertex positions.

- See the TODO in WedgeIntersector::testTriangle and test if it's safe to
    discard the degenerate line segments created by faces that only intersect
    the wedge at a single point.

X If in MeshShader::shadeFaceVerticesAdjacentToVertex I force it to shade all
    verticies as if they were D0 discontinuities, it introduces a lot of artifacts.
    X I should probably spend some time to try to improve the behavior of the
        code in this case. It's possible it's screwing up the D0 vertices
        and I might not be noticing.
    X I think this can never work. I think the "halfway to center" testing I'm doing
        is only valid for D0 vertices, because of the degenerate situation they represent.

X I experimentally wrote DiscontinuityMesher::snapFaceLineSegmentEndpointsToFaceVertices
    to weld all FaceLineSegmentEndpoints to nearly-coincident mesh vertices,
    but I still see artifacts in 'RUN pile-of-boxes'.
    X Keep calling snapFaceLineSegmentEndpointsToFaceVertices, 
        and then do an SVG dump of that face on the left side,
        to see exactly what's going on near the upper right vertex
        that winds up creating a gap in the mesh, before the face is retriangulated.
    X The left triangle is:
        -0.414565, 1.14842, -0.497
        -0.414565, 1.002, 0.287669
        -0.414565, 1.14842, 0.503
    X The right triangle is:
        -0.414565, 1.002, 0.287669
        -0.414565, 1.14842, 0.503
        -0.414565, 1.002, 0.75
    X It looks like by the time FaceSplitter is invoked, mesh edges have been
        split exactly at existing mesh vertices, creating duplicates.
        X It's possible these are causing problems later.
    X MeshShaderFaceListener::allowFaceIntersectionTest shouldn't have been
        ignoring all faces adjacent to mLocalVertexToIgnore, because in the case
        of D0 vertices, some of these faces were potential occluders.

- LineSegmentCollection::findLineSegmentIntersections calculates 't' values along
    line segments using calculations that could probably benefit from being
    converted over to doubles.

- LineSegmentCollection::findVisibleLineSegments calculates 't' values and could
    be improved by switching to doubles.
    - I should probably write InterpolateVector2d for this as well.

- Could WedgeIntersector::transformWorldSpacePointToWedgeSpacePoint
    and transformWedgeSpacePointToWorldSpacePoint be improved by
    temporarily switching to doubles for the calculation?
    - Maybe mWedgePositiveXAxis and related vectors should be
        stored as Vector3d's.

- It'd be a good idea to look through WedgeIntersector and LineSegmentCollection
    and check for code where use of single precision could be a problem,
    and consider converting it to double precision.

- WedgeIntersector could be improved by converting mWedgePositiveXAxis, etc.
    to Vector3d's, and making alternate double precision versions of functions
    like GetIntersectionOfLineWithPlane, to improve accuracy.
    - This would help transformWorldSpacePointToWedgeSpacePoint
        and transformWedgeSpacePointToWorldSpacePoint as well.

- How are line segments that arise from D0 discontinuity vertices dealt with now?
    - DiscontinuityMesher::traceWedge is called for these four cases:
        - VE event where one endpoint of edge PQ is a D0 vertex.
        - EV event where V is a D0 vertex.
        - Distant EE event where one endpoint of edge PQ is a D0 vertex.
        - Distant EV event where V is a D0 vertex.
    - DiscontinuityMesher::traceWedge calls WedgeIntersector::testTriangle
        on every face in the scene, and builds a LineSegmentCollection
        of all the resulting line segments formed by the intersection
        of the faces with the wedge.
        - WedgeIntersector::testTriangle calls WedgeIntersector::testTriangleVertices,
            which will pass on the D0 vertex,
            and assigns it an EndpointIdentifier of type ONE_VERTEX_POINTER.
            - This could be true of other triangle vertices as well, and not only
                those that have vertices coincident with edge PQ.
            - !!! Perhaps at this point, we could verify that points A, B, or C
                of the triangle are coincident with P or Q,
                and if so, piggyback on the EndpointIdentifier
                the coordinates of the wedge endpoint that the point is
                coincident with.
                - !!! On the other hand, piggybacking this information
                    is pretty bad design.
                - !!! If I could ensure that these values were copied around correctly,
                    or reset when necessary 
                    (as in Region::createProjectedDifferenceEndpointIdentifier),
                    then later I could use them to ensure that the corresponding
                    line segment endpoint remains coincident with
                    the mesh edge endpoint.
            - WedgeIntersector::testTriangle calls WedgeIntersector::clipToVeWedge 
                and WedgeIntersector::clipToEvWedge.
                - WedgeIntersector::clipToVeWedge and WedgeIntersector::clipToEvWedge
                    both clip the endpoints to the planes bounding the wedge,
                    reassigning the EndpointIdentifiers if this occurs.
                    - !!! This would discard any data we had piggybacked
                        on the EndpointIdentifiers earlier.
                    - !!! So, what we'd like to do is examine inputCe0.mId
                        and inputCe1.mId and determine if they were coincident
                        with P or Q. If that's the case, leave them alone
                        and don't attempt any further clipping.
                        - !!! In the case of clipToVeWedge, though,
                            we'd still like to do the big test for faces that
                            lie in the plane of PQ.
    - DiscontinuityMesher::traceWedge calls LineSegmentCollection::calculateVisibleLineSegments.
        - LineSegmentCollection::calculateVisibleLineSegments calls findLineSegmentIntersections.
            - This calculates the intersections of the wedge space line segments,
                and creates unique EndpointIdentifiers for them.
            - The 2D wedge space coordinate of the intersection point is mapped to
                a world space coordinate using
                WedgeIntersector::transformWedgeSpacePointToWorldSpacePoint.
        - LineSegmentCollection::calculateVisibleLineSegments calls splitLineSegments.
            - Creates new line segments from the split points.
            - Sets visibility parameters for the new line segment endpoints
                using WedgeIntersector::projectPointOntoEdgePQ.
        - LineSegmentCollection::calculateVisibleLineSegments calls sortLineSegments.
            - Sorts the line segments.
        - LineSegmentCollection::calculateVisibleLineSegments calls findVisibleLineSegments.
            - In front to back order (in terms of visibility), 
                calls Region::computeDifference repeatedly, subtracting away each new
                line segment from the region that is already known to be visible.
                - ???
            - Given the clipped spans in the region within the line segment,
                the parametric values of their endpoints are used to project
                the points into wedge space along edge PQ,
                and from there they are transformed back into world space.
                - This must be a pretty lossy operation.
                - For now I put in a hack that maps span parameters 0 and 1
                    back to the exact world space coordinates of the
                    line segment endpoints.
                    - This failed some assertions I put in, in the case of backprojections,
                        which I ignored, which was probably a bad idea.
    - DiscontinuityMesher::traceWedge calls FaceLineSegment::setIsDegreeZeroDiscontinuity
        on the endpoints of the FaceLineSegment that lie
        within an epsilon distance of the mesh edge that the wedge was traced through,
        assuming it was a VE or distant EE event.
        - !!! Is this really what I want? Is it possible I could determine which
            vertices were D0 explicitly, without the epsilon test?
    - DiscontinuityMesher::traceWedge projects the line segments onto the faces
        they lie in, and calls Retriangulator::addFaceLineSegmentToFace.

- I'm suspicious that MeshShaderFaceListener::allowFaceIntersectionTest
    ignores backfacing polygons. Is that really a good idea?
    Why does it do that? At least figure out why and comment it.

X 'RUN contact-shadow-d0-coincident --mark-d0-vertices' has vertices marked as D0
    that probably should not be.
    X 'RUN four-boxes' has these as well. 
    X Figure out where they're coming from and fix them.

- Figure out why the assert calls I commented out in 
    LineSegmentCollection::findVisibleLineSegments were failing.
    - There's probably an important reason, and I don't want to mask any errors.

X This has a light leak:
    RUN temple --no-emissive --sun-azimuth 40 --sun-elevation 50 --sun-sides 12

X This fails an assertion:
    RUN pile-of-boxes --no-emissive --sun-azimuth 45 --sun-elevation 90 \ 
        --sun-sides 24 --sun-angular-diameter 1000 

- This has discontinuous shading on the concave portion of the model:
    RUN well --no-emissive --sun-azimuth 40 --sun-elevation 50 --sun-sides 12 

X This fails with a CDT error:
    RUN four-boxes --no-em --sun-az 60 --sun-el 90 --sun-sides 12

X This has light leaks:
    RUN cylinders --no-em --sun-az 45 --sun-el 80 --sun-sides 12 
    X At 0.124999, 0, 1.23429 
      and 0.125, 0, 1.23429, 
      there are two vertices on the groundplane that are nearly coincident,
      and it's probably the case that only one of them is marked as a D0 discontinuity.
    X Which features generate these line segment endpoints?
    X Do they have anything in common?
    X Either I have to rig the computation so that they're computed
        at exactly the same location, or I have to find some way
        of knowing to merge only those kinds of vertices,
        or making sure that both vertices are marked as D0 discontinuities.
    X Bumping up the epsilon used to mark vertices as D0 discontinuous
        in DiscontinuityMesher::traceWedge by a factor of 100 makes the vertices
        get shaded correctly. So, it'd be enough to make my D0 discontinuity
        testing more robust, and not rely on the epsilon test, if that's possible.
    X Three line segments have their endpoints at this location.
        Two of them are exactly at 0.125, 0, 1.23428797722,
        and have equal endpoint identifiers of type ONE_VERTEX_POINTER.
        The third endpoint is at 0.124998807907 9.53674316406e-07 1.23428821564
        and has a unique endpoint identifier, which is assigned
        when the line segments in the wedge are clipped against
        each other. Its original endpoint identifier was 
        of type EDGE_POINTER_AND_INDEX.
    X The problem was MeshShaderFaceListener's epsilon value, which was too large
        by a factor of 1000, which was causing a ray test to fail.
        The vertex at 0.124998807907 9.53674316406e-07 1.23428821564
        really was not supposed to be D0, because it was just inside the cylinder,
        but since it was so close to the nearest face of the cylinder, and the value
        of epsilon was large, the ray test against the face was failing.
    X This leaves me very suspicious of this epsilon test.
    X Why do I even need it in this case? I'm already testing against all of the
        faces adjacent to the vertex.
    X Maybe a solution is, in MeshShaderFaceListener::allowFaceIntersectionTest,
        only perform the t <= mEpsilon test if mLocalVertexToIgnore isn't defined.
    X I'm having trouble imagining cases where I need the epsilon test at all,
        but I thought that earlier I tried commenting it out, and that
        caused lots of problems.

X This has light leaks on the back side:
    RUN four-boxes --no-em --sun-az 180 --sun-el 80 --sun-sides 12 
    X The light leak connects to a face on the front edge of the box,
        which looks like it should either be D0, or should be
        considered fully in shadow.
    X The vertex is at 0.789832, 0, 1.29684.
    X It appears to be coincident with the bottom edge of the box.
    X There are actually two vertices at this location, at these coordinates:
        0.789831876755 1.90734863281e-06 1.29683637619
        0.789831876755 1.90734863281e-06 1.29683589935
    X Neither of these vertices seems to be initially marked as a D0 discontinuity
        in DiscontinuityMesher::traceWedge, although --mark-d0 seems to suggest
        that they both are later on. This doesn't seem to make much sense though
        because they're certainly not shaded as if they are D0.
    X MeshShader::shadeFaceVerticesAdjacentToVertex indicates that there are
        four vertices at this location, and only two of them are D0.
        X Figure out why DiscontinuityMesher::traceWedge outputs
            two vertices, but MeshShader::shadeFaceVerticesAdjacentToVertex
            references four vertices.
        X The two vertices which are not D0 have the same coordinates of the
            two listed above, which were not D0 then either.
        X There really are four vertices here when I view the model
            afterward is Silo. Three of the vertices are on the groundplane,
            and one is part of the box.
        X If I zoom in, what's going on is that there are two line segments
            that follow the edge, and a third that intersects them both,
            extending out a little bit, and this results in three vertices.
            I'll bet the two intersections points are not D0 discontinuities.
        X How could I address this?
            X Rather than computing the intersection points in these cases,
                I could detect that the endpoint lies within an epsilon distance
                of the other line segments, but farther away than that
                distance from their endpoints, and then run those line segments
                through the original endpoint, rather than splitting
                the line segments.
                X If this is going to work in this case, it assumes that 
                    the original endpoint is D0, but I don't think it is.
        X Out of these three points, I'd like to know
            which ones are marked D0 and which are not.
        X Oh this does make sense, because the line segment with the non-D0 endpoint
            is coming in from outside the box, so it's the vertex that's
            being lit incorrectly and extending back under the box.
            X Since the endpoint is so close to the two edges which I am assuming are D0,
                it certainly seems as though it should be marked D0.
            X Since that edge is probably being clipped by an edge which is a D0
                discontinuity, it'd be great if there was some way of marking it 
                as D0 as well. Is this possible? When I clip that line segment,
                do I know that the other line segment is D0?
        X It seems to me that the line segment leading into the underside of the box
            should be marked as D0. Determine why it is not.
            X When that edge is chosen as edge PQ of a wedge, even though it is clipped
                by the face of the box above it, its endpoint should
                still be marked as D0, right?
            X The two endpoints of the line segment leading up to the box are:
                0.789832, 0, 1.38329
                0.789832, 0, 1.29684
            X These endpoints are not marked as D0.
            X The wedge PQ edge that creates them is at Y=2, far above the plane.
            X There must be some other way of determining that the vertex adjacent
                to the box should be marked D0.
            X If I add a hack to force these two endpoints to be D0,
                then the face vertices are shaded correctly.
            X If I could find some way of correctly marking these edges as D0,
                it would probably solve this problem.
            X One way to do it would be to mark as D0 all FaceLineSegment endpoints
                that lay within an epsilon distance of other FaceLineSegments
                whose endpoints were both D0.
                X I tried this and it didn't work.
                X Figure out why this didn't work. Are the endpoints of the
                    two adjacent face line segments near the endpoint not both D0?
                X If I run this with --mark-d0, it certainly seems as though
                    the intersected line segment endpoints are D0.
                X Add print statements to show exactly what is going on with
                    the endpoints of the line segments I'm interested in.
    X Figure out an entirely new way of determining D0 vertices,
        giving it a little more thought.
        X Make a list of the points in the code where
            setIsDegreeZeroDiscontinuity is being set.
        X Investigate getting rid of that code, and determining D0
            discontinuities in LineSegmentCollection, and returning the results in
            LineSegment, which would then get passed to FaceLineSegment.
        X I guess I'd still have to set D0 discontinuities when FaceLineSegments
            intersected each other.
        X D0 vertices are caused by:
            X Intersection of wedge line segments with edge PQ.
            X Points where wedge line segments intersect, or nearly intersect, each other.
    X Here's what to do:
        X To Endpoint, add setIsDegreeZeroDiscontinuity and isDegreeZeroDiscontinuity.
        X To WedgeIntersector::ClippableEndpoint, add mIsDegreeZeroDiscontinuity,
            and have it set to false in the ClippableEndpoint's constructor.
        X To WedgeIntersector::clipToPlane, add an argument that indicates that if
            the line segment is clipped, the endpoint created at the clipped plane
            will be marked as D0.
        X Update all clipToPlane calls.
        X In clipToVeWedge, in the case where the face intersects edge PQ,
            make sure both endpoints are marked D0.
        X Make sure any endpoint near edge PQ, or near P or Q, is marked D0.
            X I'm already doing this in my existing code.
        X In recordClippableEndpointsAsLineSegment, pass along the D0 values
            from ClippableEndpoint to the Endpoint variables.
        X Before the call to LineSegmentCollection::splitLineSegments,
            add another function that detects when line segments have endpoints
            that nearly intersect other line segments in wedge space, 
            and mark them as D0.
            X I need an epsilon value for the wedge.
        X In LineSegmentCollection::splitLineSegments, assign D0 discontinuities
            to the intersection points.
            X Make sure the D0 value of the first and last points are set correctly.
            X Make sure line segments that meet at a single point are not marked D0.
        X In DiscontinuityMesher::traceWedge, add calls to setIsDegreeZeroDiscontinuity
            so that they set these values if the corresponding LineSegment 
            endpoint is D0.
            X Don't get rid of my existing setIsDegreeZeroDiscontinuity calls,
                because I rely on them to mark D0 points that are near edge PQ,
                but do not strictly intersect it.
        X LineSegmentCollection::findVisibleLineSegments needs to track 
            the D0 discontinuity flags. 
            X Modify Region to support D0 flags.

X This has a funny overhanging shadow artifact:
    RUN four-boxes --no-em --sun-az 185 --sun-el 80 --sun-sides 12 
    X The artifact is because there are discontinuity line segments missing.

X This has light leaks:
    RUN two-slabs --sun-az 180 --sun-el 38 --sun-sides 12 --sun-diam 90

X This has a funny overhanging shadow artifact in the front:
    RUN four-boxes --no-em --sun-az 190 --sun-el 75 --sun-sides 12 

X This has light leaks:
    RUN cylinders --no-em --sun-az 45 --sun-el 80 --sun-sides 12 

X This has a light leak in the back:
    RUN four-boxes --no-em --sun-az 180 --sun-el 80 --sun-sides 12 

X This has a light leak:
    RUN two-slabs --sun-az 180 --sun-el 38 --sun-sides 12 --mark --sun-diam 100 

- This has an awful dark leak on the back side:
    RUN_OPT teapot --sun-az 95 --sun-el 70 --sun-sides 6 
    - The rest of the errors are probably due to intersecting faces,
        which I explicitly don't handle.

X Rename exact::TestPointIntersectsLineSegment2f and TestPointIntersectsLine2f
    to match the order of their arguments.

- When I use the --mark-d0 flag, it seems to eat up much more memory
    than I would expect.

X This has a big light leak on the left side.
    RUN temple 
    X The incorrectly lit vertex is at:
        -0.52908, 0.0, -1.34264
    X If I force all vertices near this point to be D0, the model is shaded correctly.
    X It looks like there are four unique vertices here:
        -0.529080867767 4.76837158203e-07 -1.34263658524
        -0.529080867767 0 -1.34263634682
        -0.529079914093 -4.76837158203e-07 -1.34263706207
        -0.529080569744 4.76837158203e-07 -1.34263658524
    X The first and third vertices are not D0, but the second and fourth are D0.
        X Figure out why this is.
    X One hacky approach would be to find the vertices adjacent to all D0 vertices
        and mark them as D0 as well.
        X However, it'd be best to figure out what is really going on with
            these vertices first.

X This has superfluous D0 points on the groundplane I can't explain.
    RUN eight-cubes --mark-d0

X This has a light leak:
    RUN two-slabs --sun-az 180 --sun-el 38 --sun-sides 12 --sun-diam 399

X This has missing faces: (!)
    RUN contact-shadow --no-em --sun-az 0 --sun-el 0 --sun-sides 12 
    X This happens because RetriangulatorFace::createEdgePointsFromEndpointIdentifierEdgePtrs
        thinks that two of the line segment endpoints on the groundplane face,
        coincident with the box's base, are associated with the far edge,
        as determined by EndpointIdentifier::getEdgePtr, which is clearly wrong.
    X The line segments of the endpoints in question are degenerate.
    X I determined that these edge associates must be made
        in WedgeIntersector::testTriangleEdges. It's the only place that
        EndpointIdentifier::setEdgePtrAndIndex is being called.
        X However, it's possible these are being copied somewhere else.
    X I fixed this with an epsilon hack  
        in RetriangulatorFace::createEdgePointsFromEndpointIdentifierEdgePtrs,
        and this will probably come back to haunt me later.

X This fails with a CDT error:
    RUN two-slabs --sun-az 180 --sun-el 38 --sun-sides 12 --sun-diam 400
    X The problematic face is:
        -3.00000071526, 9.04833889008, 9.26366138458 
        -3.43798422813, 9.6461315155, 8.79661464691 
        -3.00000071526, 9.73861026764, 8.72436237335 
    X The problem here looks like there's one line segment that intersects
        perimeter edges, but stretches from one mesh vertex to another,
        and so is probably immune to being collapsed 
        in RetriangulatorFace::correctEdgePointsFromLineSegmentIntersections.
        X It's worse than that. That line segment isn't being considered
            because correctEdgePointsFromLineSegmentIntersections only tests
            line segments that are associated with EdgePoints,
            and the line segment in questions stretches from one edge vertex to another.
    X Oh, how about, when there are line segments that stretch from one vertex to another,
        I could simply collapse them to one of the two vertices?

X With the above fix, this fails with another CDT error:
    RUN two-slabs --sun-az 180 --sun-el 38 --sun-sides 12 --sun-diam 400
    X The problematic face is:
        -3.00000095367 9.0483379364 11.5313444138
        -3.00000095367 9.73860931396 10.9920454025
        -2.56201767921 9.64613056183 11.0642976761
    X It looks like there are line segments that are coincident with the perimeter
        and straddle points on the perimeter.

X Outstanding significant problems:
    X Occasionally there are missing discontinuity edges:
        X RUN contact-shadow --no-em --sun-az 0 --sun-el 0 --sun-sides 12  
        X RUN four-boxes --no-em --sun-az -45 --sun-el 60 --sun-sides 12  
        X RUN four-boxes --no-em --sun-az 185 --sun-el 80 --sun-sides 12 
    X In MeshShaderFaceListener::initialize, an epsilon value is computed,
        and the behavior of MeshShaderFaceListener::allowFaceIntersectionTest
        is very sensitive to the choice of this value.
        If the value is too large or too small, light leaks or dark
        leaks will occur where independent sets of mesh geometry
        are in contact with each other but are not connected
        (e.g. a box sitting on a tabletop).
        X These scenes are sensitive to errors:
            RUN temple
            RUN two-slabs --sun-az 180 --sun-el 38 --sun-sides 12 --mark --sun-diam 90 
        X I need a robust way of dealing with this problem.
        X It's entirely possible that the only way to deal with this is to
            create a preprocess that detects all mesh intersections
            and to subdivide and connect the mesh as necessary to ensure
            that it is clean.

- Go back over each case where I perform epsilon tests and see if there's
    any way that I can restructure the problem so that it is exact or symbolic.

X This has missing discontinuity line segments:
    under the overhanging box in the back.
    RUN four-boxes --no-em --sun-az -45 --sun-el 60 --sun-sides 12 
    X The vertices of this face are:
        0.524614, 1, 0.763605
        0.969949, 0, 1.65897
        0.969949, 1, 1.65897
    X The two line segments are breaking
        in RetriangulatorFace::correctEdgePointsFromLineSegmentIntersections.
    X Instrument RetriangulatorFace::correctEdgePointsFromLineSegmentIntersections
        to determine exactly which code is making this modification.
        X The error is in the final call to weldEdgePointRangeToPoint
            in this function. Commenting this block of code out makes the
            artifact go away and restores the missing discontinuity edge.
    X I think the problem is that we're considering a line segment leading away from
        the right edge down to the bottom edge, and that's where it's 
        intersecting a perimeter edge.
    X If I can't fix this test, could I defer it until later?
    X What's happening is that even though the intersection point is near the lower edge
        of the face, it's welding points on the right edge, and welding them all the way
        to the bottom right vertex, which effectively destroys the line segments
        I care about.
    X I'd like it to only weld together the two vertices near the intersection point
        on the lower edge.
    X Even if I can write the code to do that, the problem is that I don't know if I still
        have other test models that rely on the original behavior.
    X I need to come up with a new behavior that is more accurate overall.
    X I'm just ripping out this code for now.
    X My guess is that in the past it was needed to handle intersection cases
        while shading, but now that case is being handled by the final test
        that throws away line segments.
    X This is all very worrisome.

- RetriangulatorFace::correctRemainingLineSegmentPerimeterIntersections is too dangerous.
    I must modify it so that it does not discard line segments, but snaps edge points instead.
    If I don't, I'm sure it'll come back to bite me later.

X This has dark leaks:
    RUN two-slabs --sun-az 180 --sun-el 38 --sun-sides 12 --sun-diam 90
    X It's probably caused by the epislon test problems in the ray firing code.

X This has missing discontinuity line segments:
    RUN four-boxes --no-em --sun-az 185 --sun-el 80 --sun-sides 12 
    X The vertices of the broken face are:
        0.969949, 1, 1.65897
        1.86531, 0, 1.21363
        0.969949, 0, 1.65897
    X The line segments are missing even before Retriangulator::filterFaceLineSegments
        is called.
    X If I run rfm_discmesh with the --debug-lines flag, I don't see the line segments.
    X The endpoints of the missing line segments are:
        1.15845, 0, 1.56521
        0.969949, 0.549152, 1.65897
        and
        1.17737, 0, 1.5558
        0.969949, 0.573771, 1.65897
    X The wedge edge being projected is:
        0.79958, 1, 1.73594
        1.29958, 1, 1.73594
    X At least one of the edge's we're looking for (the first one)
        is output from WedgeIntersector::testTriangle.
    X The line segment is disappearing inside 
        LineSegmentCollection::calculateVisibleLineSegments.
    X The line segment is disappearing inside 
        LineSegmentCollection::findVisibleLineSegments.
    X However, the problem must be in LineSegmentCollection::sortLineSegments.
        The order of the line segments must be wrong going into findVisibleLineSegments.
    X I have to identify the line segment that is being sorted incorrectly,
        and see where the code is making the wrong decision.
    X LineSegmentCollection::sortLineSegments thinks that the problematic edge
        and another edge are mutually occluding.
        X The comments say that this should only happen if the two line segments
            are colinear, but that clearly is not the case.
        X Their endpoints nearly intersect. Perhaps what's happening is that
            when the line segments are split against each other,
            the resulting line segments still intersect,
            because of floating point error.
    X I think the problem is that it's possible that if I split line segments
        given the intersections detected by cgmath::LineSetIntersector,
        it's entirely possible that the resulting line segments
        still intersect, because of floating point error.
    X Oops, wait, the fix I made to LineSegmentCollection::sortLineSegments
        probably isn't good enough for all cases. Just because one vertex is closer
        to the light source doesn't mean that one edge occludes the other.
        X What I want to do is find which two endpoints are closest to each other,
            and then look at the other two endpoints to decide which edge
            is in front of the other.

** Handle approximated concave curved surfaces with vertex normals by projecting nudged vertices
    in DiscontinuityMesher::shadeFaceVerticesAdjacentToVertex onto the plane
    that passes through the vertex normal.
    - This should improve how the 'well' model looks inside the well's concave surface.
    - Make a simple test with a concave curved surface.

X Write rfm_cat.
    X Write mesh::Concatenate.
    X How's this going to work?
    X Loop over all vertices, edges, and faces of the source mesh.
        X Create clones of these mesh elements in the target mesh.
        X Create maps of source mesh elements to target mesh elements.
        X When copying attributes, I have to map source attribute keys
            to target attribute keys.
    X Don't forget to copy face vertex attributes.
    X What about mesh material attributes and mesh element material index attributes?
        X I'd like to reuse material definitions that match, but resolve conflicting
            material and texture indices.
        X To really verify that whatever I implement is working,
            I should add an option to rfm_print to print out all the
            materials and textures, along with a count of how many
            faces have them assigned.
    X Comments at the top of src/mesh/StandardAttribute.cpp imply that
        if an AttributePossessor has an integer attribute called foo,
        we can assume that any index table of attributes of the form "foo.<int>.<string>"
        are indexed by that value.
        X To generalize mesh::Concatenate to future tables of data,
            I could write it in such a way that it follows this convention.
            However, the behavior of the material table should really
            take the material names into account.
    X I decided to blow this off and not merge materials and textures for now.

X Do a series of timing tests of progressively larger models, procedurally generated,
    to see how the running time relates to the size of the input models.
    X Graph the results.
    X Write rfm_trans
    X Write rfm_cat
    X Write a Python script to generate the test models.

X In src/sandbox/discmesh_perf_test/output, model.16.wrl has a missing polygon
    in the back center.

X In src/sandbox/discmesh_perf_test/output, model.15.wrl has several bogus polygons
    in the back.

X In src/sandbox/discmesh_perf_test/output, model.14.wrl has several missing polygons
    in the back.

X In src/sandbox/discmesh_perf_test/output, model.13.wrl has several bogus polygons
    in the back.

X In src/sandbox/discmesh_perf_test/output, model.10.wrl has several bogus polygons
    in the back.

X In src/sandbox/discmesh_perf_test/output, model.8.wrl has several bogus polygons
    in the back.

X In src/sandbox/discmesh_perf_test/output, model.7.wrl has several bogus polygons
    in the back.

X In src/sandbox/discmesh_perf_test/output, model.6.wrl has a crazy bogus
    polygon error in the upper left.
    X Saving this as an OBJ file and running it via src/rfm_discmesh/RUN made it fail
        with a CDT error.
    X Saving this an an OBJ file and running it via src/rfm_discmesh/RUN_OPT didn't show
        any errors that were in the original test.
        X Could this be because translating to OBJ and back loses precision?
    X Modify the test.py script to skip the cube stacks I'm not interested in,
        but keep the ones in the corners so the bounding box does not change.
    X Then copy the resulting .rfm file over to src/rfm_discmesh/test/models,
        and modify the RUN and RUN_OPT scripts to also handle RFM files as input,
        when no OBJ file is present.
    X This shows the error:
        RUN_OPT cube-stacks-bogus --sun-azimuth 210 --sun-elevation 65
        but this does not:        
        RUN cube-stacks-bogus --sun-azimuth 210 --sun-elevation 65
        X Ugh.
        X It's happening when the faces are retriangulated.
        X I tried making all the cgmath vector classes initialize themselves to zero,
            but this did not make the bug go away. So the problem is not
            an uninitialized vector.
        X The vertices of the problematic face are:
            15.5, 0.0, 4.5
            24.5, 0.0, -4.5
            15.5, 0.0, -4.5
        X When Retriangulator::filterFaceLineSegments is called,
            the face already has a bogus line segment assigned to it that is
            outside the bounds of the face, which causes the problem.
            X This only happens in the optimized build, and not in the debug build.
        X The bogus edge that is added is:
            12.8386, 0.0, -4.5
            14.5, 0, -4.5
    X The bug was in cgmath::GetIntersectionOfLineWithPlane, because of division
        by a very small number. Optimization was probably changing the order of
        operations that was producing wildly different results.
        I added an epsilon test to improve the behavior.

- (Kurt) Do a sphere/cone test when testing wedges against AABB's. 
    Compute the intersection of the cone bounding the wedge with the sphere 
    surrounding the AABB.

- When computing backprojections for distant light sources, instead of testing
    every edge in the scene, only test silhouette edges. This is easy
    in this case, because the light rays are all coming from the same direction.

- Try to devise a flood-fill based scheme for determining which vertices are
    fully illuminated, or fully in shadow, so I don't have to compute
    backprojections for them at all.

X Figure out if there's a way of fixing the D0 epsilon bug by tagging those vertices
    that generated the D0 discontinuities (either via VE or EV events),
    and using a larger epsilon value for those vertices than for other vertices
    when testing light source visibility.
    X This test illustrates the problem:
        RUN two-slabs --sun-az 180 --sun-el 38 --sun-sides 12 --sun-diam 90

** 'RUN shadow-creep-bug' now has an artifact because there is a vertex
    that is marked D0 but probably should not be.

- This has dark leaks on the porch:
    RUN craftsman --sun-az 210 --sun-el 30
    - The problematic vertex is
        -1.27849, 1, 5
    - There are three distinct vertices here. Only two of them are marked D0.
        - Forcing them all to be D0 does not solve the problem.
    - Increasing the first epsilon value calculated in MeshShaderFaceListener::initialize
        (changing the constant from 0.0005 to 0.001) makes this artifact go away,
        but brings back the light leak in 'RUN temple' test.
    - It'd be super great if I could come up with a method for handling these cases
        that does not involve epsilon tests.

X This has blue polygons!
    RUN craftsman --sun-az 210 --sun-el 30

X 'RUN craftsman-colored --sun-az 210 --sun-el 30' is a disaster.
    X When I assigned colors to this model, I created many coincident vertices
        for which there is no connectivity.
    X Running this with the --debug-lines flag shows that several line segments
        are completely missing. It's not even the case that they're
        created and then filtered out.
    X My guess is that in a few places, the code cannot handle the missing connectivity.
        Maybe it's having problems with coincident vertices or edges.
    - This problem and some of the epsilon problems might be solved by
        writing a robust preprocessor that would do the following:
        - Merge all nearly coincident vertices.
        - Split all edges where vertices are nearly coincident with them.
        - Split all intersecting nearly colinear edges.
        - Split all intersecting faces.
        - Split all faces where edges are nearly coincident with them.
        - Split all faces where vertices are nearly coincident with them.
        - Split all intersecting nearly coplanar faces.
        - Merge all duplicate edges.
        - Merge all duplicate faces.
        - Triangulate all faces.
        - (Make sure I am covering every possible case in the list above.)

X 'RUN cube-split' also clearly shows the problem when run with --debug-lines.

** 'RUN craftsman-colored --sun-az 210 --sun-el 30' has dark leaks.
    - These are all at points where edges of faces contact the middle of other faces.
    - This is my most significant remaining problem.
    - The problem vertices are:
        -0.200458, 1.0, 8.12804
        -3.5, 0.75, 8.25
        -3.875, 1.0, 5.0
        -1.27849, 1.0, 5.0
        -3.65249, 1.49316, 7.25602
        -2.87736, 1.49316, 8.03115
        -0.103567, 1.49316, 7.25602
        0.671564, 1.49316, 8.03115
    - I forced all these vertices to be shaded as if they were D0, and it had no effect.
    - Most of these artifacts are caused by missing critical edges on the light facing
        side of faces in contact with supporting faces.
    - Where are these critical edges being discarded?
    - My theory is that they're being discarded in the test I added to handle
        disconnected mesh geometry. When an edge in contact with another face
        casts shadows onto it, I'm discarding the legitimate shadow edge that I want.
        - Do tests to see if that's the case. Don't discard edges that lie
            within an epsilon distance of the groundplane.
        - More and more, this points to the need for preprocessing of the mesh.
    - I need to preprocess the mesh, and split these faces where they intersect.

- Write programs to filter the mesh, and as a series of standalone programs.
    - rfm_weld - Weld together nearly identical vertices, edges, and faces within
        an episilon distance from each other, as defined by an absolute tolerance
        and a relative tolerance.
    - rfm_intersect - Detect all intersecting mesh geometry and split it so that
        there are no intersections.
        - Just as with the 2D line segment case, I'm guessing that after the intersections
            are detected and split, this doesn't mean that doing so doesn't
            create more intersections.
    - rfm_triangulate - Triangulate all the faces of a mesh.
    X After I write all this, undo revision 3231 that handles coincident edges,
        but screws up shadows cast by contact geometry.

X Write rfm_weld.
    X Make a meshweld library for this code.
    X Support absolute and relative tolerances as arguments.
    X Create an AABB tree for the vertices of the model.
    - Loop over all vertices, adding them to the AABB tree,
        but first testing if there are already vertices in the model
        within an epsilon distance of the vertex.
        - If a close vertex is found, merge the new vertex into the existing one.
            Transfer the new vertex's adjacent edges and faces to the old one
            (assuming they are not already adjacent to the old vertex).
            Also, delete the new vertex.
    - Loop over all remaining vertices. Test for duplicate adjacent edges that
        have the same opposite adjacent vertex.
        - If a duplicate edge is found, remove it. Transfer its adjacent faces
            to the matching edge (assuming there are no duplicates).
        - Handle the case where there are more than two duplicate edges.
        - There might be resulting adjacent faces with only one edge.
            These must be removed.
            - Figure out if there are other funny cases like this.
    - Even better:
        X Mark the edges and vertices of the unique disconnected segments of the model.
            X Add a debug mode for coloring each of these with a different color.
            X Step over the whole model, flood filling adjacent vertices, edges,
                and faces (for debugging only) with a unique temporary integer ID 
                for each connected region.
                X Use the face ID to assign face colors, as they are assigned.
        X Remove all the ID attributes after they've been assigned.
        X Write meshprim::CreateCylinder, to connect two points together
            with a capped cylinder of a certain radius.
        - Find perimeter edges and vertices. (Edges that have zero or one adjacent face,
            and vertices adjacent to those edges.)
            - Mark the vertices as we encounter them to ensure we don't add them to the
                AABB multiple times.
            - Build AABB trees of the perimeter edges and vertices,
                so intersections can be tested for efficiently.
            - When populating the AABB tree of vertices, I have to grow the
                bounding box size for each vertex to take into account the absolute
                and relative tolerance. Otherwise, I'll have no way of knowing when
                two vertices are nearly coincident.
                - Well, wait. I don't really have to do that. I just have to grow the
                    bounding box of the object I'm testing for duplicates of,
                    when querying the AABB tree for intersections with a bounding box.
        - Only weld together vertices and edges on the perimeter that are near
            similar vertices and edges on opposing segments of the model.
            Don't weld together geometry within the same segment.
            - For robustness, could I do something like first identify edges
                longer than the tolerance values and weld their vertices first,
                and then incrementally zip together remaining edges and vertices,
                trying to maintain the order along the perimeter?
                - This would help prevent the mesh from folding back on itself
                    around nearly degenerate faces.
                - I could do tests of this using macroscopic tolerances.
        - When welding together unconnected mesh edges, first test for exact matches of vertex
            positions, and only after that, fall back to an epsilon test.
        - How do I weld together vertices?
            - Transfer the adjacent edges and faces from one vertex to another,
                without adding duplicates.
            - Then delete the original vertex.
        - Same for edges.
        - After we've tested perimeter edges and vertices on opposing regions for coincidence,
            there's still the possibility that perimeter edges within a single region
            are coincident, such as in the case when a region's perimeter folds
            back on itself (e.g. a cross shape composed of six squares, folded into a box).
            - We'll need a final pass to handle these cases. It's still best to test
                for the other cases first, because we'd like to give priority to
                connecting regions together.
    X Again:
        X Put all edges in an AABB tree.
        - Do two passes. On the first pass, look for exact positional matches
            of the vertices (set rel/abs epsilon values to zero),
            so they have priority.
        - Do this in two passes. 
            - In the first pass, only consider merging perimeter edges 
                from separate connected regions.
            - In the second pass, only consider merging perimeter edges within the same region.
        X Loop over all edges.
            - Only consider perimeter edges.
            - Use the AABB tree to search for edges with coincident endpoints.
                - There may be more than one edge that matches.
                - Reject edges from the same, or different connected regions,
                    depending on the pass (as described above).
            X Merge all the matching vertices for each endpoint.
                X Write a mesh library function to merge a pair of vertices.
                    X Copy over all adjacent edge references.
                        X Handle the case where the vertex already references
                            the same adjacent edge.
                        X Fix the vertex references of the adjacent edges.
                    X Copy over all adjacent face references.
                        X Handle the case where the vertex already references
                            the same adjacent face.
                        X Fix the vertex references of the adjacent faces.
                        X Fix the vertex references of the adjacent faces' face vertices.
                    X Copy over all vertex attributes not already present in the first vertex
                        being merged.
                    X Destroy the merged vertex.
            X Merge the edges.
                - Make sure the edge that the current loop iterator refers to isn't the one
                    that is deleted, so that incrementing the iterator doesn't fail.
                X Maintain an std::set of the edges were deleted via merging,
                    and avoid considering them again when they show up in the AABB test.
                X Write a mesh library function to merge a pair of edges.
                    X The edges must already have both endpoints in common.
                    X Copy over all adjacent face references.
                        X Handle the case where the edge already references
                            the same adjacent face.
                        X Fix the edge references of adjacent faces.
                    X Copy over all edge attributes not already present in the first edge
                        being merged.
                    X Destroy the merged edge.
    X In verbose mode, print out how many vertices, edges, and faces were removed.
    X rfm_weld is crashing when the file is written out. It looks like there might be
        a dangling VertexPtr referenced by a face vertex. 
        X Is MergeVertexIntoVertex handling face vertices correctly?

- Does VerifyConsistency test to make sure that vertices and edges
    are defined in the correct order, and the correct offset relative
    to each other with respect to faces? 
    I can use meshprim::CreateCylinder to feed it a mesh that I assume
    is not correct and it does not complain.
    - This was a test I added to the Delaunay 2D mesh consistency check,
        but I never added it to the 3D mesh check.

X Test normals output by CreateBox and CreateCylinder.
    X Write out RFM files containing these primitives, with face colors assigned,
        and then convert them to WRL files.
    X rfm2wrl doesn't support writing out normals.

X Replace the CreateBox and CreateCylinder functions with BoxCreator and CylinderCreator
    that are more future-proof.

X Write a cgmath/Matrix4fOperations.h function that creates a matrix that
    orients the Y axis from one point to another.
    Use this with meshprim::CylinderCreator to position cylinders between two points.

X In CreateBox and CreateCylinder, add functions to explicitly request normals
    and texture coordinates. Disable both of them by default.

X Try changing the order of arguments in the CylinderCreator.cpp expressions
    that involve cgmath::PI, to see if I can make the scientific notation
    in the resulting OBJ files go away.
    X That didn't work.

X Write code to triangulate a mesh.
    X Create a 'rfm_triangulate' program.
    - Create a 'meshtri' library.
        X Create a Triangulator class.
        X Loop over all the faces.
        X Skip all faces that are already triangles.
        X What do I do about faces that are degenerate or that self-intersect?
            X At the very least, put asserts in the code to check for these cases
                so when it fails, I'll know why early on.
            X Degenerate faces (in 2D) will cause the delaunay triangulator to fail
                because of the redundant vertices.
        - Don't bother handling quads as a special case. I just want this to work,
            and it'll all operate in linear time anyway.
        X It look like I'd have to copy code from meshretri/FaceSplitter.cpp.
            Can I split this out into another common library?
            X This has too much discontinuity-specific junk in it.
        X Split the face using the delaunay library.

- Write code to detect intersections in a mesh of triangles and subdivide them
    where they intersect.
    - Handle the case where the edge of one face intersects the middle of another face.
    - Handle the case where the edge of one face is colinear with the edge of another face,
        but only intersects a subsection of that edge.
    X Create a rfm_split program for testing.
        X Take --abs-tolerance and --rel-tolerance arguments, like rfm_weld does.
    X Create a meshsplit library.
        X Allow setting of absolute and relative tolerance.
    X In debug mode, make meshsplit first test that all the faces are triangles.
        X Make this a standard mesh library function, and call it elsewhere in my code
            where I'm already performing this test. (rfm_discmesh?)
    X Create an AABB tree of all the faces.
        X Use meshisect::FaceIntersector.
    - Use the meshretri library to perform the retriangulation and see how far I get with that.
    - Write these intersection tests:
        - Two line segments in 3D.
            - We want the resulting line segment, if any.
            - If the intersection is a point, return it as a degenerate line segment.
        - Point and triangle in 3D.
        - Line segment and triangle in 3D.
            - We want the resulting line segment, if any.
            - If the intersection is a point, return it as a degenerate line segment.
        - Two triangles in 3D.
            - We want the resulting line segment, if any.
            - If the intersection is a point, return it as a degenerate line segment.
    - Detect all the intersections between each pair of faces.
        X Loop over all faces. Test against all faces in the portion of the AABB tree
            that intersect its bounding box, grown by the abs/rel tolerances.
            - For each edge of the face, test if it intersects the other face.
                - Don't test edges that are already adjacent to the other face.
                - Test for intersections of the face's vertices with the other face's edges.
                    Record these intersections as degenerate line segments in the other face.
                    - This is no good. It'll wind up creating degenerate faces.
                - Test for intersections of the face's vertices with the other face.
                    Record these intersections as degenerate line segments in the other face.
                    - This is no good. It'll wind up creating degenerate faces.
                - Test for colinear intersections of the edge with the edges
                    of the other face. Record these intersections in the other face
                    as line segments.
                    - Don't test edges that are adjacent to the same vertex.
                    - This is no good. It'll wind up creating degenerate faces half the time.
**              - Then, test if the edge lies in the plane of the other face.
                    If it does, clip the edge against the face, and record it in the other
                    face as a line segment.
                    - This one test should be enough to fix up the Craftsman house model.
                    - This is not true. After merging, I'm left with several
                        degenerate faces, because of colinear edges that only have one
                        adjacent vertex after the merging.
            - If the faces are not coplanar, find their intersection.
                Record the intersection as a possibly degenerate line segment in the other face.
                - Do this by finding the points of intersection between the edge of each
                    face and the other face.
    - Submit all these intersections to meshretri.
    - Retriangulate all the faces.
    - Then merge all pairs of edges that had a common origin via a shared intersection.
        - The right way to do this would be to give meshretri the ability to add
            unique identifiers to the edges that it adds to the mesh.
        - One semi-lame option is to only bother with splitting the mesh in this pass,
            and then rely on the meshweld library to merge the resulting edges in another pass.
            - Just plan on doing this for now.

X Move meshprim/Matrix4fOperations.h,cpp to cgmath library.

X Move DeleteVertex, DeleteEdge, DeleteFace from MeshOperations.h,cpp to
    VertexOperations.h,cpp, etc.
    X Same for MergeVertexIntoVertex and MergeEdgeIntoEdge.

X Move mesh::ComputeBoundingBox into MeshOperations.h,cpp.

X Move mesh intersection classes in to meshisect library.
    X Rename existing meshisect library to meshsplit.
    X Rename rfm_isect to rfm_split.
    X Make the new meshisect library.
    X Move all mesh intersection classes to the new meshisect.

X Don't automatically autofill and check in .cpp files when Ctrl+C,H is used from a header
    and the corresponding .cpp file doesn't already exist.

X Modify GetIntersectionOfTriangleWithCoplanarLineSegment so we can find out
    which of the three edges caused the two endpoints to be clipped, if any.
    X I need this so I can pass the correct edges to meshretri::FaceLineSegment.

X Splitter should loop over all edges in the mesh, not the mesh faces and then their edges.

X Rename objfile to meshobj and rfmfile to meshrfm.

- 'RUN' in src/rfm_split fails in rfm_weld.
    Examining this edge in the file looks like there is a degenerate triangle whose
    vertices are being welded together.
    X Rename meshweld::PerimeterWelder to Welder.
    X Don't weld together edges that are adjacent to the same face.
    X Give meshretri::Retriangulator an option to assign a (temporary) boolean attribute
        to edges that are created as a result of splitting.
    X Give meshweld::Welder an option to only consider edges marked with
        a specified boolean attribute (set to true), instead of 
        perimeter edges. Wire this up to the attribute
        assigned earlier in meshretri::Retriangulator.
    X Add a debugging option to rfm_split to set the attribute above,
        and a debugging option to rfm_weld to test for the attribute.
        The attribute should not be a temporary attribute.
    - If this all works, make rfm_discmesh split and then weld the mesh
        based on a temporary attribute.
    - I did a test by copying the split/welded .rfm file to src/rfm_discmesh/test/models,
        and meshretri::RetriangulatorFace looped forever on the same polygon 
        in correctSelfIntersectingFacePerimeterLineSegments,
        perhaps on a degenerate face.
        X One way to deal with this would be to avoid splitting degenerate faces.
        X Ideally, though, I should avoid creating these in the first place.
            X Write a mesh library function to collapse an edge.
        X How about if in meshsplit, I avoid adding to faces those line segments
            that lie within an epsilon distance of the face's existing edges?
        X I don't think any of this would work because I can imagine situations where
            degenerate faces are being created simply by welding vertices together
            between disjoint segments of the mesh.
        - No matter what, correctSelfIntersectingFacePerimeterLineSegments should never
            loop indefinitely. Fix that.
        - Figure out how to improve meshsplit so that it first 
            splits edges where they are intersected by other edges. This should
            resolve the degenerate face creation problem.
            - There are at least two cases here. An edge may lie within another edge,
                or an edge may partially straddle another edge.
            - When edges are colinear with other edges, they should explicitly handled
                by this case, rather than by recording line segments
                for meshretri.
            - Make sure I think this through.
            - It's unclear if meshretri requires that its input mesh consists entirely
                of triangles. If I can figure this out, comment it
                in meshretri/Retriangulator.h.
                - In the worst case, I could write up test code to try this out.

- In meshsplit, don't split faces with edges whose adjacent faces are all
    coplanar with the face. This will avoid unnecesarily splitting the groundplane
    faces under the house.

X Change mesh::VerifyConsistency to return a bool, without ever calling assert.
    X Change the MESH_VERIFY_CONSISTENCY macro to use assert. 
        The #ifdef in the definition of MESH_VERIFY_CONSISTENCY is then no longer needed
        because the assert macro with discard the VerifyConsistency call.
    X Change all the unit test VerifyConsistency calls to use CPPUNIT_ASSERT.
    X Consider renaming VerifyConsistency to IsConsistent, 
        MESH_VERIFY_CONSISTENCY to MESH_ASSERT_CONSISTENCY,
        and VerifyConsistency.h,cpp to MeshConsistency.h,cpp.

X Add tests to VerifyConsistency to check for edges with only one vertex,
    or faces with only two vertices or edges.

X Do this all over again.
    X Write unit tests for DeleteVertex.
    X Write unit tests for DeleteEdge.
    X Write unit tests for GetEpsilonFromEdge.
    X Write unit tests for GetEdgeBoundingBox.
    X Write unit tests for DeleteFace.
    X Write unit tests for GetFaceAverageVertexPosition.
    X Write unit tests for GetEpsilonFromFace.
    X Write unit tests for GetFaceBoundingBox.
    X Write unit tests for GetTriangularFaceOtherEdges.
    X Write unit tests for GetTriangularFaceOtherEdge.
    X Write ElementTracker, an object that keeps track of vertices, edges, and faces
        that are deleted by some functions. Use a STL set to keep track of them
        and query them.
        X This should have functions for clearing the sets, adding new vertices, edges,
            and faces, functions to set what element types we're interested in.
        X It should have functions for querying vertices, edges, and faces
            which should fail an assert if those element types are masked out.
        X Add functions for iterating over the elements in the sets.
        X Write unit tests.
    X Write MergeVertexIntoNonadjacentVertex.
        X Review this design.
        X This will handle the case when two vertices have no adjacent edges or faces in common.
        X Resurrect the old vertex merging function.
        X Assert that the vertices have no edges or faces in common.
        X Replace the source vertex with the target vertex in the source vertex's
            adjacent edges.
            X Also make the target vertex adjacent to these edges.
        X Replace the source vertex with the target vertex in the source vertex's
            adjacent faces.
            X Also make the target vertex adjacent to these faces.
            X Make sure the face vertex attributes corresponding to the target vertex
                wind up with the same attributes that the source vertex had.
                X There's no need to do this. Since the source vertex isn't adjacent
                    to the target vertex's adjacent face, it cannot have any
                    FaceVertex attributes within that face.
            X Ensure that the vertex order within the source vertex's adjacent faces 
                is maintained.
        X Copy over attributes from the source vertex to the target vertex not already
            present in the target vertex.
        X Delete the source vertex.
        X Use an optional ElementTracker.
        X Write a unit test merging vertices of two triangles.
        X Write a unit test merging two vertices of two triangles.
        X Write a unit test merging vertices that each have three adjacent triangles.
    X Write MergeEdgeIntoEdgeWithSharedVertices.
        X Review this design.
        X Assert that the edges already share the same two vertices.
        X Resurrect the old edge merging function.    
        X Write unit tests.
    X Write CollapseEdge.
        X Review this design.
        X Assert that all adjacent faces are triangles.
        X Assert that the other edges adjacent to one of the edge's vertices
            are not adjacent to the same two edges as the edge we're collapsing.
            In other words, there should not be any other edges
            sharing the same vertices as the edge we're collapsing.
            If there were, we'd wind up creating edges that had duplicate vertices.
        X Use ElementTracker.
        X Always merge the first adjacent vertex into the second one.
            MergeVertexIntoVertex will expect this.
        X Build a vector of all edge pairs of the other edges of the adjacent faces.
            X Use GetTriangularFaceOtherEdges.
        X Delete the faces adjacent to the edge.
            X Record the deleted faces.
        X Delete the edge.
            X Record the deleted edge.
        X Call MergeVertexIntoNonAdjacentVertex.
            X Record the deleted vertex.
        X Call MergeEdgeIntoEdgeWithSharedVertices on all edge pairs saved earlier.
            X Record the deleted edges.
        X Write unit tests.
    X Write a new MergeVertexIntoVertex function.
        X Review this design.
        X Use an optional ElementTracker.
        X This function should work robustly in all cases for triangular meshes.
        X This function will only merge vertices. If this results in coincident
            adjacent edges, we won't merge them. If that's desired,
            MergeEdgeIntoEdgeWithSharedVertices can be called.
        X First, assert that all adjacent faces are triangles.
        X Two cases:
            X The two vertices do not share an adjacent edge.
                X Call MergeVertexIntoNonAdjacentVertex.
            X The two vertices share an adjacent edge.
                X Call CollapseEdge, but first ensure that the vertex order of the edge's
                    adjacent vertices are such that the first vertex will be merged into the second
                    by the edge collapse operation.
                X If the two vertices share multiple edges, we must first merge all the edges
                    together into a single edge, and then collapse that edge.
                    Otherwise, CollapseEdge will fail, because it can't deal with
                    vertices whose endpoints are both shared by other edges.
        X Write unit tests.
    X Write MergeEdgeIntoEdge.
        X Review this design.
        X Use an optional ElementTracker.
        X The vertex order of the edges will determine which vertices get merged together.
        X Assert that the first vertex of each edge is not the second vertex of the other edge.
        X Call MergeVertexIntoVertex zero, one, or two times, 
            depending on which vertices are already merged,
        X Call MergeEdgeIntoEdgeWithSharedVertices.
        X Write unit tests.
    X Get rid of the STL set of edges in meshweld::EdgeMatcher
        and use mesh::ElementTracker instead.
    X Make meshweld::Welder::weldEdges use MergeEdgeIntoEdge.

X Add checks to mesh::IsConsistent to make sure that edges do not have duplicate vertices
    or duplicate faces, and that faces do not have duplicate vertices or duplicate edges.

- When splitting up the mesh where intersections are detected, discard
    line segments that are nearly coincident with the edges of a face, to
    avoid creating degenerate faces after the mesh is split.
    Do this after all of the edge merging work is complete.

X rfm_split/RUN still fails.

X rfm_split/RUN doesn't weld the bottoms of the posts on the front of the porch
    to the porch, which doesn't seem like it should be a problematic case.
    X Why are these being skipped?
    X One of the edges that isn't being welded is:
        -0.200458, 1, 7.15913
        -0.200458, 1, 8.12804
    X Only one of the two edges with these endpoints is considered a candidate for merging
        by Welder::edgeCanBeMerged.
        X I don't think meshsplit::Splitter is flagging the edges that are causing
            the splitting, only the edges that result from splitting.

X RUN craftsman-welded --sun-az 210 --sun-el 30
    almost looks correct, except that the normals are getting screwed up
    somewhere along the line.
    X craftsman-welded.rfm was created by rfm_split/RUN.
    X The original model this model was created from, before splitting, had bad normals.

- RUN craftsman-welded --sun-az 210 --sun-el 30
    - This now is almost perfectly correct, except for discontinuity line segments
        are not being created where the black triangle appears at the top front of the house.
    - There are multiple degenerate faces coincident with the silhouette edges
        that would have cast these discontinuity line segments.
    - Both of these silhouette edges are involved in a situation where one edge
        cross through another.
    - My feeling is that if these faces were split correctly where the edges intersected,
        I wouldn't wind up with the degenerate faces, and the artifacts would go away.

- Explicitly handle the case where the two edges of adjacent faces are nearly colinear
    and intersect, but do not share endpoints.
    - The rfm_split/RUN2 test demonstrates this problem with a simpler model.
    - If I handle an edge with respect to a face this way, I probably should not
        later use that edge to split the same face.
    - How will this interact with the use of meshretri::Retriangulator?
    - Could I augment meshretri::Retriangulator to let me specify split points for edges?
        - This looks like a can of worms.
    - Maybe I should just specify degenerate line segments to get Retriangulator
        to split the edges where I want.
        - Will this work?
    - Fuck it. I'll just tweak the model so it avoids this case and move on
        to the indirect illumination. I've spent far too much time on this already.

- Come up with a plan for how I'm going todo the indirect illumination.
    - Rough version:
        - Step 1
            - For each vertex, find each unique normal amongst the adjacent face vertices.
            - Fire rays from the vertex into the adjacent scene.
            - Compute the indirect illumination for each adjacent face vertex.
            - This should look moderately interesting.
        - Step 2
            - Compute the indirect illumination for virtual face vertices
                on the faces adjacent to each edge.
                - Interpolate the normals of the two adjacent face vertices
                    to determine which normal to use for the virtual face vertex.
            - When the illumination for these virtual face vertices differ
                from a linear interpolated illumination at that point along the edge,
                mark the edge for splitting, and record the illumination we've already 
                calculated for the face vertices we'll create.
            - Mark edges we've already decided should not be split, and
                on the next pass, don't consider them again.
            - Don't split edges below a specified size threshold.
            - Split all these edges.
                - Assign the newly computed illumination for the new face vertics.
            - Retriangulate the model.
            - Repeat.
        - Step 3
            - The above approach will result in dark corners. Figure out how to
                deal with that problem.

X I need better support for ray firing.
    X Add a unit test for the value of 't' passed to cgmath::BoundingBox3fIntersectsRaySegment.
    X cgmath::AabbTree needs to be able to fire rays and return the first intersection
        point along the ray, and the intersected object.
    - Add a unit test for the cgmath::AabbTree ray intersection test.
    X Then add support for this to meshisect::FaceIntersector.
    - Add a unit test for the meshisect::FaceIntersector ray intersection test.
    X Write a sandbox test program that fires rays into an input file
        and outputs all the intersections as boxes.

X Do a sandbox test of BoundingBox3fIntersectsTetrahedron, because I don't really
    know if it works or not. It looks like the vertex order is important. Comment this.
    X It seemed partially broken so I commented that fact.
    X Vertex order didn't seem to matter when I tested it.

- Write code to shade a vertex.
    - Take a vertex as input.
    - Find the set of unique vertex normals for all adjacent face vertices.
    - Calculate the shading for each face vertex normal individually, and apply it to
        the corresponding face vertices.
    - Fire random rays across a hemisphere, given the vertex position and normal.
    - If the ray lies behind any adjacent face (when projected onto the face),
        it's occluded.
    - Otherwise, fire the ray into the scene and see what it hits.
    - For the first version of this code, just shade each face based on the fraction
        of those rays that hit something vs. those that hit nothing at all,
        as if we were computing ambient occlusion.
    - Improve the epsilon comparison in rfm_indirect, MeshShader::allowFaceIntersectionTest.
        See comments.
    - Later, sample the interpolated face colors across the faces that are intersected,
        or the sky color when no faces are intersected.
    - What fraction of the indirect illumination should be added to the vertex colors?
    - To support multiple passes, into what attributes should I write this information?
        - rfm_discmesh sets 'illuminatedColor3f' face vertex attributes,
            which are also copied to the standard 'color3f' attribute.
        - Should I change 'illuminatedColor3f' to 'directIlluminationColor3f'?
        - rfm_indirect could write out 'indirectIlluminationColor3f'.

X rfm_indirect/REBUILD shows that rfm_split is creating the NaN normals.
   X Figure out why this is happening.
   X The original model had degenerate faces that were causing problems.

X Rename Matrix4's translation/rotation/scale functions so they start with 'from',
    my standard for named constructors.
    X Check for any others in Vector3f, etc.

X Several vertices in 'rfm_indirect/RUN' appear to be shaded incorrectly.
    X Investigate this one:
        -5, 0, 10
        X There is really only one vertex here.
        X Astoundingly, rfm2wrl wasn't writing out the correct vertex colors.
            How did this ever work?

X Vertex I don't understand: 0.439042, 1.55792, 5
    X There are two vertices here.
    X Both normals are 0, 0, 1.
    X With 1000 samples, the intensities are 0.291 and 0.336.
        I assume these are essentially the same, but any small
        difference in intensity shows up as a sharp discontinuity
        because of the coincident vertices.
    X Filtering out the degnerate faces by collapsing the vertices
        would probably fix this.
        X Try doing this manually.
        X If that works, write an rfm_snap tool to fix all these cases.
    X Another way to fudge around this would be to use the same set of random normals
        for every vertex. That way, the calculations for coincident vertices
        with matching normals would work out the same.
        X I'll want to do this anyway to avoid expensive drand48 calls.
        X Try this.

X Could I filter vertices after calculating intensities?
    X I could apply a Gaussian filter to all vertices over a certain distance
        across each region with continuous normals.
        X Unique identifiers would be assigned to each of these regions in advance.
    X This might interact poorly with the adaptive subdivision.

X Figure out what's going on with the artifact on the top of the left pillar
    on the porch.
    X Actually this looks fine, and exactly what I would expect given how
        the input geometry. Adapative subdivision should correct this.

X Add friend functions to VertexPtr, EdgePtr, FacePtr so I can print them out
    without using "&*".

X Should EdgeSplitter really be in the mesh library?

- mesh::Triangulator fails when passed degenerate faces. Try to resolve this somehow.
    - Ideally, I shouldn't have any degenerate faces.
    - Write a rfm_lint program to highlight the degenerate faces in the model.
    - Look at these faces and see what I can do to filter them out.
    - Write CollapseDegenerateFace in FaceOperations.cpp
        - Four cases:
            - All the vertices are nearly coincident.
            - Two of the vertices are nearly coincident.
            - No vertices are coincident. One of the vertices nearly lies along the opposite edge.
            - The triangle is not degenerate. The face cannot be collapsed.
        - Could I delete the face, split the long edge where the middle vertex intersects it,
            triangulate the adjacent face, and then merge vertices and edges together?
    - All the strictly degenerate faces (assuming zero tolerance) are very small.
        so adaptive subdivision won't ever attempt to subdivide them,
        so I can probably ignore this problem for now.

- What would rfm_lint check for?
    - Mesh consistency.
        - Nonmutual vertex-edge references.
        - Vertices with duplicate adjacent edges.
        - Nonmutual vertex-face references.
        - Vertices with duplicate adjacent faces.
        - Edges with less than two adjacent vertices.
        - Nonmutual edge-vertex references.
        - Edges with duplicate adjacent vertices.
        - Nonmutal edge-face references.
        - Edges with duplicate adjacent faces.
        - Faces with less than two adjacent vertices.
        - Faces with less than three adjacent vertices.
        - Faces with unequal numbers of adjacent vertices and edges.
        - Nonmutual face-vertex references.
        - Faces with duplicate adjacent vertices.
        - Nonmutal face-edge references.
        - Faces with duplicate adjacent edges.
        - Face vertices referencing vertices other than the face's adjacent vertices.
    - Coincident vertices.
    - Coincident edges.
    - Coincident faces.
    - Nearly coincident vertices.
    - Nearly coincident edges.
    - Nearly coincident faces.
    - Nearly coincident faces with opposing geometric normals.
    - Edges that share the same vertices.
    - Faces that share the same vertices.
    - Degenerate edges.
    - Degenerate faces.
    - Nonplanar faces.
    - Self-intersecting faces.
    - Vertices that intersect edges.
    - Vertices that intersect faces.
    - Edges intersecting edges.
    - Edges that intersect faces.
    - Faces intersecting faces.
    - Faces coplanar with and intersecting faces.
    - Edges with two adjacent faces with conflicting vertex orders.
    - Edges with more than two adjacent faces.
    - Edges with only one adjacent faces.
    - Faces whose vertices orders don't match their edge orders.
    - Vertices with NaN vertex positions.
    - Face vertices with NaN normals.
    - Face vertices with non-unit normals.
    - Faces with NaN normals.
    - Vertices with non-unit normals.
    - Faces with more than three vertices.
    - Faces with material indices that reference materials not defined in the mesh file.

X Use a cosine distribution for my ray sampling, if that is the correct distribution to use.
    X I was already doing this.

** The white splotches near the ground are probably because MeshShader::allowFaceIntersectionTest
    is using such a large epsilon value.
    - Improve this computation.

X Give mesh::Subdivider the ability to split only marked edges.

X Convert rfm_lint over so it uses a class instead of global variables.

X Try to restore an incremental backup.

X Fix FaceIsDegenerate so it no longer performs the area test, but instead tests if
    vertices are nearly coincident with opposing edges.

X Rename mesh::EdgeSplitter to Subdivider so it doesn't seem so edge-centric,
    and make it responsible for retriangulating the faces.
    X Make it first assert that the mesh is triangular.

X What's the plan for doing adaptive subdivision?
    X Specify an error tolerance.
    X Specify a minimum edge length.
    X Shade the existing vertices.
    X In shadeMeshVertex, populate a member variable vector of the faces adjacent 
        to the current vertex.
        X For each face, we also need the two vertices adjacent to the current vertex.
            Put these together in a structure. We'll do the same when shading edges.
        X In allowFaceIntersectionTest, test against this vector of faces,
            rather than the faces adjacent to mCurrentVertexPtr.
    X Loop over all edges.
        X Ignore edges less than the specified minimum length.
        X Ignore edges we've already tested before.
        X For each adjacent face, compute the shading that would be applied
            to a face vertex at the midpoint of the edge.
            X Write shadeMeshEdge.
                X Populate the vector of faces adjacent to the edge.
                X Write createUniqueAdjacentFaceVertexNormalSetFromEdge.
                    X For each adjacent face, this should interpolate the normals 
                        of the face vertices corresponding to the endpoints of the edge.
                    X We also need a multimap from each normal to the faces that
                        share that normal, along with 
                        the interpolated indirect illumination between the
                        face vertices at the ends of the edge.
            X Modify sampleIndirectIlluminationForVertex to take a point, a normal,
                and an adjacent face vector.
                X Rename it sampleIndirectIllumination.
                X Use this in shadeMeshEdge.
                X Store the resulting illumination in normalToShadedEdgeMap.
            X Make rayPointsBehindFaceAdjacentToVertex not take a vertex pointer,
                and instead use the vector of adjacent faces in the calculation.
            X In shadeMeshEdge, given computed illumination for a normal,
                test if, for any of the faces that share that normal,
                the illumination differs from the interpolated illumination of the endpoints
                by an amount greater than the error tolerance.
                X Put the edge in a map of edges to maps of adjacent faces to
                    illumination values.
                    X We don't have to mark edges. Their presence in this map is
                        how we'll know to split them.
                X If we decided not to split an edge, mark the edge so we don't
                    consider it again on the next pass. Use a temporary edge attribute.
    X Roll our own version of mesh::Subdivider.
        X We have to assign illumination to face vertices created
            by edge splitting before retriangulation.
    X Get rid of mCurrentVertexPtr.
    X Get rid of mesh::Subdivider since we have to do it ourselves.
    X Keep looping in the edge shading/splitting code until no more edges were split.
        X After each pass, mFaceIntersector must be reinitialized with the new mesh,
            since new faces will have been created.

X Make ProjectedFaceIsDegenerate use the same logic as FaceIsDegenerate.

X Remove the three pass limit from MeshShader::shadeMesh after I figure out
    what's causing it to crash when this limit is exceeded.
    X The code is trying to subdivide a degenerate triangle.
    X Go back to the strategy of removing all these triangles first, before I start.
        X Fix FaceIsDegenerate to not be so aggressive. Just see if points are
            nearly coincident with other edges of the face that they're not adjacent to.
        X Then check that only these few faces are detected using rfm_lint.
            X Then write a program to remove the degenerate faces.
            X For now, only handle the case where two vertices are coincident.
            X Name the new program rfm_degenerate.
            X Make a vector of all degenerate edges.
            X Use ElementTracker to track deleted edges so we don't try to 
                collapse them repeatedly, and to track deleted faces so we don't
                consider them after they're deleted.
            X Find degenerate edges and collapse them.
                X Use mesh::GetEpsilonFromEdge to find the epsilon distance for the test.
                X Collapse the degenerate edge.
            X Keep looping until there are no more degenerate edges.
            X Print out how many faces were removed by subtracting the original
                number of faces from the new number.
                X Print the number of edges and vertices removed too.
        X Then try to run rfm_indirect again without any looping restrictions.

X It doesn't quite look like the subdivided edges are being shaded correctly.

X rfm_degenerate.debug craftsman-direct.rfm deg.rfm
    fails in an assert statement.

X Make rfm_degenerate first test that the mesh is all triangles. CollapseEdge can't
    deal with any other case.

X On the RUN test in rfm_indirect, why is this vertex on the right column
    darker than its neighbors?
    0.322858, 1.96985, 7.9954
    X Reshading all the vertices of the subdivided mesh fixes this artifact and others,
        which implies that there is a problem with the edge shading function.
    X Figure out why this is.
    X I printed out the shaded values for the vertex at that location and the edge
        at that location.
        X The luminance is the same, even though this is not what I see in the 
            resulting shaded models.
        X It looks as though the interpolated intensity colors are what's being written
            out into the mesh.
        X Does this mean that the shaded values are not getting written back
            into the new face vertices after the mesh is triangulated?

X Add adaptive subdivision arguments to rfm_indirect and pass them along to MeshShader.

X Add a --max-pass command line argument to rfm_indirect.

X Actually do the indirect illumination for real.
    X Sample the direct illumination at the points of intersection, or the sky color.
    X Add a global default reflection coefficient (0.3 is typical), as a command line parameter.
    X Add a global coefficient to scale the existing direct illumination in the mesh.
        A good default might be 0.7.
    X Don't worry about multiple bounces yet.

- rfm_indirect should print statistics at exit about how many faces were created.

X rfm_indirect still fails after several iterations, even when degenerate edges
    are filtered out.
    X Figure out what's really causing this problem by examining the
        problematic faces in detail.
    X Don't make MeshShader collapse degenerate edges if it's not really necessary.

X I think stripping out degenerate edges makes everything worse. Try getting rid of that.

X Now I'm thinking that I should somehow make the triangulation code more robust,
    so that it can deal with degenerate faces.
    X Make a new class specific to rfm_indirect for triangulating faces.
    X The new algorithm will be limited to triangles that have had zero or more edges split,
        but will robustly handle degenerate faces.
    X Mark the vertices created as a result of edge splitting with a boolean attribute
        made available by the new class.
    X Triangulate the faces using the new class.
        X Loop over all faces.
        X Cases:
            X Face has three vertices.
                X The face is already a triangle. Nothing needs to be done.
            X Face has four vertices.
                X One of the vertices should be the result of a split edge.
            X Face has five vertices.
                X Two of the vertices should be the result of a split edge.
                X There are two possible tessellations for this case,
                    depending on the relative positions of the vertices.
            X Face has six vertices.
                X Three of the vertices should be the result of a split edge.
            X Any other case is an error.
        X Then wire up new edges and faces.
            X Write a function, possibly in the mesh library, to create a new trianglar
                face in terms of three existing vertices, and automatically create
                missing edges if necessary.
            X Write unit tests for EdgeHasAdjacentVertex.
            X Write unit tests for FindEdgeConnectingVertices.
            X Write unit tests for CreateTriangularFaceAndEdgesFromVertices.
        X Copy face vertex attributes from the old face to the new faces.
        X Delete the original face.
        X Clear all the split edge vertex attributes from the mesh vertices.
            X Call mesh::RemoveAttributeFromMeshAndAllElements.

- Why is there lots of subdivision under the house where it's all dark?

X Why all the artifacts and long skinny triangles?
    X They're created at the corners of the geometry and stretched across the slivers.

X Consider shading the midpoints/centroids of faces, rather than the vertices,
    or something along those lines, so we no longer shade corners
    that wind up extra dark.

X This vertex looks too dark:
    1.5, 3.5, 7

X Handle multiple bounces.
    X Set all the indirect illumination attributes to zero just in case somehow
        they were left over from an earlier mesh.
    X On the first bounce, copy the direct illumination into the input attributes.
    X Before each bounce, set all the output attributes to zero.
    X During each bounce, write the newly computed illumination into the output attributes.
        instead of straight into the indirect illumination attributes.
    X After each bounce, add the output attributes to the indirect illumination attributes,
        and copy the output attributes to the input attributes.
    X At the very end, combine the indirect and direct attributes into the color attributes.

X Replace the vertex shading scheme with a face shading scheme, to get rid of corner artifacts.
    X Make a branch for this work.
    X Implement this first without adaptive subdivision.
    X When finished, remove member functions/variables we no longer use:
        rayPointsBehindAdjacentFace
        mRejectedEdgeAttributeKey
    X Write shadeFaces to replace shadeMeshVertices and shadeMeshEdges.
    X Write shadeFace.
        X Sample the indirect illumination at the average position of the face vertices,
            and store it as a face attribute using mSampledIlluminationAttributeKey.
    X Replace the use of AdjacentFaceVector everywhere with references to individual faces.
    X Accumulated indirect illumination will still be stored in face vertices.
    X Calculated illumination will be stored with 
        then converted to face vertex colors and stored with mOutputIlluminationAttributeKey.
        X That way later I can store the sampled values in face vertices as well,
            before they are filtered to form the output illumination values.
        X This will also let me sample illumination values interpolated across faces
            rather than using flat-shaded faces in the calculation.
            X However, it will result in some bleeding.
    X Change resetOutputIllumination to resetSampledIllumination.
        X Output illumination will be derived from the sampled illumination.
    X Write convertSampledIlluminationToOutputIllumination.
        X For now, find the unique set of adjacent face normals for each vertex
            (using createUniqueAdjacentFaceVertexNormalSetFromVertex),
            then for each normal, average together the sampled colors of all the adjacent
            faces whose corresponding vertex normal shares the normal,
            weighted by the angle of the face.
            X Write a function to compute the angle of a face vertex. (getFaceVertexAngle)
        X Call this function.
    X Remove AdjacentFace, AdjacentFaceVector.
    X Merge the branch back to trunk.

- Deal with the TODO in MeshShaderFaceListener::allowFaceIntersectionTest.
    The ray near-end epsilon test isn't so great.
  
X Consider some kind of filtering to spread indirect illumination across thin triangles
    that would cause shading discontinuities.
    X Try this:
        - The following code will be a replacement for
            MeshShader::convertSampledIlluminationToOutputIllumination.
        X Consider each connected region one at a time.
        X Loop over all the faces in each connected region, recursively
            moving between adjacent connected faces, marking them as we go.
            X Add the sample points and associated face normals for
                these faces into an AABB tree as we go.
                X In OutputIlluminationAssigner::addSamplesFromFaces,
                    determine the position of the face vertex samples.
                    Split out the code from MeshShader into a separate file so
                    that both MeshShader andOutputIlluminationAssigner can use it.
            X Store all the faces in a set.
            X Store all the vertices in a set.
            X Create an AABB tree of all the face vertices.
                X Make sure the face vertices aren't added to the AABB tree redundantly.
        X Loop over the vertices and adjacent faces to shade the face vertices,
            as MeshShader::convertSampledIlluminationToOutputIllumination does.
            X Only consider the vertices and faces in the sets created earlier.
            X Find the farthest adjacent vertex on the adjacent faces,
                relative to the current vertex.
                X Assign this radius to the current face vertex.
                X Given this distance, use the face vertex AABB tree computed earlier
                    to find all face vertices within this radius. 
                    X Assign this radius to these face vertices unless they already
                        have a larger assigned radius.
        X Loop over the vertices and adjacent faces again.
            X Use the radius assigned to the face vertex to query the
                AABB tree of sample points.
                X Weight the samples with a Gaussian curve, by distance.
                X Weight the samples by the dot product of the normals.
                X Weight the samples by face area.
                - It'd be extra nice to use an ellipsoid in this test,
                    rather than a sphere, but I probably don't have to bother
                    for any of my test cases.

- Rename rfm_indirect command line arguments like --max-pass which is ambiguous
    given the --bounces flag.

X Get multiple bounces working again.

X Implement adaptive subdivision.
    X Modify resetSampledIllumination to additionally reset mSampledIlluminationAttributeKey
        face vertex attributes.
    X Modify shadeFace to shade three other points near the vertices, and store them
        as face vertex attributes using mSampledIlluminationAttributeKey.
        X Calculate the new positions by averaging existing vertex positions with edge midpoints.
    X Incorporate the new face vertex samples into the calculation
        in convertSampledIlluminationToOutputIllumination.
    X Implement subdivideFaces, as a replacement for splitMeshEdges.
        X For each face, if the average luminance of the face vertex sampled colors 
            differs significantly from the luminance of the sampled color at the center
            of the face, mark all edges of the face as requiring subdivision.
            X If the face does not require subdivision, mark it with
                mUnsplitFaceAttributeKey, and skip faces marked this way on 
                subsequent passes.
        X Retriangulate the mesh using mSplitEdgeTriangulator.
        X Return true if splitting was required.
    X Remove mRejectedEdgeAttributeKey.
    X Remove splitMeshEdges.
    X Make the adaptive subdivision loop in shadeMesh work again.
    X Do something so we don't try to repeatedly shade faces that we decided not to split.
        X Before the adaptive subdivision passes, mark which faces need shading.
        X On each adaptive subdivision pass, only shade faces marked this way.
        X After shading a face, mark it as having been shaded.
        X When we've decided to split a face and one or more of its edges
            are candidates for splitting, mark the face as needing to be shaded again.
    - Maybe weight samples based on polygon area (in addition to face vertex
        angle), so small slivery polygons won't have too much influence.
    X Maybe get rid of the attribute that tells me not to reconsider a face
        for additional adaptive subdivision, since the test is not expensive,
        and I'm not convinced that early rejection of a face means it'll never
        be the case that it needs to be subdivided again on another pass.

- Should the adaptive subdivision and bounce loops be exchanged?
    - (Note: I decided not to bother with this, under the assumption that it would
        be expensive and wouldn't actually help.)
    - This would reduce accuracy somewhat, generating additional light bleeding
        because the faces would all be larger.
    - If there were three bounces, I'd do all three, then do the next
        subdivision pass and possibly shade again.
    - This approach would make more logical sense in terms of bounces
        and subdivision passes.
    - This approach could result in less subdivision if the bounces flatting out
        the illumination in shadows.
    - How does my current scheme work?
        - mIlluminatedColor3fAttributeKey, on face vertices, is the input illumination.
        - mIlluminatedColor3fAttributeKey is copied to mInputIlluminationAttributeKey.
        - mIndirectIllumination3fAttributeKey, on face vertices, will be the output illumination.
            - The final illumination is accumulated here after every bounce.
        - Loop over each bounce.
            - Reset mSampledIlluminationAttributeKey to zero on each face and face vertex.
                This is where samples via fired rays are stored.
            - Flags indicating which faces need to be sampled are reset so that all faces
                will be sampled.
            - Loop over the adaptive subdivision passes.
                - Reset the AABB tree of faces, because faces may have just been split
                    on the previous iteration.
                - Shade the faces marked as needing sampling, by firing rays. Samples
                    are stored at face and face vertex centers.
                    mInputIlluminationAttributeKey is sampled where rays intersect faces,
                    as well as the sky color on the first bounce only.
                - Subdivide faces whose samples indicate a discontinuity.
            - Compute mOutputIlluminationAttributeKey on face vertices
                by combining adjacent samples.
            - Add mOutputIlluminationAttributeKey to the current total indirect illumination
                on each face vertex.
            - Copy mOutputIlluminationAttributeKey to mInputIlluminationAttributeKey
                on each face vertex, so it can be sampled on the next pass.
        - Compute the final vertex colors by summing the direct and indirect illumination.
    - How would the new scheme work?
        - Loop over each adaptive subdivision pass.
            - Loop over each bounce.

- Fix indirect lighting errors:
    - Note: At some point during my first attempt at implementing the following,
        several more artifacts showed up on the side of the house. 
        Try all all this again and pay close attention to when the artifacts show up.
    - Add a class-level boolean to restrict sampling to face centers, and set it
        on the final level of adaptive subdivision, where additional sampling will not
        help much and is most expensive, and where it would be slowest.
        - Also set the flag on all bounces after the first.
    X The diffuse coefficient must be incorported into the illumination calculation
        at each bounce, not just once at the end.
    X The diffuse colors of the surfaces must be incorporated into the illumination
        calculation. I don't do this at all so it's as if the indirect illumination
        is always being reflected by white surfaces.
    X Modify the new code so that adaptive subdivision only happens during
        the first bounce, and assume this is good enough for what I want.
    X Don't bother exchanging the adaptive subdivision and bounce loops. It would
        probably be too expensive anyway.

X Try to run a test to see if I am getting dark leaks from under the
    house out to the edges of the house. The polygons on the ground near
    the base of the house share vertices and normals with the polygons
    under the house, so I think they might be contributing to the indirect
    illumination of the face vertices around the base of the house.
    X If this is really happening, can I do anything to resolve this, like
    X Look at other faces adjacent to the vertex being shaded, and not
        consider samples that are behind those faces?
    X One possibility is that I could use the direct illumination as a guide,
        in addition to unique normals, as I do now.
        X This can't work in general, because there are no discontinuities in the
            direct illumination on the shadowed side of the base do of the house.
    X How about testing for edges with multiple adjacent faces? Is that good enough?
        Do a test where all of these edges are marked with geometry.
    X I fudged around this by editing the model. In the future,
        I really, really really would have to make a robust preprocessor to
        resolve all intersecting or nonmanifold geometry as much as possible.

X The current adaptive subdivision approach has a problem.
    X Four samples on each face are used to make the decision about adaptive subdivision.
    X However, these samples could all have similar intensity, resulting in no adaptive
        subdivision, but then the actual intensity values assigned to each vertex
        could be quite different, depending on their neighbors. This would result
        in error from the vertices being spread out across the faces.
    X I need a better strategy for determining when to adaptively subdivide each face,
        that takes neighboring faces into account.
    X How about something like this:
        X Call convertSampledIlluminationToOutputIllumination before subdivideFaces,
            instead of after.
        X Make subdivideFaces use the output illumination values for the face vertices
            instead of the sampled illumination.

- rfm_discmesh incorporates existing face vertex colors into the lighting calculation,
    but then these are overridden when the results are written out,
    as copies of the computed direct illumination, so I can view them in WRL files.
    This means that rfm_indirect can't use these colors in the same way,
    which is incorrect.
    - Make rfm_discmesh stop doing this.
    - Rename the direct illumination attribute that rfm_discmesh is writing out 
        from "illuminatedColor3f" to "directIllumination3f" 
        to match "indirectIllumination3f" defined in rfm_indirect,
        and then modify rfm_indirect to use this new attribute.
    - Give rfm2wrl an option to output the direct illumination defined at each face vertex
        instead of the standard face vertex colors.
    - Recreate the craftsman model with this new attribute defined,
        and the original face colors. Test this with rfm2wrl.
    - Make rfm_indirect call mesh::MaterialTable::getFaceVertexDiffuseColor
        in MeshShader::sampleIndirectIllumination (in a routine that 
        uses barycentric coordinates to interpolate properly),
        so it takes all the diffuse colors into account.

X rfm_indirect has some kind of weird white vertex problem.
    X On a one bounce one pass run, one of the bad vertices is:
        6.90269, 0, -0.0276108

X Create a rfm_discmesh test model that demonstrates the problem I noticed
    on the color bleeding test where long skinny polygons mess up the lighting
    in areas that would not be an issue if I was handling EEE events correctly.

X The color bleeding test has faceting artifacts.

- Change rfm_indirect --samples-per-vertex to --samples-per-face, and then divide these
    evenly amongst the sample points on each face.

** Do whatever it takes to make the temple test look good.
    - The groundplane faces aren't being split correctly.
    - Manually delete the overlapping faces.
    - Fix light leaks around pillars. Can the groundplane filtering flow around the pillars,
        rather than across them?

- Rip out the adaptive subdivision.

** Try to get the Sponza atrium model working.
    - When I tried running this on a triangulated version of the original model,
        it got stuck in Retriangulator::filterFaceLineSegments for 11 hours.
        I'm not sure if it was looping indefinitely or not.
        - Put print statements in this function, along with an output of loopCount,
            and try it again.
    - Write a program to remesh large faces.
    X In assets/sponza/RUN, rfm_split loops forever in
        RetriangulatorFace::correctSelfIntersectingFacePerimeterLineSegments.
        This is a triangle that does not half any line segments of its own,
        but must be split because it is adjacent to a line segment that is being split.
        X I fixed this by writing DegenerateFaceCollapser.

** Consider replacing the direct illumination shading backprojection code with ray firing.
    I suspect this would result in O(n log n) behavior instead of O(n^2).

** Options for what to do next:
    X Replace all makefiles in the assets directory with RUN scripts.
    X Consider replacing the two calls to 'exit' in meshretri with exceptions.
        Make sure everything is exception safe.    
    - Test shifting a model 10,000 and 100,000 units away from the origin.
        - The blocks test fails when shifted even 100 units.
        - In the overhang model, an offset of 100 is OK, but errors show up
            at an offset of 1000. These all look like problems in the discontinuity
            mesh calculation, in the vicinity of shadow contact points.
            - It'd be great if I could correct these errors in this one case,
                without resorting to doubles everywhere.
    X Rename rfm_discmesh to rfm_direct.
    - Clean up rfm_indirect's command line arguments.
    - Move all test models out of the assets directory.
    - Make sure I'm using the correct terminology in rfm_indirect, 
        where I am currently using the word "illumination".
    - Fix the issue with the artifact on the left side of the blocks test,
        caused by geometry that is nearly aligned with the light direction.
    - Add code to handle EEE events correctly, because they frequently cause artifacts.
    - Perform lighting in linear space.
        - Try to convert everything over to use linear space internally, but, as a hack,
            to avoid artifacts, interpolate visibility in rfm_discmesh in gamma space
            rather than in linear space, under the assumption that the final output vertex colors
            will be interpolated in gamma space as well.
    - Figure out a way to make rfm_indirect/OutputIlluminationAssigner not sample
        the mesh around corners or through walls, which is causing light/dark leaks.
    - Write a program that uses edge collapsing to simplify the model where error would
        not be introduced, to strip out unneeded polygons. Start with the smallest edges.
    - Invent a magical way of introducing more vertices where the indirect illumination
        varies quickly.
        - How about, for convex edges, firing rays into the environment to find
            the average direction that light is coming from,
            and using this vector to somehow calculate effective penumbra/umbra edges,
            or something like that.
    - Write a 3D viewer program to create screen shots for a web page writeup.
        - Add the ability to highlight edges.
        - Combine multiple images with jittered offsets for antialising.
        - Support writing out and reusing camera positions so a sequence of images will match up.
    - Take pictures downtown and make a model based on that.
    - Write an efficient ray tracing engine using SIMD, cache-awareness, and ray packets.
        - In a future version of this, for maximum speed, maybe I could get away with
            doing all the discontinuity mesh calculation using doubles, for accuracy,
            but shoot rays for shading using floats, for speed.

** High priority items from the list above:
    - Rewrite the direct illumination computation based on ray tracing,
        so that it is O(N log N) instead of O(N^2).
    - Make mesh::Triangulator always work, even for degenerate faces.
        X Have it first treat quads as a special case, without using
            the Delaunay code at all. That way it will be able to trivially
            handle degenerate quads.
         - Faces in the sponza atrium that originally had holes in them have faces
            that wrap back on themselves and repeat vertices.
    - Try to handle a larger set of models.
        X Make a small test model to demonstrate the degenerate face case I'm not handling,
            and then make DegenerateEdgeCollapser handle that case.
        - Write code to remove faces like the ones on the groundplane that lie inside
            other objects. These faces overlap other faces with opposing geometric normals.
            - Maybe I do this by firing rays from the center of each polygon and see
                if the first faces they intersect are backfacing.
        - Write code to split faces where they intersect.
    - Write a program to remesh large faces.
        - Do this to connected regions of coplanar faces.
        - Could I do this using equilateral triangles?
    - Try to get the Sponza atrium model working.

X Fix DegenerateEdgeCollapser so it handles degenerate triangles where one vertex
    intersects the opposite edge, and then make the assets/interior test work.
    X DegenerateEdgeCollapser only collapses degenerate edges.
        It doesn't do anything with faces that have one vertex that splits
        one of the other edges.
    X Write a new class, DegenerateFaceCollapser.
        X Assert that the mesh is all triangles.
        X Build a vector of all degenerate faces so we can modify the mesh 
            as we're looping over them.
        X Use ElementTracker to ensure we don't visit faces we've already deleted.
            X Since we'll be creating new faces through splitting, I'm concerned that
                ElementTracker will register false positives.
                X Address this by adding ElementTracker functions for removing
                    addresses of newly created faces from the ElementTracker, assuming they
                    exist in the ElementTracker at all.
        X Make CreateTriangularFaceAndEdgesFromVertices use an optional ElementTracker,
            to take deleted and created elements.
        X Make SplitEdgeTriangulator use an optional ElementTracker, to track
            deleted and created elements.
        X Loop over all the degenerate faces.
            X If the three vertices are all nearly coincident with each other,
                collapse them all to a single vertex.
            X If any pair of vertices are nearly coincident, merge them.
            X If any vertices are nearly coincident with opposing edges, then:
                X Split the opposing edge at the same location as the vertex.
                X Retriangulate all faces adjacent to the edge that was split,
                    using SplitEdgeTriangulator, including the degenerate face
                    we're trying to collapse. This is important because the vertex
                    merging function (and really the edge collapsing function it calls)
                    we're about to call requires that all faces are triangles.
                X Merge the original vertex and the newly created vertex.
                    This will remove the split degenerate face.
            X Make sure everything is tracked with the ElementTracker.
        X Repeat the above steps until no more degenerate faces are encountered.
            X Throw an exception if this loops 100 times.

X I moved SplitEdgeTriangulator to the mesh library, so now I need unit tests for it.

X Make DegenerateEdgeCollapser::filter throw an exception in an infinite loop condition,
    rather than assert, and comment this fact.

X Write a unit test for GetTriangularFaceAdjacentVertices.

X Write a unit test for and GetTriangularFaceAdjacentEdges.

X Check if there are any more functions in 'mesh' without unit tests.

X Rewrite the face collapsing code in DegenerateFaceCollapser::removeDegenerateFaces
    in terms of new higher level functions that test if all the vertices of
    a face are nearly coincident, and which collapse a face to single vertex.

X Consider renaming ElementTracker to DeletedElementTracker, or renaming some of its
    member functions or inverting the logic of how it is used, to remove ambiguity.

X Make the default behavior of obj2rfm be to reset the mesh's normals.
    Since Silo's output normals assume a smooth surface, this is what I always want,
    and I keep forgetting to specify the --reset-normals flag,
    and when I do, I usually don't immediately realize why the output looks awful.

X The 'interior' test is extremely dark inside.
    X Write a program to scale computed lighting from the command line.
    X Write rfm_relight, to quickly recompute the face vertex colors based on
        direct and indirect lighting.
        Options to adjust the direct and indirect lighting:
        X Brightness
        - Contrast
        X Saturation
        - Hue or tint or something

X Add support for DeletedElementTracker to all other functions that create or destroy
    mesh elements, like DeleteEdge.

X Write a script to search for source files that are wider than 100 characters.

X In assets/sponza, this crashes:
    rfm_degenerate.debug sponza.rfm out.rfm --debug

X Replace the assert in DegenerateFaceCollapser to an exception.

X Now this fails.
    rfm_degenerate.debug sponza.rfm out.rfm --debug

X The sponza test fails in rfm_degenerate when it tries to collapse an edge
    whose vertices are shared by another edge.
    X I think this bogus edge is being introduced by rfm_split,
        immediately before rfm_degenerate is called.

- Consider renaming CollapseEdge everywhere, and adding another CollapseEdge function
    that simply calls MergeVertexIntoVertex, to better deal with the case where
    multiple edges are adjacent to the same two vertices.

X In the sponza test, this now fails:
    rfm_degenerate.debug sponza-split.rfm out.rfm --debug
    X DegenerateFaceCollapser detects an infinite loop because 
        it keeps flipping the same edges repeatedly.
    X Maybe after calling SplitEdgeAndAdjacentTriangularFaces I could test if
        any of the resulting faces are degenerate, and collapse them
        instead of merging the vertices.

X I screwed up the way exceptions work. Once operator<< is used, a class like
    FailedOperationException turns into Exception or ErrorException or something.

X Refactor ProgramOptionsParser::parse.

X Rename RETRO_APPLE, etc. to OS_APPLE to match the new library name.

** In the sponza test, this is failing again:
    rfm_degenerate.debug sponza-split.rfm out.rfm --debug
    - DegenerateFaceCollapser gets stuck in an infinite loop flipping degenerate faces.
    - There is a case where DegenerateFaceCollapser::removeDegenerateFaces removes
        one degenerate face, but winds up creating another degenerate face,
        and this can go on forever.
    - The problem occurs when the degenerate triangle, combined with its adjacent triangle,
        forms a quadrilateral that has one very short edge.
    - In DegenerateFaceCollapser::removeDegenerateFaces, after calling
        GetClosestPointOnLineSegment3f, determine if splitting the edge at this point 
        and retriangulating the faces would result in another degenerate face.
        - Get the positions of the four vertices of the original triangles, in order.
        - Using the new split point, determine if any of the resulting triangles
            would be degenerate.
            - Write cgmath::TriangleIsDegenerate, using similar logic to FaceIsDegenerate.
            - Write unit tests for it.
    - If that's true, replace the two triangles with four new triangles,
        adding a new vertex at the average position of the four vertices of the
        original triangles.
        - Create the new triangles.
        - Copy the attributes of the largest of the original two faces to the new faces.
        - Copy face vertex attributes to the new faces.
        - Delete the old triangle.
